"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/lib/web3Service.ts":
/*!********************************!*\
  !*** ./src/lib/web3Service.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Web3Service: () => (/* binding */ Web3Service),\n/* harmony export */   web3Service: () => (/* binding */ web3Service)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/hash/solidity.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/utils/units.js\");\n// @ts-nocheck\n// TypeScript is disabled in this file due to dynamic contract interactions across\n// multiple KaiSign versions and ethers v6 function APIs (e.g., .staticCall, .estimateGas\n// on function objects). Strong typing here caused noisy, non-actionable errors and\n// duplicate API variants; runtime behavior is preserved.\n\n// ABI for the KaiSign V1 contract - Updated to match actual contract interface\nconst CONTRACT_ABI = [\n    {\n        \"inputs\": [],\n        \"name\": \"minBond\",\n        \"outputs\": [\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"commitment\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"targetChainId\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"commitSpec\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"commitmentId\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"blobHash\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"metadataHash\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"nonce\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"revealSpec\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"specID\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"stateMutability\": \"payable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"specID\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"proposeSpec\",\n        \"outputs\": [],\n        \"stateMutability\": \"payable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"specID\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"assertSpecValid\",\n        \"outputs\": [],\n        \"stateMutability\": \"payable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"specID\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"assertSpecInvalid\",\n        \"outputs\": [],\n        \"stateMutability\": \"payable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"targetChainId\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"amount\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"duration\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"string\",\n                \"name\": \"description\",\n                \"type\": \"string\"\n            }\n        ],\n        \"name\": \"createIncentive\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"incentiveId\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"stateMutability\": \"payable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"user\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"getUserIncentives\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bytes32[]\",\n                \"name\": \"\",\n                \"type\": \"bytes32[]\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"incentiveId\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"incentives\",\n        \"outputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"creator\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"uint80\",\n                \"name\": \"amount\",\n                \"type\": \"uint80\"\n            },\n            {\n                \"internalType\": \"uint16\",\n                \"name\": \"reserved1\",\n                \"type\": \"uint16\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"deadline\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"createdAt\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"isClaimed\",\n                \"type\": \"bool\"\n            },\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"isActive\",\n                \"type\": \"bool\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"chainId\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"internalType\": \"string\",\n                \"name\": \"description\",\n                \"type\": \"string\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"commitmentId\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"commitments\",\n        \"outputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"committer\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"commitTimestamp\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"reserved1\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"isRevealed\",\n                \"type\": \"bool\"\n            },\n            {\n                \"internalType\": \"uint80\",\n                \"name\": \"bondAmount\",\n                \"type\": \"uint80\"\n            },\n            {\n                \"internalType\": \"uint8\",\n                \"name\": \"reserved\",\n                \"type\": \"uint8\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"revealDeadline\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"chainId\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"incentiveId\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"chainId\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"getSpecsByContract\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bytes32[]\",\n                \"name\": \"\",\n                \"type\": \"bytes32[]\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"specId\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"specs\",\n        \"outputs\": [\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"createdTimestamp\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"proposedTimestamp\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"uint8\",\n                \"name\": \"status\",\n                \"type\": \"uint8\"\n            },\n            {\n                \"internalType\": \"uint80\",\n                \"name\": \"totalBonds\",\n                \"type\": \"uint80\"\n            },\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"reserved\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"creator\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"blobHash\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"questionId\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"incentiveId\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"chainId\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"specID\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"handleResult\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"specID\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"token\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"claimActiveTokenIncentive\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"specID\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"settleBonds\",\n        \"outputs\": [],\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"string\",\n                \"name\": \"ipfs\",\n                \"type\": \"string\"\n            }\n        ],\n        \"name\": \"getStatus\",\n        \"outputs\": [\n            {\n                \"internalType\": \"uint8\",\n                \"name\": \"\",\n                \"type\": \"uint8\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"string\",\n                \"name\": \"ipfs\",\n                \"type\": \"string\"\n            }\n        ],\n        \"name\": \"isAccepted\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"string\",\n                \"name\": \"ipfs\",\n                \"type\": \"string\"\n            }\n        ],\n        \"name\": \"getCreatedTimestamp\",\n        \"outputs\": [\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"\",\n                \"type\": \"uint64\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"targetChainId\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"amount\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"duration\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"string\",\n                \"name\": \"description\",\n                \"type\": \"string\"\n            }\n        ],\n        \"name\": \"createIncentive\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"incentiveId\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"stateMutability\": \"payable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"chainId\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"getSpecsByContract\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bytes32[]\",\n                \"name\": \"\",\n                \"type\": \"bytes32[]\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"getContractSpecCount\",\n        \"outputs\": [\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"specs\",\n        \"outputs\": [\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"createdTimestamp\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"proposedTimestamp\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"uint8\",\n                \"name\": \"status\",\n                \"type\": \"uint8\"\n            },\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"bondsSettled\",\n                \"type\": \"bool\"\n            },\n            {\n                \"internalType\": \"uint48\",\n                \"name\": \"totalBonds\",\n                \"type\": \"uint48\"\n            },\n            {\n                \"internalType\": \"uint8\",\n                \"name\": \"reserved\",\n                \"type\": \"uint8\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"creator\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"string\",\n                \"name\": \"ipfs\",\n                \"type\": \"string\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"questionId\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"incentiveId\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"commitments\",\n        \"outputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"committer\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"commitTimestamp\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"reserved1\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"isRevealed\",\n                \"type\": \"bool\"\n            },\n            {\n                \"internalType\": \"uint80\",\n                \"name\": \"bondAmount\",\n                \"type\": \"uint80\"\n            },\n            {\n                \"internalType\": \"uint8\",\n                \"name\": \"reserved\",\n                \"type\": \"uint8\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"revealDeadline\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"chainId\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"incentiveId\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"incentives\",\n        \"outputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"creator\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"token\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"uint128\",\n                \"name\": \"amount\",\n                \"type\": \"uint128\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"deadline\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"createdAt\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"isClaimed\",\n                \"type\": \"bool\"\n            },\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"isActive\",\n                \"type\": \"bool\"\n            },\n            {\n                \"internalType\": \"uint80\",\n                \"name\": \"reserved\",\n                \"type\": \"uint80\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"chainId\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"internalType\": \"string\",\n                \"name\": \"description\",\n                \"type\": \"string\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [],\n        \"name\": \"realityETH\",\n        \"outputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"\",\n                \"type\": \"address\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [],\n        \"name\": \"treasury\",\n        \"outputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"\",\n                \"type\": \"address\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"internalType\": \"address\",\n                \"name\": \"committer\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": true,\n                \"internalType\": \"bytes32\",\n                \"name\": \"commitmentId\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": true,\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint256\",\n                \"name\": \"chainId\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint256\",\n                \"name\": \"bondAmount\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint64\",\n                \"name\": \"revealDeadline\",\n                \"type\": \"uint64\"\n            }\n        ],\n        \"name\": \"LogCommitSpec\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"internalType\": \"bytes32\",\n                \"name\": \"incentiveId\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": true,\n                \"internalType\": \"address\",\n                \"name\": \"creator\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": true,\n                \"internalType\": \"address\",\n                \"name\": \"targetContract\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint256\",\n                \"name\": \"chainId\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"address\",\n                \"name\": \"token\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint256\",\n                \"name\": \"amount\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"uint64\",\n                \"name\": \"deadline\",\n                \"type\": \"uint64\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"string\",\n                \"name\": \"description\",\n                \"type\": \"string\"\n            }\n        ],\n        \"name\": \"LogIncentiveCreated\",\n        \"type\": \"event\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"bondsSettled\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    }\n];\n// Reality.eth contract ABI (minimal for bond calculations)\nconst REALITY_ETH_ABI = [\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"question_id\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"getBond\",\n        \"outputs\": [\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"question_id\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"getMinBond\",\n        \"outputs\": [\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"questions\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"content_hash\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"arbitrator\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"opening_ts\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"timeout\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"uint32\",\n                \"name\": \"finalize_ts\",\n                \"type\": \"uint32\"\n            },\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"is_pending_arbitration\",\n                \"type\": \"bool\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"bounty\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"best_answer\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"history_hash\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"bond\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"min_bond\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    }\n];\n// Reality.eth contract address (Sepolia by default)\nconst REALITY_ETH_ADDRESS =  false || \"0xaf33DcB6E8c5c4D9dDF579f53031b514d19449CA\";\n// Contract address (configurable via NEXT_PUBLIC_KAISIGN_CONTRACT_ADDRESS; falls back to known Sepolia addr)\nconst RAW_CONTRACT_ADDRESS =  false || \"0x4dFEA0C2B472a14cD052a8f9DF9f19fa5CF03719\";\n// Chain ID (configurable via NEXT_PUBLIC_CHAIN_ID, defaults to Sepolia)\nconst SEPOLIA_CHAIN_ID = Number(\"11155111\" || 0);\nclass Web3Service {\n    /**\n   * Connect to MetaMask and initialize the contract\n   */ async connect() {\n        if (false) {}\n        if (!window.ethereum) {\n            throw new Error(\"MetaMask is not installed. Please install MetaMask to continue.\");\n        }\n        try {\n            // Request account access\n            const accounts = await window.ethereum.request({\n                method: \"eth_requestAccounts\"\n            });\n            if (!accounts || accounts.length === 0) {\n                throw new Error(\"No accounts found. Please make sure MetaMask is unlocked.\");\n            }\n            // Initialize provider and signer\n            this.provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n            this.signer = await this.provider.getSigner();\n            // Initialize contract (network check moved to individual functions that need it)\n            const kaisignContract = new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(RAW_CONTRACT_ADDRESS, CONTRACT_ABI, this.signer);\n            // Assign to instance variables after successful initialization\n            this.contract = kaisignContract;\n            // Initialize Reality.eth contract now for read calls (bond info)\n            this.realityEthContract = new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(REALITY_ETH_ADDRESS, REALITY_ETH_ABI, this.provider);\n            return accounts[0];\n        } catch (error) {\n            console.error(\"Error connecting to MetaMask:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Check if we're on the Sepolia network\n   */ async checkNetwork() {\n        if (!this.provider) return false;\n        try {\n            const network = await this.provider.getNetwork();\n            return Number(network.chainId) === SEPOLIA_CHAIN_ID;\n        } catch (error) {\n            console.error(\"Error checking network:\", error);\n            return false;\n        }\n    }\n    /**\n   * Get the minimum bond amount required for a new question from the KaiSign contract\n   */ async getMinBond() {\n        try {\n            if (!this.contract) {\n                throw new Error(\"Contract not initialized. Please connect first.\");\n            }\n            const minBond = await this.contract.minBond();\n            return minBond;\n        } catch (error) {\n            console.error(\"Error getting minimum bond from contract:\", error);\n            // Fallback to a reasonable default if contract call fails\n            const fallbackBond = BigInt(\"100000000000000\"); // 0.0001 ETH\n            return fallbackBond;\n        }\n    }\n    /**\n   * Calculate the required bond for answering a specific question\n   * Based on Reality.eth rules: first answer needs min_bond, subsequent answers need 2x previous bond\n   */ async getRequiredBondForQuestion(questionId) {\n        try {\n            if (!this.realityEthContract) {\n                if (!this.provider) {\n                    throw new Error(\"Wallet not connected. Please connect first.\");\n                }\n                this.realityEthContract = new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(REALITY_ETH_ADDRESS, REALITY_ETH_ABI, this.provider);\n            }\n            // Get the current bond for this question\n            const currentBond = await this.realityEthContract.getBond(questionId);\n            if (currentBond === BigInt(0)) {\n                // No previous answers, use minimum bond\n                const minBond = await this.realityEthContract.getMinBond(questionId);\n                return minBond;\n            } else {\n                // Previous answers exist, need to double the current bond\n                const requiredBond = currentBond * BigInt(2);\n                return requiredBond;\n            }\n        } catch (error) {\n            console.error(\"Error calculating required bond for question:\", error);\n            // Fallback to contract minimum bond\n            return await this.getMinBond();\n        }\n    }\n    /**\n   * Get bond information for a question (current bond, minimum bond, and required next bond)\n   * In V1, we need to check if a spec exists first\n   */ async getBondInfo(ipfsHash1) {\n        try {\n            if (!this.contract) {\n                throw new Error(\"Contract not initialized. Please connect first.\");\n            }\n            if (!this.realityEthContract) {\n                if (!this.provider) {\n                    throw new Error(\"Wallet not connected. Please connect first.\");\n                }\n                this.realityEthContract = new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(REALITY_ETH_ADDRESS, REALITY_ETH_ABI, this.provider);\n            }\n            // Generate specID from identifier (now blob versioned hash)\n            const specId = ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes(ipfsHash1));\n            try {\n                // Check if spec exists and get its data\n                const spec = await this.contract.specs(specId);\n                const questionId = spec.questionId;\n                if (questionId === \"0x0000000000000000000000000000000000000000000000000000000000000000\") {\n                    // Question doesn't exist yet, return contract minimum bond with safety margin\n                    const contractMinBond = await this.getMinBond();\n                    const requiredBond = BigInt(\"20000000000000000\"); // Use 0.02 ETH instead of calculated amount\n                    return {\n                        currentBond: BigInt(0),\n                        minBond: contractMinBond,\n                        requiredNextBond: requiredBond,\n                        hasAnswers: false\n                    };\n                }\n                // Get bond information from Reality.eth\n                const currentBond = await this.realityEthContract.getBond(questionId);\n                const minBond = await this.realityEthContract.getMinBond(questionId);\n                const hasAnswers = currentBond > BigInt(0);\n                const baseRequiredBond = hasAnswers ? currentBond * BigInt(2) : minBond;\n                // Add safety margin for all bonds\n                const requiredNextBond = BigInt(\"15000000000000000\"); // Use 0.015 ETH instead of calculated amount\n                return {\n                    currentBond,\n                    minBond,\n                    requiredNextBond,\n                    hasAnswers\n                };\n            } catch (specError) {\n                // Spec doesn't exist yet, return contract minimum bond with safety margin\n                const contractMinBond = await this.getMinBond();\n                const requiredBond = BigInt(\"20000000000000000\"); // Use 0.02 ETH instead of calculated amount\n                return {\n                    currentBond: BigInt(0),\n                    minBond: contractMinBond,\n                    requiredNextBond: requiredBond,\n                    hasAnswers: false\n                };\n            }\n        } catch (error) {\n            console.error(\"Error getting bond info:\", error);\n            // Fallback to contract minimum bond with safety margin\n            const contractMinBond = await this.getMinBond();\n            const requiredBond = contractMinBond + contractMinBond / BigInt(10); // Add 10% safety margin\n            return {\n                currentBond: BigInt(0),\n                minBond: contractMinBond,\n                requiredNextBond: requiredBond,\n                hasAnswers: false\n            };\n        }\n    }\n    /**\n   * Commit spec using V1 contract (step 1 of commit-reveal pattern)\n   */ // The commitSpec method no longer takes an incentiveId. Incentives are created ahead\n    // of time and automatically assigned when a spec is accepted. The function signature\n    // accepts blobHash, bondAmount, an optional targetContract and optional chainId.\n    async commitSpec(blobHash, bondAmount, targetContract, targetChainId) {\n        try {\n            if (!this.contract || !this.signer) {\n                throw new Error(\"Not connected to MetaMask. Please connect first.\");\n            }\n            // Make sure we're on the Sepolia network\n            // Network check removed - let users connect on any network\n            // Generate a proper nonce for the commitment\n            const nonce = BigInt(Math.floor(Math.random() * 1000000));\n            // The blobHash parameter is actually the metadataHash (hash of JSON)\n            // This is a naming issue - it should be called metadataHash\n            const metadataHash = blobHash;\n            // Create the commitment using metadataHash and nonce (as per contract)\n            const commitment = ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_4__.solidityPacked([\n                \"bytes32\",\n                \"uint256\"\n            ], [\n                metadataHash,\n                nonce\n            ]));\n            // The V1 contract requires the target contract to exist on Sepolia (extcodesize check)\n            // For ERC7730 specs, we want to allow any contract address (even from other chains)\n            // But V1 contract validates existence, so we need a deployed contract on Sepolia\n            let target = targetContract;\n            // Known working Sepolia contracts for testing\n            const validSepoliaContracts = [\n                RAW_CONTRACT_ADDRESS,\n                \"0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238\",\n                \"0x779877A7B0D9E8603169DdbD7836e478b4624789\"\n            ];\n            if (!target || target.trim() === \"\" || !target.match(/^0x[a-fA-F0-9]{40}$/)) {\n                // Use KaiSign contract as default if no valid target specified\n                target = RAW_CONTRACT_ADDRESS;\n            } else {\n                // Check if the target contract exists on Sepolia\n                try {\n                    const targetCode = await this.provider.getCode(target);\n                    if (targetCode === \"0x\") {\n                        console.warn(\"⚠️ Target contract\", target, \"does not exist on Sepolia\");\n                        console.warn(\"V1 contract requires target to exist on same network\");\n                        console.warn(\"Falling back to KaiSign contract as target\");\n                        target = RAW_CONTRACT_ADDRESS;\n                    } else {}\n                } catch (codeCheckError) {\n                    console.warn(\"Could not verify target contract existence, using KaiSign contract as fallback\");\n                    target = RAW_CONTRACT_ADDRESS;\n                }\n            }\n            // Incentives are no longer passed during commit. Any incentive will be automatically\n            // associated by the contract when a spec is accepted. Keep a zero bytes32 for\n            // compatibility in logs if needed.\n            const finalIncentiveId = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n            // Validate minimum bond requirement with safety margin\n            const contractMinBond = await this.getMinBond();\n            // Add 10% safety margin to account for platform fees and rounding\n            const requiredBond = contractMinBond + contractMinBond / BigInt(10);\n            if (bondAmount < requiredBond) {\n                throw new Error(\"Insufficient bond. Required: \".concat((Number(requiredBond) / 10 ** 18).toFixed(5), \" ETH (including safety margin for fees)\"));\n            }\n            // CRITICAL: Run comprehensive diagnostics BEFORE attempting transaction\n            // For commitSpec, we don't send any value, so pass 0n for bond amount\n            await this.runPreTransactionDiagnostics(target, 0n);\n            // Additional validation: Check if contract is properly deployed and accessible\n            try {\n                const contractCode = await this.provider.getCode(RAW_CONTRACT_ADDRESS);\n                // Test a simple read function first\n                const testMinBond = await this.contract.minBond();\n                // Check if contract is paused (V1 has Pausable)\n                try {\n                    // Try to call the paused() function if it exists\n                    const pausedCall = await this.provider.call({\n                        to: RAW_CONTRACT_ADDRESS,\n                        data: \"0x5c975abb\" // paused() function selector\n                    });\n                    const isPaused = pausedCall === \"0x0000000000000000000000000000000000000000000000000000000000000001\";\n                    if (isPaused) {\n                        throw new Error(\"Contract is currently paused\");\n                    }\n                } catch (pauseCheckError) {}\n                // Special test: Check if the target contract validation is the issue\n                const targetContractCode = await this.provider.getCode(target);\n                if (targetContractCode === \"0x\") {\n                    console.error(\"❌ FOUND THE ISSUE: Target contract has no code!\");\n                    console.error(\"The contract's extcodesize check will fail for this target.\");\n                    throw new Error(\"Target contract \".concat(target, \" does not exist or has no bytecode. The V1 contract requires the target contract to exist on Sepolia.\"));\n                } else {}\n                // Check if treasury address is valid and can receive funds\n                try {\n                    // Get treasury address from the contract\n                    const treasurySelector = \"0x61d027b3\"; // treasury() function selector\n                    const treasuryResult = await this.provider.call({\n                        to: RAW_CONTRACT_ADDRESS,\n                        data: treasurySelector\n                    });\n                    const treasuryAddress = \"0x\" + treasuryResult.slice(-40);\n                    // Check if treasury is a valid address (not zero address)\n                    if (treasuryAddress === \"0x0000000000000000000000000000000000000000\") {\n                        console.error(\"❌ ISSUE FOUND: Treasury address is zero address!\");\n                        throw new Error(\"Treasury address is not set properly in the contract\");\n                    }\n                    // Check if treasury can receive funds (not a contract that might reject)\n                    const treasuryCode = await this.provider.getCode(treasuryAddress);\n                    if (treasuryCode.length > 2) {\n                        // Try a tiny test transfer to see if treasury can receive funds\n                        try {\n                            const testAmount = BigInt(1); // 1 wei\n                            await this.provider.call({\n                                to: treasuryAddress,\n                                value: testAmount,\n                                from: await this.signer.getAddress()\n                            });\n                        } catch (treasuryTestError) {\n                            console.error(\"❌ POSSIBLE ISSUE: Treasury might reject fund transfers:\", treasuryTestError);\n                        }\n                    } else {}\n                } catch (treasuryError) {\n                    console.error(\"Could not check treasury address:\", treasuryError);\n                }\n            } catch (contractError) {\n                console.error(\"Contract accessibility test failed:\", contractError);\n                throw contractError; // Re-throw the specific error instead of generic one\n            }\n            // Step 1: Commit\n            // Check if commitment already exists\n            try {\n                const commitmentId = ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_4__.solidityPacked([\n                    \"bytes32\",\n                    \"address\",\n                    \"address\",\n                    \"uint256\"\n                ], [\n                    commitment,\n                    await this.signer.getAddress(),\n                    target,\n                    Math.floor(Date.now() / 1000)\n                ]));\n                const existingCommitment = await this.contract.commitments(commitmentId);\n                console.log(\"Checking if commitment already exists:\", existingCommitment.committer !== ethers__WEBPACK_IMPORTED_MODULE_5__.ZeroAddress);\n                // Try a static call first to see if it would succeed\n                const staticResult = await this.contract.commitSpec.staticCall(commitment, target, targetChainId || 1);\n                console.log(\"Static call successful, proceeding with transaction\");\n            } catch (checkError) {\n                console.error(\"Pre-transaction checks failed:\", checkError);\n                // If it's a revert, try to get more info\n                if (checkError.data) {}\n                throw new Error(\"Pre-transaction validation failed: \".concat(checkError.message));\n            }\n            // Try manual gas estimation\n            try {\n                const gasEstimate = await this.contract.commitSpec.estimateGas(commitment, target, targetChainId || 1);\n            } catch (gasError) {\n                console.error(\"Gas estimation failed:\", gasError);\n                throw new Error(\"Gas estimation failed: \".concat(gasError.message));\n            }\n            const commitTx = await this.contract.commitSpec(commitment, target, targetChainId || 1);\n            const commitReceipt = await commitTx.wait();\n            // Step 2: Extract the actual commitment ID from the LogCommitSpec event\n            let commitmentId = null;\n            for (const log of commitReceipt.logs){\n                try {\n                    const parsed = this.contract.interface.parseLog(log);\n                    if (parsed && parsed.name === 'LogCommitSpec') {\n                        commitmentId = parsed.args.commitmentId;\n                        break;\n                    }\n                } catch (e) {\n                // Ignore logs that can't be parsed by our interface\n                }\n            }\n            if (!commitmentId) {\n                throw new Error(\"Could not find LogCommitSpec event in transaction logs\");\n            }\n            return {\n                commitmentId,\n                commitTxHash: commitTx.hash,\n                revealDeadline: Math.floor(Date.now() / 1000) + 3600,\n                nonce: Number(nonce),\n                commitment,\n                metadataHash\n            };\n        } catch (error) {\n            var _error_message, _error_message1, _error_message2, _error_message3, _error_message4;\n            console.error(\"Error proposing spec:\", error);\n            // Enhanced error handling for V1 contract specific issues\n            if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"missing revert data\")) && !error.data) {\n                // Try a different approach - use a known good contract as target\n                const knownGoodContracts = [\n                    \"0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238\",\n                    \"0x779877A7B0D9E8603169DdbD7836e478b4624789\"\n                ];\n                for (const testTarget1 of knownGoodContracts){\n                    try {\n                        const testCode = await this.provider.getCode(testTarget1);\n                        if (testCode !== \"0x\") {\n                            return await this.directCommitReveal(ipfsHash, bondAmount, testTarget1);\n                        }\n                    } catch (testError) {}\n                }\n                try {\n                    return await this.directCommitReveal(ipfsHash, bondAmount, RAW_CONTRACT_ADDRESS);\n                } catch (directError) {\n                    console.error(\"Direct transaction also failed:\", directError);\n                // Continue with original error handling\n                }\n            }\n            // Try to decode custom error\n            if (error.reason) {\n                console.error(\"Contract revert reason:\", error.reason);\n            }\n            if (error.data) {\n                console.error(\"Contract error data:\", error.data);\n                // Try to decode known custom errors from the V1 contract\n                try {\n                    const errorSignatures = {\n                        \"0x4ca88867\": \"AlreadyProposed()\",\n                        \"0xfb8f41b2\": \"NotProposed()\",\n                        \"0x47df8ce0\": \"InsufficientBond()\",\n                        \"0xd2e74c4c\": \"InsufficientIncentive()\",\n                        \"0x6efc7261\": \"InvalidContract()\",\n                        \"0xed592624\": \"ContractNotFound()\",\n                        \"0x5fd9a6de\": \"InvalidIPFS()\",\n                        \"0x0982e9b5\": \"CommitmentNotFound()\",\n                        \"0x6e9ad0b3\": \"CommitmentExpired()\",\n                        \"0x4221d9dc\": \"CommitmentAlreadyRevealed()\",\n                        \"0x8baa579f\": \"InvalidReveal()\",\n                        \"0xf1a2b62a\": \"NotFinalized()\",\n                        \"0x9cf8e11f\": \"AlreadySettled()\",\n                        \"0xa7648c19\": \"NoIncentiveToClaim()\",\n                        \"0xc3e2a8b1\": \"IncentiveExpired()\",\n                        \"0x82b42900\": \"Unauthorized()\"\n                    };\n                    const errorSelector = error.data.slice(0, 10);\n                    const customError = errorSignatures[errorSelector];\n                    if (customError) {\n                        throw new Error(\"Contract reverted with: \".concat(customError));\n                    }\n                } catch (decodeError) {\n                    console.error(\"Could not decode error:\", decodeError);\n                }\n            }\n            // If we can't decode it, check for common issues\n            if (((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"insufficient funds\")) || ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"InsufficientBond\"))) {\n                throw new Error(\"Insufficient bond amount. Please check the minimum bond requirement.\");\n            }\n            if ((_error_message3 = error.message) === null || _error_message3 === void 0 ? void 0 : _error_message3.includes(\"ContractNotFound\")) {\n                throw new Error(\"The target contract \".concat(targetContract || 'specified', \" does not exist on Sepolia testnet. The V1 contract requires target contracts to be deployed on the same network. Please use a valid Sepolia contract address or leave empty for general specifications.\"));\n            }\n            if ((_error_message4 = error.message) === null || _error_message4 === void 0 ? void 0 : _error_message4.includes(\"InvalidContract\")) {\n                throw new Error(\"Invalid target contract address format.\");\n            }\n            throw new Error(\"Transaction failed: \".concat(error.message || 'Unknown error'));\n        }\n    }\n    /**\n   * Reveal spec using V1 contract (step 2 of commit-reveal pattern)\n   */ async revealSpec(commitmentId, blobHash, metadataHash, nonce, bondAmount) {\n        try {\n            if (!this.contract || !this.signer) {\n                throw new Error(\"Not connected to MetaMask. Please connect first.\");\n            }\n            console.log(\"revealSpec called with:\", {\n                commitmentId,\n                blobHash,\n                metadataHash,\n                nonce,\n                bondAmount: bondAmount.toString()\n            });\n            // Debug: Check what the contract has stored for this commitment\n            try {\n                const storedCommitment = await this.contract.commitments(commitmentId);\n                console.log(\"Stored commitment data:\", {\n                    committer: storedCommitment[0],\n                    commitTimestamp: storedCommitment[1].toString(),\n                    reserved1: storedCommitment[2].toString(),\n                    targetContract: storedCommitment[3],\n                    isRevealed: storedCommitment[4],\n                    bondAmount: storedCommitment[5].toString(),\n                    reserved: storedCommitment[6].toString(),\n                    revealDeadline: storedCommitment[7].toString(),\n                    chainId: storedCommitment[8].toString(),\n                    incentiveId: storedCommitment[9]\n                });\n                // Check if we're the right committer\n                const ourAddress = await this.signer.getAddress();\n                console.log(\"Our address:\", ourAddress);\n                console.log(\"Committer address:\", storedCommitment[0]);\n                // Check if commitment expired\n                const currentTime = Math.floor(Date.now() / 1000);\n                const revealDeadline = Number(storedCommitment[7]);\n                console.log(\"Current time:\", currentTime);\n                console.log(\"Reveal deadline:\", revealDeadline);\n                if (currentTime > revealDeadline) {\n                    throw new Error(\"Commitment has expired. Please create a new commitment.\");\n                }\n                // Let's verify what commitment the contract expects\n                const expectedCommitment = ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_4__.solidityPacked([\n                    \"bytes32\",\n                    \"uint256\"\n                ], [\n                    metadataHash,\n                    BigInt(nonce)\n                ]));\n                console.log(\"Expected commitment hash:\", expectedCommitment);\n                // Reconstruct the commitment ID as the contract would\n                const reconstructedCommitmentId = ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_4__.solidityPacked([\n                    \"bytes32\",\n                    \"address\",\n                    \"address\",\n                    \"uint256\",\n                    \"uint64\"\n                ], [\n                    expectedCommitment,\n                    storedCommitment[0],\n                    storedCommitment[3],\n                    storedCommitment[8],\n                    storedCommitment[1]\n                ]));\n                console.log(\"Reconstructed commitment ID:\", reconstructedCommitmentId);\n                console.log(\"Provided commitment ID:\", commitmentId);\n                console.log(\"Do they match?\", reconstructedCommitmentId === commitmentId);\n                if (reconstructedCommitmentId !== commitmentId) {\n                    console.error(\"Commitment ID mismatch! The nonce or metadata hash doesn't match what was used during commit.\");\n                    console.log(\"This commitment was created with a different nonce or metadata hash.\");\n                    console.log(\"Please ensure you're using the exact same nonce that was returned during commit.\");\n                }\n            } catch (debugError) {\n                console.log(\"Debug error (non-critical):\", debugError);\n            }\n            // Try a static call first to see what exactly fails\n            try {\n                await this.contract.revealSpec.staticCall(commitmentId, blobHash, metadataHash, BigInt(nonce), {\n                    value: bondAmount\n                });\n            } catch (staticError) {}\n            const revealTx = await this.contract.revealSpec(commitmentId, blobHash, metadataHash, BigInt(nonce), {\n                value: bondAmount\n            });\n            const revealReceipt = await revealTx.wait();\n            return revealTx.hash;\n        } catch (error) {\n            console.error(\"Error revealing spec:\", error);\n            throw new Error(\"Reveal failed: \".concat(error.message || 'Unknown error'));\n        }\n    }\n    /**\n   * Complete submit flow (for backward compatibility)\n   */ async submitSpec(blobHash, bondAmount, targetContract, targetChainId) {\n        // The submitSpec convenience method commits then immediately reveals the spec.\n        // Incentives are no longer passed as part of commit.\n        const commitResult = await this.commitSpec(blobHash, bondAmount, targetContract, targetChainId);\n        return await this.revealSpec(commitResult.commitmentId, blobHash, commitResult.metadataHash, commitResult.nonce, bondAmount);\n    }\n    /**\n   * Get the questionId from the contract for a given IPFS hash\n   * In V1, we need to find the specID first, then get the questionId from the spec\n   */ async getQuestionId(ipfsHash1) {\n        try {\n            if (!this.contract || !this.signer) {\n                throw new Error(\"Not connected to MetaMask. Please connect first.\");\n            }\n            // Generate specID from the blob versioned hash\n            const specId = ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes(ipfsHash1));\n            // Get the spec data\n            const spec = await this.contract.specs(specId);\n            const questionId = spec.questionId;\n            return questionId;\n        } catch (error) {\n            console.error(\"Error getting questionId:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Get the current status of a specification from the contract\n   * Returns: 0 = Submitted, 1 = Accepted, 2 = Rejected\n   */ async getSpecStatus(ipfsHash1) {\n        try {\n            if (!this.contract || !this.signer) {\n                throw new Error(\"Not connected to MetaMask. Please connect first.\");\n            }\n            // We know contract is not null here\n            const status = await this.contract.getStatus(ipfsHash1);\n            return Number(status);\n        } catch (error) {\n            console.error(\"Error getting spec status:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Check if a specification is accepted\n   */ async isSpecAccepted(ipfsHash1) {\n        try {\n            if (!this.contract || !this.signer) {\n                throw new Error(\"Not connected to MetaMask. Please connect first.\");\n            }\n            // We know contract is not null here\n            const isAccepted = await this.contract.isAccepted(ipfsHash1);\n            return isAccepted;\n        } catch (error) {\n            console.error(\"Error checking if spec is accepted:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Handle the result of a Reality.eth question by calling the contract's handleResult function\n   */ async handleResult(ipfsHash1) {\n        try {\n            if (!this.contract || !this.signer) {\n                throw new Error(\"Not connected to MetaMask. Please connect first.\");\n            }\n            // Make sure we're on the Sepolia network\n            // Network check removed - let users connect on any network\n            // Generate specID from IPFS hash\n            const specId = ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes(ipfsHash1));\n            // We know contract is not null here\n            const tx = await this.contract.handleResult(specId);\n            // Wait for transaction to be confirmed\n            const receipt = await tx.wait();\n            return tx.hash;\n        } catch (error) {\n            console.error(\"Error handling result:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Get the IPFS hash from the contract for a given specID\n   */ async getIPFSByHash(specID) {\n        try {\n            if (!this.contract || !this.signer) {\n                throw new Error(\"Not connected to MetaMask. Please connect first.\");\n            }\n            // In V1, get the spec data and extract IPFS\n            const spec = await this.contract.specs(specID);\n            const ipfsHash1 = spec.ipfs;\n            return ipfsHash1;\n        } catch (error) {\n            console.error(\"Error getting IPFS hash:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Create an incentive for a target contract (V1 feature)\n   */ async createIncentive(targetContract, targetChainId, amount, duration, description) {\n        try {\n            if (!this.contract || !this.signer) {\n                throw new Error(\"Not connected to MetaMask. Please connect first.\");\n            }\n            const tx = await this.contract.createIncentive(targetContract, targetChainId, amount, duration, description, {\n                value: amount\n            });\n            const receipt = await tx.wait();\n            return tx.hash;\n        } catch (error) {\n            console.error(\"Error creating incentive:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Get specs by contract address (V1 feature)\n   */ async getSpecsByContract(contractAddress) {\n        let chainId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 11155111;\n        try {\n            if (!this.contract || !this.signer) {\n                throw new Error(\"Not connected to MetaMask. Please connect first.\");\n            }\n            const specIds = await this.contract.getSpecsByContract(contractAddress, chainId);\n            return specIds;\n        } catch (error) {\n            console.error(\"Error getting specs by contract:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Get ALL specs for a user by querying SpecRevealed events\n   */ async getAllUserSpecsByEvents(userAddress) {\n        try {\n            if (!this.contract || !this.provider) {\n                throw new Error(\"Not connected to MetaMask. Please connect first.\");\n            }\n            // Get recent blocks to search for events\n            const currentBlock = await this.provider.getBlockNumber();\n            const fromBlock = Math.max(0, currentBlock - 50000); // Last ~7 days on mainnet\n            // Query SpecRevealed events for this user\n            const filter = this.contract.filters.SpecRevealed(null, userAddress, null);\n            const events = await this.contract.queryFilter(filter, fromBlock, currentBlock);\n            const userSpecs = [];\n            for (const event of events){\n                if (event.args && event.args.specId) {\n                    const specId = event.args.specId;\n                    userSpecs.push(specId);\n                }\n            }\n            // Also check LogRevealSpec events (older format)\n            try {\n                const logRevealFilter = this.contract.filters.LogRevealSpec(userAddress, null, null, null);\n                const logRevealEvents = await this.contract.queryFilter(logRevealFilter, fromBlock, currentBlock);\n                for (const event of logRevealEvents){\n                    if (event.args && event.args.specID) {\n                        const specId = event.args.specID;\n                        if (!userSpecs.includes(specId)) {\n                            userSpecs.push(specId);\n                        }\n                    }\n                }\n            } catch (logError) {}\n            return userSpecs;\n        } catch (error) {\n            console.error(\"Error getting user specs by events:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Get contract spec count (V1 feature)\n   */ async getContractSpecCount(contractAddress) {\n        try {\n            if (!this.contract || !this.signer) {\n                throw new Error(\"Not connected to MetaMask. Please connect first.\");\n            }\n            const count = await this.contract.getContractSpecCount(contractAddress);\n            return Number(count);\n        } catch (error) {\n            console.error(\"Error getting contract spec count:\", error);\n            throw error;\n        }\n    }\n    // Diagnostic functions removed to clean up console output\n    /**\n   * Direct commit-reveal implementation for troubleshooting\n   */ async directCommitReveal(ipfsHash1, bondAmount, targetContract) {\n        try {\n            if (!this.signer || !this.provider) {\n                throw new Error(\"Not connected to MetaMask. Please connect first.\");\n            }\n            const nonce = BigInt(Math.floor(Math.random() * 1000000));\n            const commitment = ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_4__.solidityPacked([\n                \"string\",\n                \"uint256\"\n            ], [\n                ipfsHash1,\n                nonce\n            ]));\n            const target = targetContract || RAW_CONTRACT_ADDRESS;\n            // Determine the chainId from the provider's network; fallback to 1 (Sepolia)\n            let networkChainId = 1;\n            try {\n                const network = await this.provider.getNetwork();\n                networkChainId = Number(network.chainId);\n            } catch (_) {\n                networkChainId = 1;\n            }\n            // Manually encode the function call for commitSpec(bytes32,address,uint256)\n            const functionSelector = ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"commitSpec(bytes32,address,uint256)\").slice(0, 10);\n            const encodedParams = ethers__WEBPACK_IMPORTED_MODULE_7__.concat([\n                ethers__WEBPACK_IMPORTED_MODULE_7__.zeroPadValue(commitment, 32),\n                ethers__WEBPACK_IMPORTED_MODULE_7__.zeroPadValue(target, 32),\n                ethers__WEBPACK_IMPORTED_MODULE_7__.zeroPadValue(ethers__WEBPACK_IMPORTED_MODULE_8__.toBeHex(networkChainId), 32)\n            ]);\n            const txData = ethers__WEBPACK_IMPORTED_MODULE_7__.concat([\n                functionSelector,\n                encodedParams\n            ]);\n            // Send the transaction directly\n            const tx = await this.signer.sendTransaction({\n                to: RAW_CONTRACT_ADDRESS,\n                data: txData,\n                value: bondAmount,\n                gasLimit: 500000 // Set a reasonable gas limit\n            });\n            // Wait for confirmation  \n            const receipt = await tx.wait();\n            if (receipt.status === 0) {\n                console.error(\"❌ Transaction reverted with status 0\");\n                // Try to get the revert reason using eth_call with the same transaction data at the block before\n                try {\n                    await this.provider.call({\n                        to: RAW_CONTRACT_ADDRESS,\n                        data: txData,\n                        value: bondAmount,\n                        from: await this.signer.getAddress(),\n                        blockTag: receipt.blockNumber - 1\n                    });\n                } catch (callError) {\n                    if (callError.data) {\n                        // Calculate error signatures dynamically to ensure accuracy\n                        const errorMappings = [\n                            \"AlreadyProposed()\",\n                            \"NotProposed()\",\n                            \"InsufficientBond()\",\n                            \"InsufficientIncentive()\",\n                            \"InvalidContract()\",\n                            \"ContractNotFound()\",\n                            \"InvalidIPFS()\",\n                            \"CommitmentNotFound()\",\n                            \"CommitmentExpired()\",\n                            \"CommitmentAlreadyRevealed()\",\n                            \"InvalidReveal()\",\n                            \"NotFinalized()\",\n                            \"AlreadySettled()\",\n                            \"NoIncentiveToClaim()\",\n                            \"IncentiveExpired()\",\n                            \"Unauthorized()\"\n                        ];\n                        const errorSignatures = {};\n                        errorMappings.forEach((error)=>{\n                            const selector = ethers__WEBPACK_IMPORTED_MODULE_6__.id(error).slice(0, 10);\n                            errorSignatures[selector] = error;\n                        });\n                        // Add generic error\n                        errorSignatures[\"0x08c379a0\"] = \"Error(string)\";\n                        const selector = callError.data.slice(0, 10);\n                        if (errorSignatures[selector]) {\n                            // Provide specific guidance\n                            if (selector === \"0xed592624\") {} else if (selector === \"0x47df8ce0\") {} else if (selector === \"0x82b42900\") {}\n                            throw new Error(\"Contract reverted with: \".concat(errorSignatures[selector]));\n                        } else {}\n                    }\n                }\n                throw new Error(\"Transaction was mined but reverted. Check console logs for details.\");\n            }\n            return tx.hash;\n        } catch (error) {\n            console.error(\"❌ Direct transaction failed:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Run comprehensive diagnostics before attempting a transaction\n   */ async runPreTransactionDiagnostics(targetContract, bondAmount) {\n        try {\n            if (!this.contract || !this.signer || !this.provider) {\n                throw new Error(\"Not connected\");\n            }\n            const userAddress = await this.signer.getAddress();\n            // 1. Check user's ETH balance\n            const balance = await this.provider.getBalance(userAddress);\n            if (balance < bondAmount) {\n                throw new Error(\"Insufficient ETH balance. Need \".concat(ethers__WEBPACK_IMPORTED_MODULE_9__.formatEther(bondAmount), \" ETH but only have \").concat(ethers__WEBPACK_IMPORTED_MODULE_9__.formatEther(balance), \" ETH\"));\n            }\n            // 2. Check contract pause status\n            try {\n                const pausedResult = await this.provider.call({\n                    to: RAW_CONTRACT_ADDRESS,\n                    data: \"0x5c975abb\" // paused() selector\n                });\n                const isPaused = pausedResult === \"0x0000000000000000000000000000000000000000000000000000000000000001\";\n                if (isPaused) {\n                    throw new Error(\"Contract is currently paused\");\n                }\n            } catch (pauseError) {}\n            // 3. Validate target contract exists and has bytecode\n            const targetCode = await this.provider.getCode(targetContract);\n            if (targetCode === \"0x\") {\n                throw new Error(\"Target contract \".concat(targetContract, \" does not exist on Sepolia testnet\"));\n            }\n            // 4. Check treasury address configuration\n            try {\n                const treasuryAddress = await this.contract.treasury();\n                if (treasuryAddress === \"0x0000000000000000000000000000000000000000\") {\n                    throw new Error(\"Treasury address is not configured (zero address)\");\n                }\n                // Check if treasury can receive funds\n                const treasuryCode = await this.provider.getCode(treasuryAddress);\n                if (treasuryCode.length > 2) {\n                    // Treasury is a contract, test if it can receive funds\n                    try {\n                        await this.provider.call({\n                            to: treasuryAddress,\n                            value: BigInt(1),\n                            from: userAddress\n                        });\n                    } catch (treasuryTestError) {\n                        console.warn(\"Treasury test failed:\", treasuryTestError);\n                    }\n                }\n                // CRITICAL: Test the exact platform fee transfer that happens in commitSpec\n                const platformFee = bondAmount * BigInt(5) / BigInt(100);\n                if (platformFee > BigInt(0)) {\n                    try {\n                        await this.provider.call({\n                            to: treasuryAddress,\n                            value: platformFee,\n                            from: userAddress,\n                            gasLimit: 50000 // Match contract gas limit\n                        });\n                    } catch (testError) {\n                        console.error(\"❌ Treasury transfer test failed:\", testError.message);\n                        console.warn(\"Transaction may fail at treasury transfer\");\n                    }\n                }\n            } catch (treasuryError) {\n                console.warn(\"Treasury check failed:\", treasuryError);\n                console.warn(\"Continuing despite treasury issues - transaction will likely fail\");\n            }\n            // 5. Check minimum bond requirement\n            const contractMinBond = await this.contract.minBond();\n            // Skip bond amount check for commitSpec (bondAmount is 0 for commit)\n            // Bonds are only required during reveal\n            if (bondAmount > 0n && bondAmount < contractMinBond) {\n                throw new Error(\"Bond amount \".concat(ethers__WEBPACK_IMPORTED_MODULE_9__.formatEther(bondAmount), \" ETH is below minimum required \").concat(ethers__WEBPACK_IMPORTED_MODULE_9__.formatEther(contractMinBond), \" ETH\"));\n            }\n            // 6. Calculate platform fee and verify sufficient funds\n            // NOTE: commitSpec doesn't take any payment, so skip this check when bondAmount is 0\n            // The bond is only paid during reveal\n            if (bondAmount > 0n) {\n                const platformFee = bondAmount * BigInt(5) / BigInt(100); // 5% platform fee\n                const netBondAmount = bondAmount - platformFee; // Amount actually used as bond\n                if (netBondAmount < contractMinBond) {\n                    // Calculate required total to meet minimum after fee deduction\n                    const requiredTotal = contractMinBond * BigInt(100) / BigInt(95); // Reverse calculation\n                    throw new Error(\"After platform fee, net bond would be \".concat(ethers__WEBPACK_IMPORTED_MODULE_9__.formatEther(netBondAmount), \" ETH, but minimum required is \").concat(ethers__WEBPACK_IMPORTED_MODULE_9__.formatEther(contractMinBond), \" ETH. Send at least \").concat(ethers__WEBPACK_IMPORTED_MODULE_9__.formatEther(requiredTotal), \" ETH\"));\n                }\n            }\n            // 7. Test Reality.eth contract connectivity\n            try {\n                // Skip Reality.eth connectivity test for now\n                console.log(\"✓ Skipping Reality.eth connectivity test\");\n            // const realityCode = await this.provider.getCode(realityEthAddress);\n            // if (realityCode === \"0x\") {\n            //   throw new Error(\"Reality.eth contract not found at configured address\");\n            // }\n            } catch (realityError) {\n                console.error(\"Reality.eth check failed:\", realityError);\n                throw new Error(\"Could not verify Reality.eth integration\");\n            }\n            // 8. Test contract function availability with static call\n            try {\n                const testCommitment = \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\";\n                // commitSpec in V1 accepts only (bytes32 commitment, address targetContract, uint256 chainId).\n                // Do not pass an incentiveId here, as the V1 contract does not include that parameter.\n                // IMPORTANT: commitSpec is NOT payable - no value should be sent\n                await this.contract.commitSpec.staticCall(testCommitment, targetContract, 1, {\n                    from: userAddress\n                });\n            } catch (staticError) {\n                console.error(\"❌ Static call failed:\", staticError);\n                if (staticError.data) {\n                    // Try to decode the error\n                    const errorMappings = [\n                        {\n                            selector: ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"InsufficientBond()\").slice(0, 10),\n                            name: \"InsufficientBond\"\n                        },\n                        {\n                            selector: ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"ContractNotFound()\").slice(0, 10),\n                            name: \"ContractNotFound\"\n                        },\n                        {\n                            selector: ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"InvalidContract()\").slice(0, 10),\n                            name: \"InvalidContract\"\n                        },\n                        {\n                            selector: ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"Unauthorized()\").slice(0, 10),\n                            name: \"Unauthorized\"\n                        },\n                        {\n                            selector: \"0xd92e233d\",\n                            name: \"Paused\"\n                        }\n                    ];\n                    const errorSelector = staticError.data.slice(0, 10);\n                    const knownError = errorMappings.find((e)=>e.selector === errorSelector);\n                    if (knownError) {\n                        throw new Error(\"Contract would revert with: \".concat(knownError.name, \"()\"));\n                    } else {\n                        throw new Error(\"Contract would revert with unknown error: \".concat(errorSelector));\n                    }\n                } else {\n                    throw new Error(\"Contract function call would fail (no revert data available)\");\n                }\n            }\n            // 9. Gas estimation test\n            try {\n                const testCommitment = \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\";\n                // Remove the testIncentive parameter; commitSpec only takes three arguments.\n                const gasEstimate = await this.contract.commitSpec.estimateGas(testCommitment, targetContract, 1, {\n                    value: bondAmount\n                });\n                if (gasEstimate > BigInt(1000000)) {\n                    console.warn(\"⚠️ High gas estimate - transaction might be complex\");\n                }\n            } catch (gasError) {\n                console.error(\"Gas estimation failed:\", gasError);\n                throw new Error(\"Could not estimate gas for transaction\");\n            }\n        } catch (error) {\n            console.error(\"❌ Pre-transaction diagnostics failed:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Comprehensive contract analysis to understand what's deployed\n   */ async analyzeContract() {\n        try {\n            if (!this.provider || !this.signer) {\n                throw new Error(\"Not connected\");\n            }\n            // 1. Check if there's any bytecode\n            const code = await this.provider.getCode(RAW_CONTRACT_ADDRESS);\n            if (code === \"0x\") {\n                console.error(\"❌ No contract deployed at this address\");\n                return;\n            }\n            // 2. Test function selectors to identify which contract is deployed\n            const selectors = {\n                \"minBond()\": \"0x1bb659ae\",\n                // Use the new 3-parameter commitSpec selector for V1 contracts\n                \"commitSpec(bytes32,address,uint256)\": \"0x\" + ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"commitSpec(bytes32,address,uint256)\").slice(2, 10),\n                \"createSpec(string)\": \"0x8cd8db49\",\n                \"paused()\": \"0x5c975abb\",\n                \"ADMIN_ROLE()\": \"0x75b238fc\",\n                \"realityETH()\": \"0xb0b61b9b\",\n                \"templateId()\": \"0x66d8ac19\"\n            };\n            for (const [funcName, selector] of Object.entries(selectors)){\n                try {\n                    const result = await this.provider.call({\n                        to: RAW_CONTRACT_ADDRESS,\n                        data: selector + \"0\".repeat(192) // Add padding for parameters\n                    });\n                } catch (error) {\n                    if (error.data && error.data !== \"0x\") {} else {}\n                }\n            }\n            // 3. Test commitSpec specifically with detailed analysis\n            try {\n                const testCommitment = \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\";\n                const testTarget1 = RAW_CONTRACT_ADDRESS;\n                const minBond = BigInt(\"100000000000000\"); // 0.0001 ETH\n                // Encode the call to the new 3-parameter commitSpec\n                const encodedCall = ethers__WEBPACK_IMPORTED_MODULE_7__.concat([\n                    ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"commitSpec(bytes32,address,uint256)\").slice(0, 10),\n                    ethers__WEBPACK_IMPORTED_MODULE_7__.zeroPadValue(testCommitment, 32),\n                    ethers__WEBPACK_IMPORTED_MODULE_7__.zeroPadValue(testTarget1, 32),\n                    ethers__WEBPACK_IMPORTED_MODULE_7__.zeroPadValue(ethers__WEBPACK_IMPORTED_MODULE_8__.toBeHex(1), 32) // chainId = 1 for test\n                ]);\n                // Try static call\n                const result = await this.provider.call({\n                    to: RAW_CONTRACT_ADDRESS,\n                    data: encodedCall,\n                    value: minBond,\n                    from: await this.signer.getAddress()\n                });\n            } catch (commitError) {\n                if (commitError.data) {\n                    // Try to decode the error\n                    if (commitError.data.length >= 10) {\n                        const errorSelector = commitError.data.slice(0, 10);\n                        // Calculate error signatures dynamically to ensure accuracy\n                        const errorMappings = [\n                            \"AlreadyProposed()\",\n                            \"NotProposed()\",\n                            \"InsufficientBond()\",\n                            \"InsufficientIncentive()\",\n                            \"InvalidContract()\",\n                            \"ContractNotFound()\",\n                            \"InvalidIPFS()\",\n                            \"CommitmentNotFound()\",\n                            \"CommitmentExpired()\",\n                            \"CommitmentAlreadyRevealed()\",\n                            \"InvalidReveal()\",\n                            \"NotFinalized()\",\n                            \"AlreadySettled()\",\n                            \"NoIncentiveToClaim()\",\n                            \"IncentiveExpired()\",\n                            \"Unauthorized()\"\n                        ];\n                        const knownErrors = {};\n                        errorMappings.forEach((error)=>{\n                            const selector = ethers__WEBPACK_IMPORTED_MODULE_6__.id(error).slice(0, 10);\n                            knownErrors[selector] = error;\n                        });\n                        // Add known OpenZeppelin errors\n                        knownErrors[\"0xd92e233d\"] = \"Paused()\";\n                        knownErrors[\"0x08c379a0\"] = \"Error(string)\";\n                        if (knownErrors[errorSelector]) {\n                            // If it's ContractNotFound, that's our main suspect\n                            if (errorSelector === \"0xed592624\") {\n                                // Let's check the target contract bytecode size\n                                const targetCode = await this.provider.getCode(testTarget);\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (error) {\n            console.error(\"Contract analysis failed:\", error);\n        }\n    }\n    /**\n   * Identify which contract version is actually deployed\n   */ async identifyDeployedContract() {\n        try {\n            if (!this.provider || !this.signer) {\n                throw new Error(\"Not connected\");\n            }\n            // Test signature differences between V1 and original - calculate proper selectors\n            const tests = [\n                {\n                    name: \"Original KaiSign\",\n                    selector: ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"createSpec(string)\").slice(0, 10),\n                    description: \"Has createSpec(string) function\"\n                },\n                {\n                    name: \"KaiSign V1\",\n                    selector: ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"commitSpec(bytes32,address,uint256)\").slice(0, 10),\n                    description: \"Has commitSpec(bytes32,address,uint256) function\"\n                },\n                {\n                    name: \"V1 Pausable\",\n                    selector: ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"paused()\").slice(0, 10),\n                    description: \"Has paused() function from Pausable\"\n                },\n                {\n                    name: \"V1 AccessControl\",\n                    selector: ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"ADMIN_ROLE()\").slice(0, 10),\n                    description: \"Has ADMIN_ROLE constant from AccessControl\"\n                },\n                {\n                    name: \"Contract minBond\",\n                    selector: ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"minBond()\").slice(0, 10),\n                    description: \"Has minBond() function\"\n                },\n                {\n                    name: \"Contract realityETH\",\n                    selector: ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"realityETH()\").slice(0, 10),\n                    description: \"Has realityETH() function\"\n                }\n            ];\n            tests.forEach((test)=>{});\n            const results = [];\n            for (const test of tests){\n                try {\n                    const result = await this.provider.call({\n                        to: RAW_CONTRACT_ADDRESS,\n                        data: test.selector\n                    });\n                    results.push(\"✅ \".concat(test.name, \": YES (\").concat(test.description, \")\"));\n                } catch (error) {\n                    if (error.data && error.data !== \"0x\") {\n                        results.push(\"⚠️ \".concat(test.name, \": EXISTS BUT REVERTS (\").concat(test.description, \")\"));\n                    } else {\n                        results.push(\"❌ \".concat(test.name, \": NO (\").concat(test.description, \")\"));\n                    }\n                }\n            }\n            // Determine which contract this is\n            const hasCommitSpec = results[1].includes(\"✅\") || results[1].includes(\"⚠️\");\n            const hasCreateSpec = results[0].includes(\"✅\") || results[0].includes(\"⚠️\");\n            const hasPaused = results[2].includes(\"✅\") || results[2].includes(\"⚠️\");\n            const hasMinBond = results[4].includes(\"✅\") || results[4].includes(\"⚠️\");\n            const hasRealityETH = results[5].includes(\"✅\") || results[5].includes(\"⚠️\");\n            if (hasCommitSpec && hasPaused) {} else if (hasCreateSpec && !hasCommitSpec && hasMinBond && hasRealityETH) {\n                // Store this information for later use\n                window.__KAISIGN_CONTRACT_TYPE = \"original\";\n            } else if (!hasCreateSpec && !hasCommitSpec) {} else {}\n            // Print summary\n            results.forEach((result)=>console.log(\"  \" + result));\n        } catch (error) {\n            console.error(\"Contract identification failed:\", error);\n        }\n    }\n    /**\n   * Test contract connectivity and basic functions\n   */ async testContract() {\n        try {\n            if (!this.contract || !this.signer) {\n                throw new Error(\"Not connected to MetaMask. Please connect first.\");\n            }\n            // Test 1: Check if contract exists\n            const contractCode = await this.provider.getCode(RAW_CONTRACT_ADDRESS);\n            if (contractCode === \"0x\") {\n                throw new Error(\"No contract deployed at this address\");\n            }\n            // Test 2: Get minimum bond\n            try {\n                const minBond = await this.contract.minBond();\n            } catch (error) {\n                console.error(\"✗ minBond() failed:\", error);\n                throw new Error(\"Contract exists but minBond() function failed - wrong ABI?\");\n            }\n            // Test 2b: Check if this looks like the V1 contract by checking constructor elements\n            try {\n                // Check for paused function (V1 specific)\n                const pausedResult = await this.provider.call({\n                    to: RAW_CONTRACT_ADDRESS,\n                    data: \"0x5c975abb\" // paused() selector\n                });\n                // Check for ADMIN_ROLE constant (V1 specific)\n                const adminRoleResult = await this.provider.call({\n                    to: RAW_CONTRACT_ADDRESS,\n                    data: \"0x75b238fc\" // ADMIN_ROLE() selector  \n                });\n                // Check for COMMIT_REVEAL_TIMEOUT constant\n                const timeoutResult = await this.provider.call({\n                    to: RAW_CONTRACT_ADDRESS,\n                    data: \"0x1234567890abcdef\" // This would be the selector for the constant\n                });\n            } catch (v1CheckError) {\n                console.warn(\"Could not verify V1 contract features:\", v1CheckError);\n            }\n            // Test 3: Get Reality.eth address\n            try {\n                // Skip Reality.eth address test\n                console.log(\"✓ Skipping Reality.eth address test\");\n            } catch (error) {\n                console.error(\"✗ realityETH() failed:\", error);\n            }\n            // Test 4: Check if you have necessary roles\n            try {\n                const userAddress = await this.signer.getAddress();\n                // Add hasRole function to ABI check\n                const hasAdminRole = await this.provider.call({\n                    to: RAW_CONTRACT_ADDRESS,\n                    data: ethers__WEBPACK_IMPORTED_MODULE_7__.concat([\n                        \"0x91d14854\",\n                        ethers__WEBPACK_IMPORTED_MODULE_7__.zeroPadValue(\"0x0000000000000000000000000000000000000000000000000000000000000000\", 32),\n                        ethers__WEBPACK_IMPORTED_MODULE_7__.zeroPadValue(userAddress, 32)\n                    ])\n                });\n            } catch (roleError) {}\n            // Test 5: Check if commitSpec function exists (using the new 3-parameter signature)\n            try {\n                // Try to call the function selector directly\n                const commitSpecSelector = ethers__WEBPACK_IMPORTED_MODULE_6__.id(\"commitSpec(bytes32,address,uint256)\").slice(0, 10);\n                // Minimal calldata for 3 parameters: 3 * 32 bytes = 96 bytes of padding (192 hex chars)\n                const testCalldata = commitSpecSelector + \"0\".repeat(192);\n                const testCall = await this.provider.call({\n                    to: RAW_CONTRACT_ADDRESS,\n                    data: testCalldata\n                });\n            } catch (selectorError) {\n                console.error(\"✗ commitSpec function test failed:\", selectorError);\n                if (selectorError.data) {\n                    // Check if it's just a revert due to invalid parameters vs function not found\n                    if (selectorError.data === \"0x\" || selectorError.data === null) {\n                        console.error(\"⚠️  Function might not exist - no revert data returned\");\n                    } else {}\n                }\n            }\n            // Test 6: Try to call commitSpec with dry run using realistic commitment\n            try {\n                const testIpfs = \"QmTest123\";\n                const testNonce = BigInt(12345);\n                const testCommitment = ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_4__.solidityPacked([\n                    \"string\",\n                    \"uint256\"\n                ], [\n                    testIpfs,\n                    testNonce\n                ]));\n                const testTarget1 = RAW_CONTRACT_ADDRESS;\n                // Note: commitSpec in V1 accepts only (bytes32 commitment, address targetContract, uint256 chainId).\n                // Do not define or pass a testIncentive parameter here.\n                const gasEstimate = await this.contract.commitSpec.estimateGas(testCommitment, testTarget1, 1, {\n                    value: await this.contract.minBond()\n                });\n            } catch (error) {\n                console.error(\"✗ commitSpec test failed:\", error);\n                console.error(\"This suggests the contract might be paused, have access control, or different function signature\");\n                // Try to decode the error\n                if (error.data) {}\n            }\n        } catch (error) {\n            console.error(\"Contract test failed:\", error);\n            throw error;\n        }\n    }\n    // =============================================================================\n    //                          KAISIGN V1 FUNCTIONS\n    // =============================================================================\n    async createIncentive(targetContract, targetChainId, amount, durationSeconds, description) {\n        if (!this.contract || !this.signer) {\n            throw new Error(\"Not connected to MetaMask. Please connect first.\");\n        }\n        try {\n            // Network check removed - let users connect on any network\n            console.log(\"💰 Parameters:\", {\n                targetContract,\n                targetChainId,\n                token,\n                amount,\n                durationSeconds,\n                description\n            });\n            // ETH only - value is the amount\n            // Check if contract has the createIncentive function\n            if (typeof this.contract.createIncentive !== 'function') {\n                throw new Error(\"Contract does not have createIncentive function\");\n            }\n            const tx = await this.contract.createIncentive(targetContract, targetChainId, amount, durationSeconds, description, {\n                value: amount\n            });\n            const receipt = await tx.wait();\n            // Log any events emitted\n            if (receipt.logs && receipt.logs.length > 0) {\n                receipt.logs.forEach((log, index)=>{});\n            }\n            return tx.hash;\n        } catch (error) {\n            var _this_contract, _this_signer, _error_message;\n            console.error(\"💥 Error creating incentive:\", error);\n            console.error(\"🔧 Contract address:\", (_this_contract = this.contract) === null || _this_contract === void 0 ? void 0 : _this_contract.target);\n            console.error(\"👤 Signer address:\", await ((_this_signer = this.signer) === null || _this_signer === void 0 ? void 0 : _this_signer.getAddress()));\n            if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {\n                throw new Error(\"Transaction would fail - check your parameters and account balance\");\n            }\n            if (error.code === 'INSUFFICIENT_FUNDS') {\n                throw new Error(\"Insufficient ETH balance to complete transaction\");\n            }\n            if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('user rejected')) {\n                throw new Error(\"Transaction was rejected by user\");\n            }\n            throw error;\n        }\n    }\n    async getUserIncentives(userAddress) {\n        // Auto-connect if not connected\n        if (!this.contract) {\n            try {\n                console.log(\"Contract not connected, attempting to connect...\");\n                await this.connect();\n            } catch (connectError) {\n                console.warn(\"Failed to auto-connect for getUserIncentives:\", connectError);\n                // Return empty array instead of throwing to prevent blocking the UI\n                return [];\n            }\n        }\n        // Double check after connection attempt\n        if (!this.contract) {\n            console.warn(\"Contract still not available after connection attempt, returning empty array\");\n            return [];\n        }\n        try {\n            const incentiveIds = await this.contract.getUserIncentives(userAddress);\n            // Convert from ethers result to string array\n            const ids = Array.from(incentiveIds);\n            return ids;\n        } catch (error) {\n            var _this_contract, _error_info;\n            console.error(\"💥 Error getting user incentives:\", error);\n            console.error(\"🔧 Contract address:\", (_this_contract = this.contract) === null || _this_contract === void 0 ? void 0 : _this_contract.target);\n            console.error(\"📝 Function signature: getUserIncentives(address)\");\n            // If function doesn't exist or returns empty data, return empty array instead of throwing\n            if (error.code === \"BAD_DATA\" || ((_error_info = error.info) === null || _error_info === void 0 ? void 0 : _error_info.method) === \"getUserIncentives\") {\n                console.warn(\"⚠️ getUserIncentives function may not exist on this contract, returning empty array\");\n                return [];\n            }\n            // For other errors, also return empty array to prevent UI blocking\n            console.warn(\"⚠️ getUserIncentives failed, returning empty array to prevent UI blocking\");\n            return [];\n        }\n    }\n    async getIncentiveData(incentiveId) {\n        if (!this.contract) {\n            throw new Error(\"Not connected to contract.\");\n        }\n        try {\n            const incentive = await this.contract.incentives(incentiveId);\n            // Handle the struct response properly\n            const result = {\n                creator: incentive[0],\n                token: incentive[1],\n                amount: incentive[2].toString(),\n                deadline: Number(incentive[3]),\n                createdAt: Number(incentive[4]),\n                targetContract: incentive[5],\n                isClaimed: incentive[6],\n                isActive: incentive[7],\n                reserved: Number(incentive[8]),\n                chainId: Number(incentive[9]),\n                description: incentive[10] // string description\n            };\n            return result;\n        } catch (error) {\n            console.error(\"💥 Error getting incentive data:\", error);\n            console.error(\"🔍 Incentive ID:\", incentiveId);\n            throw error;\n        }\n    }\n    async getSpecsByContractPaginated(targetContract, offset, limit) {\n        if (!this.contract) {\n            throw new Error(\"Not connected to contract.\");\n        }\n        try {\n            const result = await this.contract.getSpecsByContractPaginated(targetContract, offset, limit);\n            return {\n                specIds: result.specIds,\n                total: Number(result.total)\n            };\n        } catch (error) {\n            console.error(\"Error getting paginated specs:\", error);\n            throw error;\n        }\n    }\n    async getSpecData(specId) {\n        if (!this.contract) {\n            throw new Error(\"Not connected to contract.\");\n        }\n        try {\n            // Call the specs function and handle potential structure variations\n            const spec = await this.contract.specs(specId);\n            // The contract might have different struct layouts, so we need to handle both cases\n            // Try to parse assuming the newer format with 'reserved' field\n            let parsedSpec;\n            if (Array.isArray(spec) && spec.length >= 11) {\n                // Handle tuple/array format - Updated to match exact contract struct order\n                parsedSpec = {\n                    createdTimestamp: Number(spec[0]),\n                    proposedTimestamp: Number(spec[1]),\n                    status: Number(spec[2]),\n                    totalBonds: spec[3].toString(),\n                    reserved: Number(spec[4]),\n                    creator: spec[5],\n                    targetContract: spec[6],\n                    blobHash: spec[7],\n                    questionId: spec[8],\n                    incentiveId: spec[9],\n                    chainId: Number(spec[10]) // uint256 chainId\n                };\n            } else {\n                // Handle named struct format\n                parsedSpec = {\n                    createdTimestamp: Number(spec.createdTimestamp || 0),\n                    proposedTimestamp: Number(spec.proposedTimestamp || 0),\n                    status: Number(spec.status || 0),\n                    totalBonds: (spec.totalBonds || 0).toString(),\n                    reserved: Number(spec.reserved || 0),\n                    creator: spec.creator || \"0x0000000000000000000000000000000000000000\",\n                    targetContract: spec.targetContract || \"0x0000000000000000000000000000000000000000\",\n                    blobHash: spec.blobHash || \"0x\",\n                    questionId: spec.questionId || \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n                    incentiveId: spec.incentiveId || \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n                    chainId: Number(spec.chainId || 0)\n                };\n            }\n            return parsedSpec;\n        } catch (error) {\n            var _error_message;\n            console.error(\"💥 Error getting spec data:\", error);\n            console.error(\"📋 SpecId that failed:\", specId);\n            // Try to provide more helpful error information\n            if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"could not decode result data\")) {\n                console.error(\"🔧 This looks like an ABI mismatch. The contract struct might have changed.\");\n                // Try to extract some basic info from the raw error if possible\n                if (error.value) {\n                    console.error(\"📊 Raw contract return value:\", error.value);\n                }\n            }\n            throw new Error(\"Failed to decode specification data. This might be due to a contract version mismatch. Original error: \".concat(error.message));\n        }\n    }\n    async proposeSpec(specId, bondAmount) {\n        if (!this.contract || !this.signer) {\n            throw new Error(\"Not connected to MetaMask. Please connect first.\");\n        }\n        try {\n            // Network check removed - let users connect on any network\n            const tx = await this.contract.proposeSpec(specId, {\n                value: bondAmount\n            });\n            const receipt = await tx.wait();\n            return tx.hash;\n        } catch (error) {\n            console.error(\"Error proposing spec:\", error);\n            throw error;\n        }\n    }\n    async assertSpecValid(specId, bondAmount) {\n        if (!this.contract || !this.signer) {\n            throw new Error(\"Not connected to MetaMask. Please connect first.\");\n        }\n        try {\n            // Network check removed - let users connect on any network\n            const tx = await this.contract.assertSpecValid(specId, {\n                value: bondAmount\n            });\n            const receipt = await tx.wait();\n            return tx.hash;\n        } catch (error) {\n            console.error(\"Error asserting spec valid:\", error);\n            throw error;\n        }\n    }\n    async assertSpecInvalid(specId, bondAmount) {\n        if (!this.contract || !this.signer) {\n            throw new Error(\"Not connected to MetaMask. Please connect first.\");\n        }\n        try {\n            // Network check removed - let users connect on any network\n            const tx = await this.contract.assertSpecInvalid(specId, {\n                value: bondAmount\n            });\n            const receipt = await tx.wait();\n            return tx.hash;\n        } catch (error) {\n            console.error(\"Error asserting spec invalid:\", error);\n            throw error;\n        }\n    }\n    async handleResult(specId) {\n        if (!this.contract || !this.signer) {\n            throw new Error(\"Not connected to MetaMask. Please connect first.\");\n        }\n        try {\n            // First check the current status of the spec\n            const specData = await this.contract.specs(specId);\n            // Status: 0=Committed, 1=Submitted, 2=Proposed, 3=Finalized, 4=Cancelled\n            if (Number(specData.status) === 3) {\n                // Spec is already finalized, but incentives might not be claimed\n                // Let's try to claim ETH incentives manually if they exist\n                // Check if there are available ETH incentives for this spec's target contract\n                const availableIncentives = await this.getAvailableIncentives(specData.targetContract, Number(specData.chainId));\n                const ethIncentives = availableIncentives.filter((inc)=>inc.token === \"0x0000000000000000000000000000000000000000\" && !inc.isClaimed && inc.isActive);\n                if (ethIncentives.length > 0) {\n                    // There are unclaimed ETH incentives - the spec might have been finalized without processing incentives\n                    // This could happen if handleResult was never called or failed partially\n                    // Try calling handleResult anyway - it might work if the Reality.eth question needs processing\n                    try {\n                        const tx = await this.contract.handleResult(specId);\n                        const receipt = await tx.wait();\n                        return tx.hash;\n                    } catch (handleError) {\n                        throw new Error(\"Specification is finalized but incentives weren't claimed automatically. This may require contract admin intervention or the incentives may have expired.\");\n                    }\n                } else {\n                    throw new Error(\"Specification is already finalized and no unclaimed ETH incentives found. Check if incentives were already claimed or use claimActiveTokenIncentive for ERC20 tokens.\");\n                }\n            } else if (Number(specData.status) !== 2) {\n                throw new Error(\"Cannot handle result for spec in status \".concat(specData.status, \". Spec must be Proposed (status 2).\"));\n            }\n            const tx = await this.contract.handleResult(specId);\n            const receipt = await tx.wait();\n            return tx.hash;\n        } catch (error) {\n            console.error(\"Error handling result:\", error);\n            // Decode specific contract errors\n            if (error.data === \"0xf2a87d5e\") {\n                throw new Error(\"NotProposed: Specification is not in Proposed status. It may already be finalized.\");\n            } else if (error.data === \"0x1bee0d5a\") {\n                throw new Error(\"NotFinalized: Reality.eth question is not yet finalized. Wait for the timeout period.\");\n            }\n            throw error;\n        }\n    }\n    async settleBonds(specId) {\n        if (!this.contract || !this.signer) {\n            throw new Error(\"Not connected to MetaMask. Please connect first.\");\n        }\n        try {\n            // Check spec status first\n            const specData = await this.contract.specs(specId);\n            // Validate requirements before attempting settlement\n            if (Number(specData.status) !== 3) {\n                throw new Error(\"Cannot settle bonds: Specification must be finalized (status 3), but current status is \".concat(Number(specData.status)));\n            }\n            if (specData.bondsSettled) {\n                throw new Error(\"Cannot settle bonds: Bonds have already been settled for this specification\");\n            }\n            // Check Reality.eth question status\n            const questionId = specData.questionId;\n            // IMPORTANT: Double-check by calling the contract's bondsSettled mapping directly\n            // This might be different from the spec struct value\n            try {\n                // The contract might have a bondsSettled mapping that's separate from the struct\n                // Let me try a different approach - check the ABI for available view functions\n                // Check if the contract has any other state we need to verify\n                // CRITICAL: Check the bondsSettled mapping directly\n                const mappingSettled = await this.contract.bondsSettled(specId);\n                if (mappingSettled) {\n                    throw new Error(\"Cannot settle bonds: The bondsSettled mapping shows bonds are already settled, even though the spec struct says false. This indicates the bonds were already processed.\");\n                }\n            } catch (stateError) {\n                console.error(\"Error checking additional state:\", stateError);\n            }\n            if (questionId === \"0x0000000000000000000000000000000000000000000000000000000000000000\") {\n                throw new Error(\"Cannot settle bonds: No Reality.eth question associated with this specification\");\n            }\n            // Try to get Reality.eth contract and check if question is finalized\n            try {\n                // Skip Reality.eth contract initialization for now\n                console.log(\"✓ Skipping Reality.eth contract initialization\");\n                // Create Reality.eth contract instance\n                const realityEthAbi = [\n                    \"function isFinalized(bytes32 question_id) external view returns (bool)\",\n                    \"function resultFor(bytes32 question_id) external view returns (bytes32)\"\n                ];\n                const realityEthContract = new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(realityEthAddress, realityEthAbi, this.provider);\n                const isFinalized = await realityEthContract.isFinalized(questionId);\n                if (isFinalized) {\n                    const result = await realityEthContract.resultFor(questionId);\n                } else {}\n            } catch (realityError) {\n                console.error(\"Error checking Reality.eth status:\", realityError);\n            }\n            // Check if contract has enough balance to pay out bonds (always run this)\n            try {\n                const kaisignContractAddress = \"0x4dFEA0C2B472a14cD052a8f9DF9f19fa5CF03719\";\n                const contractBalance = await this.provider.getBalance(kaisignContractAddress);\n                if (contractBalance < specData.totalBonds) {\n                    throw new Error(\"\\uD83D\\uDEA8 CONTRACT INSUFFICIENT FUNDS: Contract balance: \".concat(ethers__WEBPACK_IMPORTED_MODULE_9__.formatEther(contractBalance), \" ETH, Required: \").concat(ethers__WEBPACK_IMPORTED_MODULE_9__.formatEther(specData.totalBonds), \" ETH\"));\n                }\n            } catch (balanceError) {\n                console.error(\"Error checking contract balance:\", balanceError);\n                throw balanceError;\n            }\n            // Try with manual gas estimation to avoid estimation errors\n            try {\n                const gasEstimate = await this.contract.settleBonds.estimateGas(specId);\n                const tx = await this.contract.settleBonds(specId, {\n                    gasLimit: gasEstimate + BigInt(50000) // Add buffer\n                });\n                const receipt = await tx.wait();\n                return tx.hash;\n            } catch (gasError) {\n                console.error(\"Gas estimation failed, trying with fixed gas:\", gasError);\n                // Try with a fixed gas limit\n                const tx = await this.contract.settleBonds(specId, {\n                    gasLimit: BigInt(200000) // Fixed gas limit\n                });\n                const receipt = await tx.wait();\n                return tx.hash;\n            }\n        } catch (error) {\n            console.error(\"Error settling bonds:\", error);\n            // Decode specific contract errors for settleBonds\n            if (error.data === \"0x1bee0d5a\") {\n                throw new Error(\"NotFinalized: Specification must be finalized before settling bonds.\");\n            } else if (error.data === \"0x2cb15938\") {\n                throw new Error(\"AlreadySettled: Bonds for this specification have already been settled.\");\n            }\n            // Check if it's a generic revert\n            if (error.message.includes(\"execution reverted\") && !error.data) {\n                // Try to get more info about why it failed\n                throw new Error(\"Bond settlement failed. This could be because: 1) Specification is not finalized, 2) Bonds already settled, 3) You're not authorized to settle, or 4) Contract state issue. Spec ID: \".concat(specId));\n            }\n            throw error;\n        }\n    }\n    async getCurrentAccount() {\n        if (!this.provider) {\n            return null;\n        }\n        try {\n            var _accounts_;\n            const accounts = await this.provider.listAccounts();\n            return accounts.length > 0 ? ((_accounts_ = accounts[0]) === null || _accounts_ === void 0 ? void 0 : _accounts_.address) || null : null;\n        } catch (error) {\n            console.error(\"Error getting current account:\", error);\n            return null;\n        }\n    }\n    async getContractSpecCount(targetContract) {\n        if (!this.contract) {\n            throw new Error(\"Not connected to contract.\");\n        }\n        try {\n            const count = await this.contract.getContractSpecCount(targetContract);\n            return Number(count);\n        } catch (error) {\n            console.error(\"Error getting contract spec count:\", error);\n            throw error;\n        }\n    }\n    async getAvailableIncentives(targetContract, targetChainId) {\n        if (!this.contract) {\n            throw new Error(\"Not connected to contract.\");\n        }\n        try {\n            const incentives = [];\n            // Get real incentives from contract events\n            try {\n                const filter = this.contract.filters.LogIncentiveCreated(null, null, targetContract);\n                const events = await this.contract.queryFilter(filter, -10000); // Last 10k blocks\n                for (const event of events){\n                    var _event_args;\n                    const incentiveId = (_event_args = event.args) === null || _event_args === void 0 ? void 0 : _event_args.incentiveId;\n                    if (incentiveId) {\n                        const incentiveData = await this.contract.incentives(incentiveId);\n                        // Only include incentives that exactly match the target chain ID\n                        // This prevents cross-chain incentive confusion\n                        if (incentiveData.isActive && !incentiveData.isClaimed && (targetChainId === undefined || incentiveData.chainId.toString() === targetChainId.toString())) {\n                            incentives.push({\n                                id: incentiveId,\n                                creator: incentiveData.creator,\n                                token: incentiveData.token,\n                                amount: incentiveData.token === \"0x0000000000000000000000000000000000000000\" ? (Number(incentiveData.amount) / 1e18).toString() : incentiveData.amount.toString(),\n                                deadline: Number(incentiveData.deadline),\n                                description: incentiveData.description,\n                                isActive: incentiveData.isActive,\n                                isClaimed: incentiveData.isClaimed\n                            });\n                        }\n                    }\n                }\n            } catch (eventError) {}\n            return incentives;\n        } catch (error) {\n            console.error(\"Error getting available incentives:\", error);\n            throw error;\n        }\n    }\n    async getIncentivesByTargetContract(targetContract) {\n        if (!this.contract) {\n            throw new Error(\"Not connected to contract.\");\n        }\n        try {\n            // This would require event filtering or a subgraph\n            // For now, returning empty array as placeholder\n            console.warn(\"getIncentivesByTargetContract: This function needs event filtering implementation\");\n            return [];\n        } catch (error) {\n            console.error(\"Error getting incentives by target contract:\", error);\n            throw error;\n        }\n    }\n    async claimActiveTokenIncentive(specId, tokenAddress) {\n        if (!this.contract) {\n            throw new Error(\"Not connected to contract.\");\n        }\n        try {\n            const tx = await this.contract.claimActiveTokenIncentive(specId, tokenAddress);\n            const receipt = await tx.wait();\n            return tx.hash;\n        } catch (error) {\n            console.error(\"Error claiming active token incentive:\", error);\n            throw error;\n        }\n    }\n    // Helper function to claim ETH incentives manually\n    async claimETHIncentive(specId) {\n        if (!this.contract) {\n            throw new Error(\"Not connected to contract.\");\n        }\n        try {\n            // ETH token address is 0x0000000000000000000000000000000000000000\n            const ethAddress = \"0x0000000000000000000000000000000000000000\";\n            const tx = await this.contract.claimActiveTokenIncentive(specId, ethAddress);\n            const receipt = await tx.wait();\n            return tx.hash;\n        } catch (error) {\n            console.error(\"Error claiming ETH incentive:\", error);\n            // If claimActiveTokenIncentive fails for ETH, try handleResult as fallback\n            if (error.data === \"0x2b4fa360\") {\n                return await this.handleResult(specId);\n            }\n            throw error;\n        }\n    }\n    constructor(){\n        this.provider = null;\n        this.signer = null;\n        this.contract = null;\n        this.realityEthContract = null;\n    }\n}\n// Export a singleton instance\nconst web3Service = new Web3Service();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvd2ViM1NlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsY0FBYztBQUNkLGtGQUFrRjtBQUNsRix5RkFBeUY7QUFDekYsbUZBQW1GO0FBQ25GLHlEQUF5RDtBQUN6QjtBQTZEaEMsK0VBQStFO0FBQy9FLE1BQU1DLGVBQWU7SUFDbkI7UUFDRSxVQUFVLEVBQUU7UUFDWixRQUFRO1FBQ1IsV0FBVztZQUFDO2dCQUFDLGdCQUFnQjtnQkFBVyxRQUFRO2dCQUFJLFFBQVE7WUFBUztTQUFFO1FBQ3ZFLG1CQUFtQjtRQUNuQixRQUFRO0lBQ1Y7SUFDQTtRQUNFLFVBQVU7WUFDUjtnQkFBQyxnQkFBZ0I7Z0JBQVcsUUFBUTtnQkFBYyxRQUFRO1lBQVM7WUFDbkU7Z0JBQUMsZ0JBQWdCO2dCQUFXLFFBQVE7Z0JBQWtCLFFBQVE7WUFBUztZQUN2RTtnQkFBQyxnQkFBZ0I7Z0JBQVcsUUFBUTtnQkFBaUIsUUFBUTtZQUFTO1NBQ3ZFO1FBQ0QsUUFBUTtRQUNSLFdBQVcsRUFBRTtRQUNiLG1CQUFtQjtRQUNuQixRQUFRO0lBQ1Y7SUFDQTtRQUNFLFVBQVU7WUFDUjtnQkFBQyxnQkFBZ0I7Z0JBQVcsUUFBUTtnQkFBZ0IsUUFBUTtZQUFTO1lBQ3JFO2dCQUFDLGdCQUFnQjtnQkFBVyxRQUFRO2dCQUFZLFFBQVE7WUFBUztZQUNqRTtnQkFBQyxnQkFBZ0I7Z0JBQVcsUUFBUTtnQkFBZ0IsUUFBUTtZQUFTO1lBQ3JFO2dCQUFDLGdCQUFnQjtnQkFBVyxRQUFRO2dCQUFTLFFBQVE7WUFBUztTQUMvRDtRQUNELFFBQVE7UUFDUixXQUFXO1lBQUM7Z0JBQUMsZ0JBQWdCO2dCQUFXLFFBQVE7Z0JBQVUsUUFBUTtZQUFTO1NBQUU7UUFDN0UsbUJBQW1CO1FBQ25CLFFBQVE7SUFDVjtJQUNBO1FBQ0UsVUFBVTtZQUFDO2dCQUFDLGdCQUFnQjtnQkFBVyxRQUFRO2dCQUFVLFFBQVE7WUFBUztTQUFFO1FBQzVF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VSxNQUFNRCxHQUFHaEQsSUFBSTtZQUc3QixPQUFPZ0QsR0FBR3ZDLElBQUk7UUFDaEIsRUFBRSxPQUFPakcsT0FBWTtZQUNuQkMsUUFBUUQsS0FBSyxDQUFDLGlDQUFpQ0E7WUFFL0MsMkVBQTJFO1lBQzNFLElBQUlBLE1BQU11RCxJQUFJLEtBQUssY0FBYztnQkFFL0IsT0FBTyxNQUFNLElBQUksQ0FBQ2dGLFlBQVksQ0FBQ3RIO1lBQ2pDO1lBRUEsTUFBTWpCO1FBQ1I7SUFDRjs7YUE3ekVRUixXQUEwQzthQUMxQ0UsU0FBc0M7YUFDdENJLFdBQXVDO2FBQ3ZDQyxxQkFBZ0Q7O0FBMnpFMUQ7QUFFQSw4QkFBOEI7QUFDdkIsTUFBTW1TLGNBQWMsSUFBSW5ULGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWNoYXJkaGEvRG9jdW1lbnRzL+i7n+mrlOW3peeoiy9Qcm9qZWN0cy9LYWktU2lnbi1CdWlsZGVyL2Zyb250ZW5kL3NyYy9saWIvd2ViM1NlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcbi8vIFR5cGVTY3JpcHQgaXMgZGlzYWJsZWQgaW4gdGhpcyBmaWxlIGR1ZSB0byBkeW5hbWljIGNvbnRyYWN0IGludGVyYWN0aW9ucyBhY3Jvc3Ncbi8vIG11bHRpcGxlIEthaVNpZ24gdmVyc2lvbnMgYW5kIGV0aGVycyB2NiBmdW5jdGlvbiBBUElzIChlLmcuLCAuc3RhdGljQ2FsbCwgLmVzdGltYXRlR2FzXG4vLyBvbiBmdW5jdGlvbiBvYmplY3RzKS4gU3Ryb25nIHR5cGluZyBoZXJlIGNhdXNlZCBub2lzeSwgbm9uLWFjdGlvbmFibGUgZXJyb3JzIGFuZFxuLy8gZHVwbGljYXRlIEFQSSB2YXJpYW50czsgcnVudGltZSBiZWhhdmlvciBpcyBwcmVzZXJ2ZWQuXG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tIFwiZXRoZXJzXCI7XG5cbi8vIERlY2xhcmUgdGhlIHdpbmRvdy5ldGhlcmV1bSBmb3IgVHlwZVNjcmlwdFxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBldGhlcmV1bT86IHtcbiAgICAgIGlzTWV0YU1hc2s/OiBib29sZWFuO1xuICAgICAgcmVxdWVzdDogKHJlcXVlc3Q6IHsgbWV0aG9kOiBzdHJpbmc7IHBhcmFtcz86IEFycmF5PGFueT4gfSkgPT4gUHJvbWlzZTxhbnk+O1xuICAgICAgb24/OiAoZXZlbnQ6IHN0cmluZywgaGFuZGxlcjogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKSA9PiB2b2lkO1xuICAgICAgcmVtb3ZlTGlzdGVuZXI/OiAoZXZlbnQ6IHN0cmluZywgaGFuZGxlcjogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKSA9PiB2b2lkO1xuICAgIH07XG4gIH1cbn1cblxuLy8gVHlwZSBmb3IgY29udHJhY3QgbWV0aG9kcyB0byBoYW5kbGUgVFMgZXJyb3JzIChWMSBjb250cmFjdClcbnR5cGUgQ29udHJhY3RXaXRoTWV0aG9kcyA9IGV0aGVycy5Db250cmFjdCAmIHtcbiAgbWluQm9uZDogKCkgPT4gUHJvbWlzZTxiaWdpbnQ+O1xuICAvLyBjb21taXRTcGVjIG5vIGxvbmdlciBhY2NlcHRzIGFuIGluY2VudGl2ZUlkLiBJdCBub3cgdGFrZXMgb25seSAoYnl0ZXMzMiBjb21taXRtZW50LCBhZGRyZXNzIHRhcmdldENvbnRyYWN0LCB1aW50MjU2IGNoYWluSWQpLlxuICBjb21taXRTcGVjOiAoY29tbWl0bWVudDogc3RyaW5nLCB0YXJnZXRDb250cmFjdDogc3RyaW5nLCB0YXJnZXRDaGFpbklkOiBudW1iZXIpID0+IFByb21pc2U8YW55PjtcbiAgcmV2ZWFsU3BlYzogKGNvbW1pdG1lbnRJZDogc3RyaW5nLCBibG9iSGFzaDogc3RyaW5nLCBtZXRhZGF0YUhhc2g6IHN0cmluZywgbm9uY2U6IGJpZ2ludCwgb3B0aW9uczogeyB2YWx1ZTogYmlnaW50IH0pID0+IFByb21pc2U8YW55PjtcbiAgcHJvcG9zZVNwZWM6IChzcGVjSUQ6IHN0cmluZywgb3B0aW9uczogeyB2YWx1ZTogYmlnaW50IH0pID0+IFByb21pc2U8YW55PjtcbiAgYXNzZXJ0U3BlY1ZhbGlkOiAoc3BlY0lEOiBzdHJpbmcsIG9wdGlvbnM6IHsgdmFsdWU6IGJpZ2ludCB9KSA9PiBQcm9taXNlPGFueT47XG4gIGFzc2VydFNwZWNJbnZhbGlkOiAoc3BlY0lEOiBzdHJpbmcsIG9wdGlvbnM6IHsgdmFsdWU6IGJpZ2ludCB9KSA9PiBQcm9taXNlPGFueT47XG4gIGhhbmRsZVJlc3VsdDogKHNwZWNJRDogc3RyaW5nKSA9PiBQcm9taXNlPGFueT47XG4gIGNsYWltQWN0aXZlVG9rZW5JbmNlbnRpdmU6IChzcGVjSUQ6IHN0cmluZywgdG9rZW46IHN0cmluZykgPT4gUHJvbWlzZTxhbnk+O1xuICBzZXR0bGVCb25kczogKHNwZWNJRDogc3RyaW5nKSA9PiBQcm9taXNlPGFueT47XG4gIGdldFN0YXR1czogKGlwZnNIYXNoOiBzdHJpbmcpID0+IFByb21pc2U8bnVtYmVyPjtcbiAgaXNBY2NlcHRlZDogKGlwZnNIYXNoOiBzdHJpbmcpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIGdldENyZWF0ZWRUaW1lc3RhbXA6IChpcGZzSGFzaDogc3RyaW5nKSA9PiBQcm9taXNlPGJpZ2ludD47XG4gIGNyZWF0ZUluY2VudGl2ZTogKHRhcmdldENvbnRyYWN0OiBzdHJpbmcsIHRhcmdldENoYWluSWQ6IG51bWJlciwgYW1vdW50OiBiaWdpbnQsIGR1cmF0aW9uOiBiaWdpbnQsIGRlc2NyaXB0aW9uOiBzdHJpbmcsIG9wdGlvbnM6IHsgdmFsdWU6IGJpZ2ludCB9KSA9PiBQcm9taXNlPGFueT47XG4gIGdldFNwZWNzQnlDb250cmFjdDogKHRhcmdldENvbnRyYWN0OiBzdHJpbmcsIGNoYWluSWQ6IG51bWJlcikgPT4gUHJvbWlzZTxzdHJpbmdbXT47XG4gIGdldENvbnRyYWN0U3BlY0NvdW50OiAodGFyZ2V0Q29udHJhY3Q6IHN0cmluZykgPT4gUHJvbWlzZTxiaWdpbnQ+O1xuICBzcGVjczogKHNwZWNJRDogc3RyaW5nKSA9PiBQcm9taXNlPGFueT47XG4gIGluY2VudGl2ZXM6IChpbmNlbnRpdmVJZDogc3RyaW5nKSA9PiBQcm9taXNlPGFueT47XG4gIGNvbW1pdG1lbnRzOiAoY29tbWl0bWVudElkOiBzdHJpbmcpID0+IFByb21pc2U8YW55PjtcbiAgYm9uZHNTZXR0bGVkOiAoc3BlY0lEOiBzdHJpbmcpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIHJlYWxpdHlFVEg6ICgpID0+IFByb21pc2U8c3RyaW5nPjtcbn07XG5cbi8vIFR5cGUgZm9yIFJlYWxpdHkuZXRoIGNvbnRyYWN0IG1ldGhvZHNcbnR5cGUgUmVhbGl0eUV0aENvbnRyYWN0ID0gZXRoZXJzLkNvbnRyYWN0ICYge1xuICBnZXRCb25kOiAocXVlc3Rpb25JZDogc3RyaW5nKSA9PiBQcm9taXNlPGJpZ2ludD47XG4gIGdldE1pbkJvbmQ6IChxdWVzdGlvbklkOiBzdHJpbmcpID0+IFByb21pc2U8YmlnaW50PjtcbiAgaXNGaW5hbGl6ZWQ6IChxdWVzdGlvbklkOiBzdHJpbmcpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIHJlc3VsdEZvcjogKHF1ZXN0aW9uSWQ6IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmc+O1xuICBmaW5hbGl6ZTogKHF1ZXN0aW9uSWQ6IHN0cmluZykgPT4gUHJvbWlzZTxhbnk+O1xuICBxdWVzdGlvbnM6IChxdWVzdGlvbklkOiBzdHJpbmcpID0+IFByb21pc2U8e1xuICAgIGNvbnRlbnRfaGFzaDogc3RyaW5nO1xuICAgIGFyYml0cmF0b3I6IHN0cmluZztcbiAgICBvcGVuaW5nX3RzOiBiaWdpbnQ7XG4gICAgdGltZW91dDogYmlnaW50O1xuICAgIGZpbmFsaXplX3RzOiBiaWdpbnQ7XG4gICAgaXNfcGVuZGluZ19hcmJpdHJhdGlvbjogYm9vbGVhbjtcbiAgICBib3VudHk6IGJpZ2ludDtcbiAgICBiZXN0X2Fuc3dlcjogc3RyaW5nO1xuICAgIGhpc3RvcnlfaGFzaDogc3RyaW5nO1xuICAgIGJvbmQ6IGJpZ2ludDtcbiAgICBtaW5fYm9uZDogYmlnaW50O1xuICB9Pjtcbn07XG5cbi8vIEFCSSBmb3IgdGhlIEthaVNpZ24gVjEgY29udHJhY3QgLSBVcGRhdGVkIHRvIG1hdGNoIGFjdHVhbCBjb250cmFjdCBpbnRlcmZhY2VcbmNvbnN0IENPTlRSQUNUX0FCSSA9IFtcbiAge1xuICAgIFwiaW5wdXRzXCI6IFtdLFxuICAgIFwibmFtZVwiOiBcIm1pbkJvbmRcIixcbiAgICBcIm91dHB1dHNcIjogW3tcImludGVybmFsVHlwZVwiOiBcInVpbnQyNTZcIiwgXCJuYW1lXCI6IFwiXCIsIFwidHlwZVwiOiBcInVpbnQyNTZcIn1dLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIiwgXCJuYW1lXCI6IFwiY29tbWl0bWVudFwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLCBcIm5hbWVcIjogXCJ0YXJnZXRDb250cmFjdFwiLCBcInR5cGVcIjogXCJhZGRyZXNzXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDI1NlwiLCBcIm5hbWVcIjogXCJ0YXJnZXRDaGFpbklkXCIsIFwidHlwZVwiOiBcInVpbnQyNTZcIn1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcImNvbW1pdFNwZWNcIixcbiAgICBcIm91dHB1dHNcIjogW10sXG4gICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJub25wYXlhYmxlXCIsXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLCBcIm5hbWVcIjogXCJjb21taXRtZW50SWRcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIiwgXCJuYW1lXCI6IFwiYmxvYkhhc2hcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIiwgXCJuYW1lXCI6IFwibWV0YWRhdGFIYXNoXCIsIFwidHlwZVwiOiBcImJ5dGVzMzJcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50MjU2XCIsIFwibmFtZVwiOiBcIm5vbmNlXCIsIFwidHlwZVwiOiBcInVpbnQyNTZcIn1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcInJldmVhbFNwZWNcIixcbiAgICBcIm91dHB1dHNcIjogW3tcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIiwgXCJuYW1lXCI6IFwic3BlY0lEXCIsIFwidHlwZVwiOiBcImJ5dGVzMzJcIn1dLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwicGF5YWJsZVwiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiaW5wdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsIFwibmFtZVwiOiBcInNwZWNJRFwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9XSxcbiAgICBcIm5hbWVcIjogXCJwcm9wb3NlU3BlY1wiLFxuICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInBheWFibGVcIixcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImlucHV0c1wiOiBbe1wiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLCBcIm5hbWVcIjogXCJzcGVjSURcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwifV0sXG4gICAgXCJuYW1lXCI6IFwiYXNzZXJ0U3BlY1ZhbGlkXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwicGF5YWJsZVwiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiaW5wdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsIFwibmFtZVwiOiBcInNwZWNJRFwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9XSxcbiAgICBcIm5hbWVcIjogXCJhc3NlcnRTcGVjSW52YWxpZFwiLFxuICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInBheWFibGVcIixcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJhZGRyZXNzXCIsIFwibmFtZVwiOiBcInRhcmdldENvbnRyYWN0XCIsIFwidHlwZVwiOiBcImFkZHJlc3NcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50MjU2XCIsIFwibmFtZVwiOiBcInRhcmdldENoYWluSWRcIiwgXCJ0eXBlXCI6IFwidWludDI1NlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQyNTZcIiwgXCJuYW1lXCI6IFwiYW1vdW50XCIsIFwidHlwZVwiOiBcInVpbnQyNTZcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50NjRcIiwgXCJuYW1lXCI6IFwiZHVyYXRpb25cIiwgXCJ0eXBlXCI6IFwidWludDY0XCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwic3RyaW5nXCIsIFwibmFtZVwiOiBcImRlc2NyaXB0aW9uXCIsIFwidHlwZVwiOiBcInN0cmluZ1wifVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwiY3JlYXRlSW5jZW50aXZlXCIsXG4gICAgXCJvdXRwdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsIFwibmFtZVwiOiBcImluY2VudGl2ZUlkXCIsIFwidHlwZVwiOiBcImJ5dGVzMzJcIn1dLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwicGF5YWJsZVwiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiaW5wdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJhZGRyZXNzXCIsIFwibmFtZVwiOiBcInVzZXJcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifV0sXG4gICAgXCJuYW1lXCI6IFwiZ2V0VXNlckluY2VudGl2ZXNcIixcbiAgICBcIm91dHB1dHNcIjogW3tcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJbXVwiLCBcIm5hbWVcIjogXCJcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMltdXCJ9XSxcbiAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImlucHV0c1wiOiBbe1wiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLCBcIm5hbWVcIjogXCJpbmNlbnRpdmVJZFwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9XSxcbiAgICBcIm5hbWVcIjogXCJpbmNlbnRpdmVzXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwiY3JlYXRvclwiLCBcInR5cGVcIjogXCJhZGRyZXNzXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDgwXCIsIFwibmFtZVwiOiBcImFtb3VudFwiLCBcInR5cGVcIjogXCJ1aW50ODBcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50MTZcIiwgXCJuYW1lXCI6IFwicmVzZXJ2ZWQxXCIsIFwidHlwZVwiOiBcInVpbnQxNlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQ2NFwiLCBcIm5hbWVcIjogXCJkZWFkbGluZVwiLCBcInR5cGVcIjogXCJ1aW50NjRcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50NjRcIiwgXCJuYW1lXCI6IFwiY3JlYXRlZEF0XCIsIFwidHlwZVwiOiBcInVpbnQ2NFwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwidGFyZ2V0Q29udHJhY3RcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImJvb2xcIiwgXCJuYW1lXCI6IFwiaXNDbGFpbWVkXCIsIFwidHlwZVwiOiBcImJvb2xcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJib29sXCIsIFwibmFtZVwiOiBcImlzQWN0aXZlXCIsIFwidHlwZVwiOiBcImJvb2xcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50MjU2XCIsIFwibmFtZVwiOiBcImNoYWluSWRcIiwgXCJ0eXBlXCI6IFwidWludDI1NlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInN0cmluZ1wiLCBcIm5hbWVcIjogXCJkZXNjcmlwdGlvblwiLCBcInR5cGVcIjogXCJzdHJpbmdcIn1cbiAgICBdLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiaW5wdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsIFwibmFtZVwiOiBcImNvbW1pdG1lbnRJZFwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9XSxcbiAgICBcIm5hbWVcIjogXCJjb21taXRtZW50c1wiLFxuICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJhZGRyZXNzXCIsIFwibmFtZVwiOiBcImNvbW1pdHRlclwiLCBcInR5cGVcIjogXCJhZGRyZXNzXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDY0XCIsIFwibmFtZVwiOiBcImNvbW1pdFRpbWVzdGFtcFwiLCBcInR5cGVcIjogXCJ1aW50NjRcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50MzJcIiwgXCJuYW1lXCI6IFwicmVzZXJ2ZWQxXCIsIFwidHlwZVwiOiBcInVpbnQzMlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwidGFyZ2V0Q29udHJhY3RcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImJvb2xcIiwgXCJuYW1lXCI6IFwiaXNSZXZlYWxlZFwiLCBcInR5cGVcIjogXCJib29sXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDgwXCIsIFwibmFtZVwiOiBcImJvbmRBbW91bnRcIiwgXCJ0eXBlXCI6IFwidWludDgwXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDhcIiwgXCJuYW1lXCI6IFwicmVzZXJ2ZWRcIiwgXCJ0eXBlXCI6IFwidWludDhcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50NjRcIiwgXCJuYW1lXCI6IFwicmV2ZWFsRGVhZGxpbmVcIiwgXCJ0eXBlXCI6IFwidWludDY0XCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDI1NlwiLCBcIm5hbWVcIjogXCJjaGFpbklkXCIsIFwidHlwZVwiOiBcInVpbnQyNTZcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsIFwibmFtZVwiOiBcImluY2VudGl2ZUlkXCIsIFwidHlwZVwiOiBcImJ5dGVzMzJcIn1cbiAgICBdLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwidGFyZ2V0Q29udHJhY3RcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQyNTZcIiwgXCJuYW1lXCI6IFwiY2hhaW5JZFwiLCBcInR5cGVcIjogXCJ1aW50MjU2XCJ9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJnZXRTcGVjc0J5Q29udHJhY3RcIixcbiAgICBcIm91dHB1dHNcIjogW3tcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJbXVwiLCBcIm5hbWVcIjogXCJcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMltdXCJ9XSxcbiAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImlucHV0c1wiOiBbe1wiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLCBcIm5hbWVcIjogXCJzcGVjSWRcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwifV0sXG4gICAgXCJuYW1lXCI6IFwic3BlY3NcIixcbiAgICBcIm91dHB1dHNcIjogW1xuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDY0XCIsIFwibmFtZVwiOiBcImNyZWF0ZWRUaW1lc3RhbXBcIiwgXCJ0eXBlXCI6IFwidWludDY0XCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDY0XCIsIFwibmFtZVwiOiBcInByb3Bvc2VkVGltZXN0YW1wXCIsIFwidHlwZVwiOiBcInVpbnQ2NFwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQ4XCIsIFwibmFtZVwiOiBcInN0YXR1c1wiLCBcInR5cGVcIjogXCJ1aW50OFwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQ4MFwiLCBcIm5hbWVcIjogXCJ0b3RhbEJvbmRzXCIsIFwidHlwZVwiOiBcInVpbnQ4MFwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQzMlwiLCBcIm5hbWVcIjogXCJyZXNlcnZlZFwiLCBcInR5cGVcIjogXCJ1aW50MzJcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJhZGRyZXNzXCIsIFwibmFtZVwiOiBcImNyZWF0b3JcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwidGFyZ2V0Q29udHJhY3RcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIiwgXCJuYW1lXCI6IFwiYmxvYkhhc2hcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIiwgXCJuYW1lXCI6IFwicXVlc3Rpb25JZFwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLCBcIm5hbWVcIjogXCJpbmNlbnRpdmVJZFwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDI1NlwiLCBcIm5hbWVcIjogXCJjaGFpbklkXCIsIFwidHlwZVwiOiBcInVpbnQyNTZcIn1cbiAgICBdLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiaW5wdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsIFwibmFtZVwiOiBcInNwZWNJRFwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9XSxcbiAgICBcIm5hbWVcIjogXCJoYW5kbGVSZXN1bHRcIixcbiAgICBcIm91dHB1dHNcIjogW10sXG4gICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJub25wYXlhYmxlXCIsXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLCBcIm5hbWVcIjogXCJzcGVjSURcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwidG9rZW5cIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwiY2xhaW1BY3RpdmVUb2tlbkluY2VudGl2ZVwiLFxuICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcIm5vbnBheWFibGVcIixcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImlucHV0c1wiOiBbe1wiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLCBcIm5hbWVcIjogXCJzcGVjSURcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwifV0sXG4gICAgXCJuYW1lXCI6IFwic2V0dGxlQm9uZHNcIixcbiAgICBcIm91dHB1dHNcIjogW10sXG4gICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJub25wYXlhYmxlXCIsXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJpbnB1dHNcIjogW3tcImludGVybmFsVHlwZVwiOiBcInN0cmluZ1wiLCBcIm5hbWVcIjogXCJpcGZzXCIsIFwidHlwZVwiOiBcInN0cmluZ1wifV0sXG4gICAgXCJuYW1lXCI6IFwiZ2V0U3RhdHVzXCIsXG4gICAgXCJvdXRwdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50OFwiLCBcIm5hbWVcIjogXCJcIiwgXCJ0eXBlXCI6IFwidWludDhcIn1dLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiaW5wdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJzdHJpbmdcIiwgXCJuYW1lXCI6IFwiaXBmc1wiLCBcInR5cGVcIjogXCJzdHJpbmdcIn1dLFxuICAgIFwibmFtZVwiOiBcImlzQWNjZXB0ZWRcIixcbiAgICBcIm91dHB1dHNcIjogW3tcImludGVybmFsVHlwZVwiOiBcImJvb2xcIiwgXCJuYW1lXCI6IFwiXCIsIFwidHlwZVwiOiBcImJvb2xcIn1dLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiaW5wdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJzdHJpbmdcIiwgXCJuYW1lXCI6IFwiaXBmc1wiLCBcInR5cGVcIjogXCJzdHJpbmdcIn1dLFxuICAgIFwibmFtZVwiOiBcImdldENyZWF0ZWRUaW1lc3RhbXBcIixcbiAgICBcIm91dHB1dHNcIjogW3tcImludGVybmFsVHlwZVwiOiBcInVpbnQ2NFwiLCBcIm5hbWVcIjogXCJcIiwgXCJ0eXBlXCI6IFwidWludDY0XCJ9XSxcbiAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJhZGRyZXNzXCIsIFwibmFtZVwiOiBcInRhcmdldENvbnRyYWN0XCIsIFwidHlwZVwiOiBcImFkZHJlc3NcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50MjU2XCIsIFwibmFtZVwiOiBcInRhcmdldENoYWluSWRcIiwgXCJ0eXBlXCI6IFwidWludDI1NlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQyNTZcIiwgXCJuYW1lXCI6IFwiYW1vdW50XCIsIFwidHlwZVwiOiBcInVpbnQyNTZcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50NjRcIiwgXCJuYW1lXCI6IFwiZHVyYXRpb25cIiwgXCJ0eXBlXCI6IFwidWludDY0XCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwic3RyaW5nXCIsIFwibmFtZVwiOiBcImRlc2NyaXB0aW9uXCIsIFwidHlwZVwiOiBcInN0cmluZ1wifVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwiY3JlYXRlSW5jZW50aXZlXCIsXG4gICAgXCJvdXRwdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsIFwibmFtZVwiOiBcImluY2VudGl2ZUlkXCIsIFwidHlwZVwiOiBcImJ5dGVzMzJcIn1dLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwicGF5YWJsZVwiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwidGFyZ2V0Q29udHJhY3RcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQyNTZcIiwgXCJuYW1lXCI6IFwiY2hhaW5JZFwiLCBcInR5cGVcIjogXCJ1aW50MjU2XCJ9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJnZXRTcGVjc0J5Q29udHJhY3RcIixcbiAgICBcIm91dHB1dHNcIjogW3tcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJbXVwiLCBcIm5hbWVcIjogXCJcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMltdXCJ9XSxcbiAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImlucHV0c1wiOiBbe1wiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLCBcIm5hbWVcIjogXCJ0YXJnZXRDb250cmFjdFwiLCBcInR5cGVcIjogXCJhZGRyZXNzXCJ9XSxcbiAgICBcIm5hbWVcIjogXCJnZXRDb250cmFjdFNwZWNDb3VudFwiLFxuICAgIFwib3V0cHV0c1wiOiBbe1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDI1NlwiLCBcIm5hbWVcIjogXCJcIiwgXCJ0eXBlXCI6IFwidWludDI1NlwifV0sXG4gICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJ2aWV3XCIsXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJpbnB1dHNcIjogW3tcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIiwgXCJuYW1lXCI6IFwiXCIsIFwidHlwZVwiOiBcImJ5dGVzMzJcIn1dLFxuICAgIFwibmFtZVwiOiBcInNwZWNzXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQ2NFwiLCBcIm5hbWVcIjogXCJjcmVhdGVkVGltZXN0YW1wXCIsIFwidHlwZVwiOiBcInVpbnQ2NFwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQ2NFwiLCBcIm5hbWVcIjogXCJwcm9wb3NlZFRpbWVzdGFtcFwiLCBcInR5cGVcIjogXCJ1aW50NjRcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50OFwiLCBcIm5hbWVcIjogXCJzdGF0dXNcIiwgXCJ0eXBlXCI6IFwidWludDhcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJib29sXCIsIFwibmFtZVwiOiBcImJvbmRzU2V0dGxlZFwiLCBcInR5cGVcIjogXCJib29sXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDQ4XCIsIFwibmFtZVwiOiBcInRvdGFsQm9uZHNcIiwgXCJ0eXBlXCI6IFwidWludDQ4XCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDhcIiwgXCJuYW1lXCI6IFwicmVzZXJ2ZWRcIiwgXCJ0eXBlXCI6IFwidWludDhcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJhZGRyZXNzXCIsIFwibmFtZVwiOiBcImNyZWF0b3JcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwidGFyZ2V0Q29udHJhY3RcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInN0cmluZ1wiLCBcIm5hbWVcIjogXCJpcGZzXCIsIFwidHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIiwgXCJuYW1lXCI6IFwicXVlc3Rpb25JZFwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLCBcIm5hbWVcIjogXCJpbmNlbnRpdmVJZFwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9XG4gICAgXSxcbiAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImlucHV0c1wiOiBbe1wiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLCBcIm5hbWVcIjogXCJcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwifV0sXG4gICAgXCJuYW1lXCI6IFwiY29tbWl0bWVudHNcIixcbiAgICBcIm91dHB1dHNcIjogW1xuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLCBcIm5hbWVcIjogXCJjb21taXR0ZXJcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQ2NFwiLCBcIm5hbWVcIjogXCJjb21taXRUaW1lc3RhbXBcIiwgXCJ0eXBlXCI6IFwidWludDY0XCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDMyXCIsIFwibmFtZVwiOiBcInJlc2VydmVkMVwiLCBcInR5cGVcIjogXCJ1aW50MzJcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJhZGRyZXNzXCIsIFwibmFtZVwiOiBcInRhcmdldENvbnRyYWN0XCIsIFwidHlwZVwiOiBcImFkZHJlc3NcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJib29sXCIsIFwibmFtZVwiOiBcImlzUmV2ZWFsZWRcIiwgXCJ0eXBlXCI6IFwiYm9vbFwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQ4MFwiLCBcIm5hbWVcIjogXCJib25kQW1vdW50XCIsIFwidHlwZVwiOiBcInVpbnQ4MFwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQ4XCIsIFwibmFtZVwiOiBcInJlc2VydmVkXCIsIFwidHlwZVwiOiBcInVpbnQ4XCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDY0XCIsIFwibmFtZVwiOiBcInJldmVhbERlYWRsaW5lXCIsIFwidHlwZVwiOiBcInVpbnQ2NFwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQyNTZcIiwgXCJuYW1lXCI6IFwiY2hhaW5JZFwiLCBcInR5cGVcIjogXCJ1aW50MjU2XCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLCBcIm5hbWVcIjogXCJpbmNlbnRpdmVJZFwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9XG4gICAgXSxcbiAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImlucHV0c1wiOiBbe1wiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLCBcIm5hbWVcIjogXCJcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwifV0sXG4gICAgXCJuYW1lXCI6IFwiaW5jZW50aXZlc1wiLFxuICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJhZGRyZXNzXCIsIFwibmFtZVwiOiBcImNyZWF0b3JcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwidG9rZW5cIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQxMjhcIiwgXCJuYW1lXCI6IFwiYW1vdW50XCIsIFwidHlwZVwiOiBcInVpbnQxMjhcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50NjRcIiwgXCJuYW1lXCI6IFwiZGVhZGxpbmVcIiwgXCJ0eXBlXCI6IFwidWludDY0XCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDY0XCIsIFwibmFtZVwiOiBcImNyZWF0ZWRBdFwiLCBcInR5cGVcIjogXCJ1aW50NjRcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJhZGRyZXNzXCIsIFwibmFtZVwiOiBcInRhcmdldENvbnRyYWN0XCIsIFwidHlwZVwiOiBcImFkZHJlc3NcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJib29sXCIsIFwibmFtZVwiOiBcImlzQ2xhaW1lZFwiLCBcInR5cGVcIjogXCJib29sXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwiYm9vbFwiLCBcIm5hbWVcIjogXCJpc0FjdGl2ZVwiLCBcInR5cGVcIjogXCJib29sXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDgwXCIsIFwibmFtZVwiOiBcInJlc2VydmVkXCIsIFwidHlwZVwiOiBcInVpbnQ4MFwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQyNTZcIiwgXCJuYW1lXCI6IFwiY2hhaW5JZFwiLCBcInR5cGVcIjogXCJ1aW50MjU2XCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwic3RyaW5nXCIsIFwibmFtZVwiOiBcImRlc2NyaXB0aW9uXCIsIFwidHlwZVwiOiBcInN0cmluZ1wifVxuICAgIF0sXG4gICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJ2aWV3XCIsXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJpbnB1dHNcIjogW10sXG4gICAgXCJuYW1lXCI6IFwicmVhbGl0eUVUSFwiLFxuICAgIFwib3V0cHV0c1wiOiBbe1wiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLCBcIm5hbWVcIjogXCJcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifV0sXG4gICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJ2aWV3XCIsXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJpbnB1dHNcIjogW10sXG4gICAgXCJuYW1lXCI6IFwidHJlYXN1cnlcIixcbiAgICBcIm91dHB1dHNcIjogW3tcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwiXCIsIFwidHlwZVwiOiBcImFkZHJlc3NcIn1dLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiYW5vbnltb3VzXCI6IGZhbHNlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcImluZGV4ZWRcIjogdHJ1ZSwgXCJpbnRlcm5hbFR5cGVcIjogXCJhZGRyZXNzXCIsIFwibmFtZVwiOiBcImNvbW1pdHRlclwiLCBcInR5cGVcIjogXCJhZGRyZXNzXCJ9LFxuICAgICAge1wiaW5kZXhlZFwiOiB0cnVlLCBcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIiwgXCJuYW1lXCI6IFwiY29tbWl0bWVudElkXCIsIFwidHlwZVwiOiBcImJ5dGVzMzJcIn0sXG4gICAgICB7XCJpbmRleGVkXCI6IHRydWUsIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLCBcIm5hbWVcIjogXCJ0YXJnZXRDb250cmFjdFwiLCBcInR5cGVcIjogXCJhZGRyZXNzXCJ9LFxuICAgICAge1wiaW5kZXhlZFwiOiBmYWxzZSwgXCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50MjU2XCIsIFwibmFtZVwiOiBcImNoYWluSWRcIiwgXCJ0eXBlXCI6IFwidWludDI1NlwifSxcbiAgICAgIHtcImluZGV4ZWRcIjogZmFsc2UsIFwiaW50ZXJuYWxUeXBlXCI6IFwidWludDI1NlwiLCBcIm5hbWVcIjogXCJib25kQW1vdW50XCIsIFwidHlwZVwiOiBcInVpbnQyNTZcIn0sXG4gICAgICB7XCJpbmRleGVkXCI6IGZhbHNlLCBcImludGVybmFsVHlwZVwiOiBcInVpbnQ2NFwiLCBcIm5hbWVcIjogXCJyZXZlYWxEZWFkbGluZVwiLCBcInR5cGVcIjogXCJ1aW50NjRcIn1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcIkxvZ0NvbW1pdFNwZWNcIixcbiAgICBcInR5cGVcIjogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XCJpbmRleGVkXCI6IHRydWUsIFwiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLCBcIm5hbWVcIjogXCJpbmNlbnRpdmVJZFwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9LFxuICAgICAge1wiaW5kZXhlZFwiOiB0cnVlLCBcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwiY3JlYXRvclwiLCBcInR5cGVcIjogXCJhZGRyZXNzXCJ9LFxuICAgICAge1wiaW5kZXhlZFwiOiB0cnVlLCBcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwidGFyZ2V0Q29udHJhY3RcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgIHtcImluZGV4ZWRcIjogZmFsc2UsIFwiaW50ZXJuYWxUeXBlXCI6IFwidWludDI1NlwiLCBcIm5hbWVcIjogXCJjaGFpbklkXCIsIFwidHlwZVwiOiBcInVpbnQyNTZcIn0sXG4gICAgICB7XCJpbmRleGVkXCI6IGZhbHNlLCBcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwidG9rZW5cIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgIHtcImluZGV4ZWRcIjogZmFsc2UsIFwiaW50ZXJuYWxUeXBlXCI6IFwidWludDI1NlwiLCBcIm5hbWVcIjogXCJhbW91bnRcIiwgXCJ0eXBlXCI6IFwidWludDI1NlwifSxcbiAgICAgIHtcImluZGV4ZWRcIjogZmFsc2UsIFwiaW50ZXJuYWxUeXBlXCI6IFwidWludDY0XCIsIFwibmFtZVwiOiBcImRlYWRsaW5lXCIsIFwidHlwZVwiOiBcInVpbnQ2NFwifSxcbiAgICAgIHtcImluZGV4ZWRcIjogZmFsc2UsIFwiaW50ZXJuYWxUeXBlXCI6IFwic3RyaW5nXCIsIFwibmFtZVwiOiBcImRlc2NyaXB0aW9uXCIsIFwidHlwZVwiOiBcInN0cmluZ1wifVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwiTG9nSW5jZW50aXZlQ3JlYXRlZFwiLFxuICAgIFwidHlwZVwiOiBcImV2ZW50XCJcbiAgfSxcbiAge1xuICAgIFwiaW5wdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsIFwibmFtZVwiOiBcIlwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9XSxcbiAgICBcIm5hbWVcIjogXCJib25kc1NldHRsZWRcIixcbiAgICBcIm91dHB1dHNcIjogW3tcImludGVybmFsVHlwZVwiOiBcImJvb2xcIiwgXCJuYW1lXCI6IFwiXCIsIFwidHlwZVwiOiBcImJvb2xcIn1dLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfVxuXTtcblxuLy8gUmVhbGl0eS5ldGggY29udHJhY3QgQUJJIChtaW5pbWFsIGZvciBib25kIGNhbGN1bGF0aW9ucylcbmNvbnN0IFJFQUxJVFlfRVRIX0FCSSA9IFtcbiAge1xuICAgIFwiaW5wdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsIFwibmFtZVwiOiBcInF1ZXN0aW9uX2lkXCIsIFwidHlwZVwiOiBcImJ5dGVzMzJcIn1dLFxuICAgIFwibmFtZVwiOiBcImdldEJvbmRcIixcbiAgICBcIm91dHB1dHNcIjogW3tcImludGVybmFsVHlwZVwiOiBcInVpbnQyNTZcIiwgXCJuYW1lXCI6IFwiXCIsIFwidHlwZVwiOiBcInVpbnQyNTZcIn1dLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiaW5wdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsIFwibmFtZVwiOiBcInF1ZXN0aW9uX2lkXCIsIFwidHlwZVwiOiBcImJ5dGVzMzJcIn1dLFxuICAgIFwibmFtZVwiOiBcImdldE1pbkJvbmRcIixcbiAgICBcIm91dHB1dHNcIjogW3tcImludGVybmFsVHlwZVwiOiBcInVpbnQyNTZcIiwgXCJuYW1lXCI6IFwiXCIsIFwidHlwZVwiOiBcInVpbnQyNTZcIn1dLFxuICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiaW5wdXRzXCI6IFt7XCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsIFwibmFtZVwiOiBcIlwiLCBcInR5cGVcIjogXCJieXRlczMyXCJ9XSxcbiAgICBcIm5hbWVcIjogXCJxdWVzdGlvbnNcIixcbiAgICBcIm91dHB1dHNcIjogW1xuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLCBcIm5hbWVcIjogXCJjb250ZW50X2hhc2hcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIiwgXCJuYW1lXCI6IFwiYXJiaXRyYXRvclwiLCBcInR5cGVcIjogXCJhZGRyZXNzXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDMyXCIsIFwibmFtZVwiOiBcIm9wZW5pbmdfdHNcIiwgXCJ0eXBlXCI6IFwidWludDMyXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDMyXCIsIFwibmFtZVwiOiBcInRpbWVvdXRcIiwgXCJ0eXBlXCI6IFwidWludDMyXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDMyXCIsIFwibmFtZVwiOiBcImZpbmFsaXplX3RzXCIsIFwidHlwZVwiOiBcInVpbnQzMlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImJvb2xcIiwgXCJuYW1lXCI6IFwiaXNfcGVuZGluZ19hcmJpdHJhdGlvblwiLCBcInR5cGVcIjogXCJib29sXCJ9LFxuICAgICAge1wiaW50ZXJuYWxUeXBlXCI6IFwidWludDI1NlwiLCBcIm5hbWVcIjogXCJib3VudHlcIiwgXCJ0eXBlXCI6IFwidWludDI1NlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIiwgXCJuYW1lXCI6IFwiYmVzdF9hbnN3ZXJcIiwgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIiwgXCJuYW1lXCI6IFwiaGlzdG9yeV9oYXNoXCIsIFwidHlwZVwiOiBcImJ5dGVzMzJcIn0sXG4gICAgICB7XCJpbnRlcm5hbFR5cGVcIjogXCJ1aW50MjU2XCIsIFwibmFtZVwiOiBcImJvbmRcIiwgXCJ0eXBlXCI6IFwidWludDI1NlwifSxcbiAgICAgIHtcImludGVybmFsVHlwZVwiOiBcInVpbnQyNTZcIiwgXCJuYW1lXCI6IFwibWluX2JvbmRcIiwgXCJ0eXBlXCI6IFwidWludDI1NlwifVxuICAgIF0sXG4gICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJ2aWV3XCIsXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9XG5dO1xuXG4vLyBSZWFsaXR5LmV0aCBjb250cmFjdCBhZGRyZXNzIChTZXBvbGlhIGJ5IGRlZmF1bHQpXG5jb25zdCBSRUFMSVRZX0VUSF9BRERSRVNTID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfUkVBTElUWV9FVEhfQUREUkVTUyB8fFxuICBcIjB4YWYzM0RjQjZFOGM1YzREOWRERjU3OWY1MzAzMWI1MTRkMTk0NDlDQVwiO1xuXG4vLyBDb250cmFjdCBhZGRyZXNzIChjb25maWd1cmFibGUgdmlhIE5FWFRfUFVCTElDX0tBSVNJR05fQ09OVFJBQ1RfQUREUkVTUzsgZmFsbHMgYmFjayB0byBrbm93biBTZXBvbGlhIGFkZHIpXG5jb25zdCBSQVdfQ09OVFJBQ1RfQUREUkVTUyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0tBSVNJR05fQ09OVFJBQ1RfQUREUkVTUyB8fCBcIjB4NGRGRUEwQzJCNDcyYTE0Y0QwNTJhOGY5REY5ZjE5ZmE1Q0YwMzcxOVwiO1xuLy8gQ2hhaW4gSUQgKGNvbmZpZ3VyYWJsZSB2aWEgTkVYVF9QVUJMSUNfQ0hBSU5fSUQsIGRlZmF1bHRzIHRvIFNlcG9saWEpXG5jb25zdCBTRVBPTElBX0NIQUlOX0lEID0gTnVtYmVyKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NIQUlOX0lEIHx8IDExMTU1MTExKTtcblxuZXhwb3J0IGNsYXNzIFdlYjNTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBwcm92aWRlcjogZXRoZXJzLkJyb3dzZXJQcm92aWRlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHNpZ25lcjogZXRoZXJzLkpzb25ScGNTaWduZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjb250cmFjdDogQ29udHJhY3RXaXRoTWV0aG9kcyB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHJlYWxpdHlFdGhDb250cmFjdDogUmVhbGl0eUV0aENvbnRyYWN0IHwgbnVsbCA9IG51bGw7XG4gIFxuICAvKipcbiAgICogQ29ubmVjdCB0byBNZXRhTWFzayBhbmQgaW5pdGlhbGl6ZSB0aGUgY29udHJhY3RcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoZSBjbGllbnQgc2lkZS5cIik7XG4gICAgfVxuICAgIFxuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRhTWFzayBpcyBub3QgaW5zdGFsbGVkLiBQbGVhc2UgaW5zdGFsbCBNZXRhTWFzayB0byBjb250aW51ZS5cIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFJlcXVlc3QgYWNjb3VudCBhY2Nlc3NcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgd2luZG93LmV0aGVyZXVtLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghYWNjb3VudHMgfHwgYWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFjY291bnRzIGZvdW5kLiBQbGVhc2UgbWFrZSBzdXJlIE1ldGFNYXNrIGlzIHVubG9ja2VkLlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gSW5pdGlhbGl6ZSBwcm92aWRlciBhbmQgc2lnbmVyXG4gICAgICB0aGlzLnByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIod2luZG93LmV0aGVyZXVtKTtcbiAgICAgIHRoaXMuc2lnbmVyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRTaWduZXIoKTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBjb250cmFjdCAobmV0d29yayBjaGVjayBtb3ZlZCB0byBpbmRpdmlkdWFsIGZ1bmN0aW9ucyB0aGF0IG5lZWQgaXQpXG4gICAgICBjb25zdCBrYWlzaWduQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KFxuICAgICAgICBSQVdfQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgQ09OVFJBQ1RfQUJJLFxuICAgICAgICB0aGlzLnNpZ25lclxuICAgICAgKSBhcyBDb250cmFjdFdpdGhNZXRob2RzO1xuXG4gICAgICAvLyBBc3NpZ24gdG8gaW5zdGFuY2UgdmFyaWFibGVzIGFmdGVyIHN1Y2Nlc3NmdWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIHRoaXMuY29udHJhY3QgPSBrYWlzaWduQ29udHJhY3Q7XG4gICAgICAvLyBJbml0aWFsaXplIFJlYWxpdHkuZXRoIGNvbnRyYWN0IG5vdyBmb3IgcmVhZCBjYWxscyAoYm9uZCBpbmZvKVxuICAgICAgdGhpcy5yZWFsaXR5RXRoQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KFxuICAgICAgICBSRUFMSVRZX0VUSF9BRERSRVNTLFxuICAgICAgICBSRUFMSVRZX0VUSF9BQkksXG4gICAgICAgIHRoaXMucHJvdmlkZXJcbiAgICAgICkgYXMgUmVhbGl0eUV0aENvbnRyYWN0O1xuXG5cblxuICAgICAgcmV0dXJuIGFjY291bnRzWzBdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY29ubmVjdGluZyB0byBNZXRhTWFzazpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogQ2hlY2sgaWYgd2UncmUgb24gdGhlIFNlcG9saWEgbmV0d29ya1xuICAgKi9cbiAgYXN5bmMgY2hlY2tOZXR3b3JrKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5wcm92aWRlcikgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICByZXR1cm4gTnVtYmVyKG5ldHdvcmsuY2hhaW5JZCkgPT09IFNFUE9MSUFfQ0hBSU5fSUQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjaGVja2luZyBuZXR3b3JrOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIGJvbmQgYW1vdW50IHJlcXVpcmVkIGZvciBhIG5ldyBxdWVzdGlvbiBmcm9tIHRoZSBLYWlTaWduIGNvbnRyYWN0XG4gICAqL1xuICBhc3luYyBnZXRNaW5Cb25kKCk6IFByb21pc2U8YmlnaW50PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250cmFjdCBub3QgaW5pdGlhbGl6ZWQuIFBsZWFzZSBjb25uZWN0IGZpcnN0LlwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWluQm9uZCA9IGF3YWl0IHRoaXMuY29udHJhY3QubWluQm9uZCgpO1xuXG4gICAgICByZXR1cm4gbWluQm9uZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgbWluaW11bSBib25kIGZyb20gY29udHJhY3Q6XCIsIGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGEgcmVhc29uYWJsZSBkZWZhdWx0IGlmIGNvbnRyYWN0IGNhbGwgZmFpbHNcbiAgICAgIGNvbnN0IGZhbGxiYWNrQm9uZCA9IEJpZ0ludChcIjEwMDAwMDAwMDAwMDAwMFwiKTsgLy8gMC4wMDAxIEVUSFxuXG4gICAgICByZXR1cm4gZmFsbGJhY2tCb25kO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgcmVxdWlyZWQgYm9uZCBmb3IgYW5zd2VyaW5nIGEgc3BlY2lmaWMgcXVlc3Rpb25cbiAgICogQmFzZWQgb24gUmVhbGl0eS5ldGggcnVsZXM6IGZpcnN0IGFuc3dlciBuZWVkcyBtaW5fYm9uZCwgc3Vic2VxdWVudCBhbnN3ZXJzIG5lZWQgMnggcHJldmlvdXMgYm9uZFxuICAgKi9cbiAgYXN5bmMgZ2V0UmVxdWlyZWRCb25kRm9yUXVlc3Rpb24ocXVlc3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxiaWdpbnQ+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLnJlYWxpdHlFdGhDb250cmFjdCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZC4gUGxlYXNlIGNvbm5lY3QgZmlyc3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhbGl0eUV0aENvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChcbiAgICAgICAgICBSRUFMSVRZX0VUSF9BRERSRVNTLFxuICAgICAgICAgIFJFQUxJVFlfRVRIX0FCSSxcbiAgICAgICAgICB0aGlzLnByb3ZpZGVyXG4gICAgICAgICkgYXMgUmVhbGl0eUV0aENvbnRyYWN0O1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYm9uZCBmb3IgdGhpcyBxdWVzdGlvblxuICAgICAgY29uc3QgY3VycmVudEJvbmQgPSBhd2FpdCB0aGlzLnJlYWxpdHlFdGhDb250cmFjdC5nZXRCb25kKHF1ZXN0aW9uSWQpO1xuICAgICAgXG4gICAgICBpZiAoY3VycmVudEJvbmQgPT09IEJpZ0ludCgwKSkge1xuICAgICAgICAvLyBObyBwcmV2aW91cyBhbnN3ZXJzLCB1c2UgbWluaW11bSBib25kXG4gICAgICAgIGNvbnN0IG1pbkJvbmQgPSBhd2FpdCB0aGlzLnJlYWxpdHlFdGhDb250cmFjdC5nZXRNaW5Cb25kKHF1ZXN0aW9uSWQpO1xuXG4gICAgICAgIHJldHVybiBtaW5Cb25kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUHJldmlvdXMgYW5zd2VycyBleGlzdCwgbmVlZCB0byBkb3VibGUgdGhlIGN1cnJlbnQgYm9uZFxuICAgICAgICBjb25zdCByZXF1aXJlZEJvbmQgPSBjdXJyZW50Qm9uZCAqIEJpZ0ludCgyKTtcblxuICAgICAgICByZXR1cm4gcmVxdWlyZWRCb25kO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FsY3VsYXRpbmcgcmVxdWlyZWQgYm9uZCBmb3IgcXVlc3Rpb246XCIsIGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGNvbnRyYWN0IG1pbmltdW0gYm9uZFxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0TWluQm9uZCgpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBib25kIGluZm9ybWF0aW9uIGZvciBhIHF1ZXN0aW9uIChjdXJyZW50IGJvbmQsIG1pbmltdW0gYm9uZCwgYW5kIHJlcXVpcmVkIG5leHQgYm9uZClcbiAgICogSW4gVjEsIHdlIG5lZWQgdG8gY2hlY2sgaWYgYSBzcGVjIGV4aXN0cyBmaXJzdFxuICAgKi9cbiAgYXN5bmMgZ2V0Qm9uZEluZm8oaXBmc0hhc2g6IHN0cmluZyk6IFByb21pc2U8e1xuICAgIGN1cnJlbnRCb25kOiBiaWdpbnQ7XG4gICAgbWluQm9uZDogYmlnaW50O1xuICAgIHJlcXVpcmVkTmV4dEJvbmQ6IGJpZ2ludDtcbiAgICBoYXNBbnN3ZXJzOiBib29sZWFuO1xuICB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250cmFjdCBub3QgaW5pdGlhbGl6ZWQuIFBsZWFzZSBjb25uZWN0IGZpcnN0LlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5yZWFsaXR5RXRoQ29udHJhY3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBjb25uZWN0ZWQuIFBsZWFzZSBjb25uZWN0IGZpcnN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWxpdHlFdGhDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoXG4gICAgICAgICAgUkVBTElUWV9FVEhfQUREUkVTUyxcbiAgICAgICAgICBSRUFMSVRZX0VUSF9BQkksXG4gICAgICAgICAgdGhpcy5wcm92aWRlclxuICAgICAgICApIGFzIFJlYWxpdHlFdGhDb250cmFjdDtcbiAgICAgIH1cblxuICAgICAgLy8gR2VuZXJhdGUgc3BlY0lEIGZyb20gaWRlbnRpZmllciAobm93IGJsb2IgdmVyc2lvbmVkIGhhc2gpXG4gICAgICBjb25zdCBzcGVjSWQgPSBldGhlcnMua2VjY2FrMjU2KGV0aGVycy50b1V0ZjhCeXRlcyhpcGZzSGFzaCkpO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBpZiBzcGVjIGV4aXN0cyBhbmQgZ2V0IGl0cyBkYXRhXG4gICAgICAgIGNvbnN0IHNwZWMgPSBhd2FpdCB0aGlzLmNvbnRyYWN0LnNwZWNzKHNwZWNJZCk7XG4gICAgICAgIGNvbnN0IHF1ZXN0aW9uSWQgPSBzcGVjLnF1ZXN0aW9uSWQ7XG4gICAgICAgIFxuICAgICAgICBpZiAocXVlc3Rpb25JZCA9PT0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikge1xuICAgICAgICAgIC8vIFF1ZXN0aW9uIGRvZXNuJ3QgZXhpc3QgeWV0LCByZXR1cm4gY29udHJhY3QgbWluaW11bSBib25kIHdpdGggc2FmZXR5IG1hcmdpblxuICAgICAgICAgIGNvbnN0IGNvbnRyYWN0TWluQm9uZCA9IGF3YWl0IHRoaXMuZ2V0TWluQm9uZCgpO1xuICAgICAgICAgIGNvbnN0IHJlcXVpcmVkQm9uZCA9IEJpZ0ludChcIjIwMDAwMDAwMDAwMDAwMDAwXCIpOyAvLyBVc2UgMC4wMiBFVEggaW5zdGVhZCBvZiBjYWxjdWxhdGVkIGFtb3VudFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50Qm9uZDogQmlnSW50KDApLFxuICAgICAgICAgICAgbWluQm9uZDogY29udHJhY3RNaW5Cb25kLFxuICAgICAgICAgICAgcmVxdWlyZWROZXh0Qm9uZDogcmVxdWlyZWRCb25kLFxuICAgICAgICAgICAgaGFzQW5zd2VyczogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGJvbmQgaW5mb3JtYXRpb24gZnJvbSBSZWFsaXR5LmV0aFxuICAgICAgICBjb25zdCBjdXJyZW50Qm9uZCA9IGF3YWl0IHRoaXMucmVhbGl0eUV0aENvbnRyYWN0LmdldEJvbmQocXVlc3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IG1pbkJvbmQgPSBhd2FpdCB0aGlzLnJlYWxpdHlFdGhDb250cmFjdC5nZXRNaW5Cb25kKHF1ZXN0aW9uSWQpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaGFzQW5zd2VycyA9IGN1cnJlbnRCb25kID4gQmlnSW50KDApO1xuICAgICAgICBjb25zdCBiYXNlUmVxdWlyZWRCb25kID0gaGFzQW5zd2VycyA/IGN1cnJlbnRCb25kICogQmlnSW50KDIpIDogbWluQm9uZDtcbiAgICAgICAgLy8gQWRkIHNhZmV0eSBtYXJnaW4gZm9yIGFsbCBib25kc1xuICAgICAgICBjb25zdCByZXF1aXJlZE5leHRCb25kID0gQmlnSW50KFwiMTUwMDAwMDAwMDAwMDAwMDBcIik7IC8vIFVzZSAwLjAxNSBFVEggaW5zdGVhZCBvZiBjYWxjdWxhdGVkIGFtb3VudFxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY3VycmVudEJvbmQsXG4gICAgICAgICAgbWluQm9uZCxcbiAgICAgICAgICByZXF1aXJlZE5leHRCb25kLFxuICAgICAgICAgIGhhc0Fuc3dlcnNcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKHNwZWNFcnJvcikge1xuXG4gICAgICAgIC8vIFNwZWMgZG9lc24ndCBleGlzdCB5ZXQsIHJldHVybiBjb250cmFjdCBtaW5pbXVtIGJvbmQgd2l0aCBzYWZldHkgbWFyZ2luXG4gICAgICAgIGNvbnN0IGNvbnRyYWN0TWluQm9uZCA9IGF3YWl0IHRoaXMuZ2V0TWluQm9uZCgpO1xuICAgICAgICBjb25zdCByZXF1aXJlZEJvbmQgPSBCaWdJbnQoXCIyMDAwMDAwMDAwMDAwMDAwMFwiKTsgLy8gVXNlIDAuMDIgRVRIIGluc3RlYWQgb2YgY2FsY3VsYXRlZCBhbW91bnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjdXJyZW50Qm9uZDogQmlnSW50KDApLFxuICAgICAgICAgIG1pbkJvbmQ6IGNvbnRyYWN0TWluQm9uZCxcbiAgICAgICAgICByZXF1aXJlZE5leHRCb25kOiByZXF1aXJlZEJvbmQsXG4gICAgICAgICAgaGFzQW5zd2VyczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgYm9uZCBpbmZvOlwiLCBlcnJvcik7XG4gICAgICAvLyBGYWxsYmFjayB0byBjb250cmFjdCBtaW5pbXVtIGJvbmQgd2l0aCBzYWZldHkgbWFyZ2luXG4gICAgICBjb25zdCBjb250cmFjdE1pbkJvbmQgPSBhd2FpdCB0aGlzLmdldE1pbkJvbmQoKTtcbiAgICAgIGNvbnN0IHJlcXVpcmVkQm9uZCA9IGNvbnRyYWN0TWluQm9uZCArIChjb250cmFjdE1pbkJvbmQgLyBCaWdJbnQoMTApKTsgLy8gQWRkIDEwJSBzYWZldHkgbWFyZ2luXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50Qm9uZDogQmlnSW50KDApLFxuICAgICAgICBtaW5Cb25kOiBjb250cmFjdE1pbkJvbmQsXG4gICAgICAgIHJlcXVpcmVkTmV4dEJvbmQ6IHJlcXVpcmVkQm9uZCxcbiAgICAgICAgaGFzQW5zd2VyczogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogQ29tbWl0IHNwZWMgdXNpbmcgVjEgY29udHJhY3QgKHN0ZXAgMSBvZiBjb21taXQtcmV2ZWFsIHBhdHRlcm4pXG4gICAqL1xuICAvLyBUaGUgY29tbWl0U3BlYyBtZXRob2Qgbm8gbG9uZ2VyIHRha2VzIGFuIGluY2VudGl2ZUlkLiBJbmNlbnRpdmVzIGFyZSBjcmVhdGVkIGFoZWFkXG4gIC8vIG9mIHRpbWUgYW5kIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgd2hlbiBhIHNwZWMgaXMgYWNjZXB0ZWQuIFRoZSBmdW5jdGlvbiBzaWduYXR1cmVcbiAgLy8gYWNjZXB0cyBibG9iSGFzaCwgYm9uZEFtb3VudCwgYW4gb3B0aW9uYWwgdGFyZ2V0Q29udHJhY3QgYW5kIG9wdGlvbmFsIGNoYWluSWQuXG4gIGFzeW5jIGNvbW1pdFNwZWMoYmxvYkhhc2g6IHN0cmluZywgYm9uZEFtb3VudDogYmlnaW50LCB0YXJnZXRDb250cmFjdD86IHN0cmluZywgdGFyZ2V0Q2hhaW5JZD86IG51bWJlcik6IFByb21pc2U8e1xuICAgIGNvbW1pdG1lbnRJZDogc3RyaW5nO1xuICAgIGNvbW1pdFR4SGFzaDogc3RyaW5nO1xuICAgIHJldmVhbERlYWRsaW5lOiBudW1iZXI7XG4gICAgbm9uY2U6IG51bWJlcjtcbiAgICBjb21taXRtZW50OiBzdHJpbmc7XG4gICAgbWV0YWRhdGFIYXNoOiBzdHJpbmc7XG4gIH0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRyYWN0IHx8ICF0aGlzLnNpZ25lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkIHRvIE1ldGFNYXNrLiBQbGVhc2UgY29ubmVjdCBmaXJzdC5cIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBvbiB0aGUgU2Vwb2xpYSBuZXR3b3JrXG4gICAgICAvLyBOZXR3b3JrIGNoZWNrIHJlbW92ZWQgLSBsZXQgdXNlcnMgY29ubmVjdCBvbiBhbnkgbmV0d29ya1xuICAgICAgXG5cblxuXG4gICAgICBcbiAgICAgIC8vIEdlbmVyYXRlIGEgcHJvcGVyIG5vbmNlIGZvciB0aGUgY29tbWl0bWVudFxuICAgICAgY29uc3Qgbm9uY2UgPSBCaWdJbnQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMCkpO1xuICAgICAgXG4gICAgICAvLyBUaGUgYmxvYkhhc2ggcGFyYW1ldGVyIGlzIGFjdHVhbGx5IHRoZSBtZXRhZGF0YUhhc2ggKGhhc2ggb2YgSlNPTilcbiAgICAgIC8vIFRoaXMgaXMgYSBuYW1pbmcgaXNzdWUgLSBpdCBzaG91bGQgYmUgY2FsbGVkIG1ldGFkYXRhSGFzaFxuICAgICAgY29uc3QgbWV0YWRhdGFIYXNoID0gYmxvYkhhc2g7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSB0aGUgY29tbWl0bWVudCB1c2luZyBtZXRhZGF0YUhhc2ggYW5kIG5vbmNlIChhcyBwZXIgY29udHJhY3QpXG4gICAgICBjb25zdCBjb21taXRtZW50ID0gZXRoZXJzLmtlY2NhazI1NihcbiAgICAgICAgZXRoZXJzLnNvbGlkaXR5UGFja2VkKFtcImJ5dGVzMzJcIiwgXCJ1aW50MjU2XCJdLCBbbWV0YWRhdGFIYXNoLCBub25jZV0pXG4gICAgICApO1xuICAgICAgXG5cblxuXG5cbiAgICAgIFxuICAgICAgLy8gVGhlIFYxIGNvbnRyYWN0IHJlcXVpcmVzIHRoZSB0YXJnZXQgY29udHJhY3QgdG8gZXhpc3Qgb24gU2Vwb2xpYSAoZXh0Y29kZXNpemUgY2hlY2spXG4gICAgICAvLyBGb3IgRVJDNzczMCBzcGVjcywgd2Ugd2FudCB0byBhbGxvdyBhbnkgY29udHJhY3QgYWRkcmVzcyAoZXZlbiBmcm9tIG90aGVyIGNoYWlucylcbiAgICAgIC8vIEJ1dCBWMSBjb250cmFjdCB2YWxpZGF0ZXMgZXhpc3RlbmNlLCBzbyB3ZSBuZWVkIGEgZGVwbG95ZWQgY29udHJhY3Qgb24gU2Vwb2xpYVxuICAgICAgbGV0IHRhcmdldCA9IHRhcmdldENvbnRyYWN0O1xuICAgICAgXG4gICAgICAvLyBLbm93biB3b3JraW5nIFNlcG9saWEgY29udHJhY3RzIGZvciB0ZXN0aW5nXG4gICAgICBjb25zdCB2YWxpZFNlcG9saWFDb250cmFjdHMgPSBbXG4gICAgICAgIFJBV19DT05UUkFDVF9BRERSRVNTLCAvLyBLYWlTaWduIGl0c2VsZlxuICAgICAgICBcIjB4MWM3RDRCMTk2Q2IwQzdCMDFkNzQzRmJjNjExNmE5MDIzNzlDNzIzOFwiLCAvLyBVU0RDIG9uIFNlcG9saWFcbiAgICAgICAgXCIweDc3OTg3N0E3QjBEOUU4NjAzMTY5RGRiRDc4MzZlNDc4YjQ2MjQ3ODlcIiwgLy8gQW5vdGhlciBrbm93biBjb250cmFjdFxuICAgICAgXTtcbiAgICAgIFxuICAgICAgaWYgKCF0YXJnZXQgfHwgdGFyZ2V0LnRyaW0oKSA9PT0gXCJcIiB8fCAhdGFyZ2V0Lm1hdGNoKC9eMHhbYS1mQS1GMC05XXs0MH0kLykpIHtcbiAgICAgICAgLy8gVXNlIEthaVNpZ24gY29udHJhY3QgYXMgZGVmYXVsdCBpZiBubyB2YWxpZCB0YXJnZXQgc3BlY2lmaWVkXG4gICAgICAgIHRhcmdldCA9IFJBV19DT05UUkFDVF9BRERSRVNTO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdGFyZ2V0IGNvbnRyYWN0IGV4aXN0cyBvbiBTZXBvbGlhXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Q29kZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIhLmdldENvZGUodGFyZ2V0KTtcblxuICAgICAgICAgIGlmICh0YXJnZXRDb2RlID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBUYXJnZXQgY29udHJhY3RcIiwgdGFyZ2V0LCBcImRvZXMgbm90IGV4aXN0IG9uIFNlcG9saWFcIik7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJWMSBjb250cmFjdCByZXF1aXJlcyB0YXJnZXQgdG8gZXhpc3Qgb24gc2FtZSBuZXR3b3JrXCIpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFsbGluZyBiYWNrIHRvIEthaVNpZ24gY29udHJhY3QgYXMgdGFyZ2V0XCIpO1xuICAgICAgICAgICAgdGFyZ2V0ID0gUkFXX0NPTlRSQUNUX0FERFJFU1M7XG4gICAgICAgICAgfSBlbHNlIHtcblxuXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChjb2RlQ2hlY2tFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCB2ZXJpZnkgdGFyZ2V0IGNvbnRyYWN0IGV4aXN0ZW5jZSwgdXNpbmcgS2FpU2lnbiBjb250cmFjdCBhcyBmYWxsYmFja1wiKTtcbiAgICAgICAgICB0YXJnZXQgPSBSQVdfQ09OVFJBQ1RfQUREUkVTUztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJbmNlbnRpdmVzIGFyZSBubyBsb25nZXIgcGFzc2VkIGR1cmluZyBjb21taXQuIEFueSBpbmNlbnRpdmUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5XG4gICAgICAvLyBhc3NvY2lhdGVkIGJ5IHRoZSBjb250cmFjdCB3aGVuIGEgc3BlYyBpcyBhY2NlcHRlZC4gS2VlcCBhIHplcm8gYnl0ZXMzMiBmb3JcbiAgICAgIC8vIGNvbXBhdGliaWxpdHkgaW4gbG9ncyBpZiBuZWVkZWQuXG4gICAgICBjb25zdCBmaW5hbEluY2VudGl2ZUlkID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgbWluaW11bSBib25kIHJlcXVpcmVtZW50IHdpdGggc2FmZXR5IG1hcmdpblxuICAgICAgY29uc3QgY29udHJhY3RNaW5Cb25kID0gYXdhaXQgdGhpcy5nZXRNaW5Cb25kKCk7XG4gICAgICAvLyBBZGQgMTAlIHNhZmV0eSBtYXJnaW4gdG8gYWNjb3VudCBmb3IgcGxhdGZvcm0gZmVlcyBhbmQgcm91bmRpbmdcbiAgICAgIGNvbnN0IHJlcXVpcmVkQm9uZCA9IGNvbnRyYWN0TWluQm9uZCArIChjb250cmFjdE1pbkJvbmQgLyBCaWdJbnQoMTApKTtcbiAgICAgIFxuICAgICAgaWYgKGJvbmRBbW91bnQgPCByZXF1aXJlZEJvbmQpIHtcblxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IGJvbmQuIFJlcXVpcmVkOiAkeyhOdW1iZXIocmVxdWlyZWRCb25kKSAvIDEwKioxOCkudG9GaXhlZCg1KX0gRVRIIChpbmNsdWRpbmcgc2FmZXR5IG1hcmdpbiBmb3IgZmVlcylgKTtcbiAgICAgIH1cbiAgICAgIFxuXG5cblxuXG4gICAgICBcbiAgICAgIC8vIENSSVRJQ0FMOiBSdW4gY29tcHJlaGVuc2l2ZSBkaWFnbm9zdGljcyBCRUZPUkUgYXR0ZW1wdGluZyB0cmFuc2FjdGlvblxuICAgICAgLy8gRm9yIGNvbW1pdFNwZWMsIHdlIGRvbid0IHNlbmQgYW55IHZhbHVlLCBzbyBwYXNzIDBuIGZvciBib25kIGFtb3VudFxuICAgICAgYXdhaXQgdGhpcy5ydW5QcmVUcmFuc2FjdGlvbkRpYWdub3N0aWNzKHRhcmdldCwgMG4pO1xuICAgICAgXG4gICAgICAvLyBBZGRpdGlvbmFsIHZhbGlkYXRpb246IENoZWNrIGlmIGNvbnRyYWN0IGlzIHByb3Blcmx5IGRlcGxveWVkIGFuZCBhY2Nlc3NpYmxlXG4gICAgICB0cnkge1xuXG4gICAgICAgIGNvbnN0IGNvbnRyYWN0Q29kZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIhLmdldENvZGUoUkFXX0NPTlRSQUNUX0FERFJFU1MpO1xuXG4gICAgICAgIFxuICAgICAgICAvLyBUZXN0IGEgc2ltcGxlIHJlYWQgZnVuY3Rpb24gZmlyc3RcbiAgICAgICAgY29uc3QgdGVzdE1pbkJvbmQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0Lm1pbkJvbmQoKTtcblxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgY29udHJhY3QgaXMgcGF1c2VkIChWMSBoYXMgUGF1c2FibGUpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVHJ5IHRvIGNhbGwgdGhlIHBhdXNlZCgpIGZ1bmN0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgIGNvbnN0IHBhdXNlZENhbGwgPSBhd2FpdCB0aGlzLnByb3ZpZGVyIS5jYWxsKHtcbiAgICAgICAgICAgIHRvOiBSQVdfQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgICAgIGRhdGE6IFwiMHg1Yzk3NWFiYlwiIC8vIHBhdXNlZCgpIGZ1bmN0aW9uIHNlbGVjdG9yXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgaXNQYXVzZWQgPSBwYXVzZWRDYWxsID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMVwiO1xuXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGlzUGF1c2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250cmFjdCBpcyBjdXJyZW50bHkgcGF1c2VkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAocGF1c2VDaGVja0Vycm9yKSB7XG5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3BlY2lhbCB0ZXN0OiBDaGVjayBpZiB0aGUgdGFyZ2V0IGNvbnRyYWN0IHZhbGlkYXRpb24gaXMgdGhlIGlzc3VlXG5cblxuICAgICAgICBjb25zdCB0YXJnZXRDb250cmFjdENvZGUgPSBhd2FpdCB0aGlzLnByb3ZpZGVyIS5nZXRDb2RlKHRhcmdldCk7XG5cbiAgICAgICAgXG4gICAgICAgIGlmICh0YXJnZXRDb250cmFjdENvZGUgPT09IFwiMHhcIikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRk9VTkQgVEhFIElTU1VFOiBUYXJnZXQgY29udHJhY3QgaGFzIG5vIGNvZGUhXCIpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgY29udHJhY3QncyBleHRjb2Rlc2l6ZSBjaGVjayB3aWxsIGZhaWwgZm9yIHRoaXMgdGFyZ2V0LlwiKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhcmdldCBjb250cmFjdCAke3RhcmdldH0gZG9lcyBub3QgZXhpc3Qgb3IgaGFzIG5vIGJ5dGVjb2RlLiBUaGUgVjEgY29udHJhY3QgcmVxdWlyZXMgdGhlIHRhcmdldCBjb250cmFjdCB0byBleGlzdCBvbiBTZXBvbGlhLmApO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRyZWFzdXJ5IGFkZHJlc3MgaXMgdmFsaWQgYW5kIGNhbiByZWNlaXZlIGZ1bmRzXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBHZXQgdHJlYXN1cnkgYWRkcmVzcyBmcm9tIHRoZSBjb250cmFjdFxuICAgICAgICAgIGNvbnN0IHRyZWFzdXJ5U2VsZWN0b3IgPSBcIjB4NjFkMDI3YjNcIjsgLy8gdHJlYXN1cnkoKSBmdW5jdGlvbiBzZWxlY3RvclxuICAgICAgICAgIGNvbnN0IHRyZWFzdXJ5UmVzdWx0ID0gYXdhaXQgdGhpcy5wcm92aWRlciEuY2FsbCh7XG4gICAgICAgICAgICB0bzogUkFXX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgICAgICBkYXRhOiB0cmVhc3VyeVNlbGVjdG9yXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgdHJlYXN1cnlBZGRyZXNzID0gXCIweFwiICsgdHJlYXN1cnlSZXN1bHQuc2xpY2UoLTQwKTtcblxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIHRyZWFzdXJ5IGlzIGEgdmFsaWQgYWRkcmVzcyAobm90IHplcm8gYWRkcmVzcylcbiAgICAgICAgICBpZiAodHJlYXN1cnlBZGRyZXNzID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MIElTU1VFIEZPVU5EOiBUcmVhc3VyeSBhZGRyZXNzIGlzIHplcm8gYWRkcmVzcyFcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmVhc3VyeSBhZGRyZXNzIGlzIG5vdCBzZXQgcHJvcGVybHkgaW4gdGhlIGNvbnRyYWN0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiB0cmVhc3VyeSBjYW4gcmVjZWl2ZSBmdW5kcyAobm90IGEgY29udHJhY3QgdGhhdCBtaWdodCByZWplY3QpXG4gICAgICAgICAgY29uc3QgdHJlYXN1cnlDb2RlID0gYXdhaXQgdGhpcy5wcm92aWRlciEuZ2V0Q29kZSh0cmVhc3VyeUFkZHJlc3MpO1xuXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHRyZWFzdXJ5Q29kZS5sZW5ndGggPiAyKSB7XG5cbiAgICAgICAgICAgIC8vIFRyeSBhIHRpbnkgdGVzdCB0cmFuc2ZlciB0byBzZWUgaWYgdHJlYXN1cnkgY2FuIHJlY2VpdmUgZnVuZHNcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRlc3RBbW91bnQgPSBCaWdJbnQoMSk7IC8vIDEgd2VpXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXIhLmNhbGwoe1xuICAgICAgICAgICAgICAgIHRvOiB0cmVhc3VyeUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRlc3RBbW91bnQsXG4gICAgICAgICAgICAgICAgZnJvbTogYXdhaXQgdGhpcy5zaWduZXIuZ2V0QWRkcmVzcygpXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGNhdGNoICh0cmVhc3VyeVRlc3RFcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MIFBPU1NJQkxFIElTU1VFOiBUcmVhc3VyeSBtaWdodCByZWplY3QgZnVuZCB0cmFuc2ZlcnM6XCIsIHRyZWFzdXJ5VGVzdEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICh0cmVhc3VyeUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBjaGVjayB0cmVhc3VyeSBhZGRyZXNzOlwiLCB0cmVhc3VyeUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGNvbnRyYWN0RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNvbnRyYWN0IGFjY2Vzc2liaWxpdHkgdGVzdCBmYWlsZWQ6XCIsIGNvbnRyYWN0RXJyb3IpO1xuICAgICAgICB0aHJvdyBjb250cmFjdEVycm9yOyAvLyBSZS10aHJvdyB0aGUgc3BlY2lmaWMgZXJyb3IgaW5zdGVhZCBvZiBnZW5lcmljIG9uZVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTdGVwIDE6IENvbW1pdFxuXG5cblxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBjb21taXRtZW50IGFscmVhZHkgZXhpc3RzXG4gICAgICB0cnkge1xuXG4gICAgICAgIGNvbnN0IGNvbW1pdG1lbnRJZCA9IGV0aGVycy5rZWNjYWsyNTYoZXRoZXJzLnNvbGlkaXR5UGFja2VkKFxuICAgICAgICAgIFtcImJ5dGVzMzJcIiwgXCJhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBcInVpbnQyNTZcIl0sXG4gICAgICAgICAgW2NvbW1pdG1lbnQsIGF3YWl0IHRoaXMuc2lnbmVyLmdldEFkZHJlc3MoKSwgdGFyZ2V0LCBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKV1cbiAgICAgICAgKSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBleGlzdGluZ0NvbW1pdG1lbnQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmNvbW1pdG1lbnRzKGNvbW1pdG1lbnRJZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2hlY2tpbmcgaWYgY29tbWl0bWVudCBhbHJlYWR5IGV4aXN0czpcIiwgZXhpc3RpbmdDb21taXRtZW50LmNvbW1pdHRlciAhPT0gZXRoZXJzLlplcm9BZGRyZXNzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSBhIHN0YXRpYyBjYWxsIGZpcnN0IHRvIHNlZSBpZiBpdCB3b3VsZCBzdWNjZWVkXG4gICAgICAgIGNvbnN0IHN0YXRpY1Jlc3VsdCA9IGF3YWl0IHRoaXMuY29udHJhY3QuY29tbWl0U3BlYy5zdGF0aWNDYWxsKFxuICAgICAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHRhcmdldENoYWluSWQgfHwgMVxuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlN0YXRpYyBjYWxsIHN1Y2Nlc3NmdWwsIHByb2NlZWRpbmcgd2l0aCB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChjaGVja0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQcmUtdHJhbnNhY3Rpb24gY2hlY2tzIGZhaWxlZDpcIiwgY2hlY2tFcnJvcik7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBpdCdzIGEgcmV2ZXJ0LCB0cnkgdG8gZ2V0IG1vcmUgaW5mb1xuICAgICAgICBpZiAoY2hlY2tFcnJvci5kYXRhKSB7XG5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmUtdHJhbnNhY3Rpb24gdmFsaWRhdGlvbiBmYWlsZWQ6ICR7Y2hlY2tFcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUcnkgbWFudWFsIGdhcyBlc3RpbWF0aW9uXG4gICAgICB0cnkge1xuXG4gICAgICAgIGNvbnN0IGdhc0VzdGltYXRlID0gYXdhaXQgdGhpcy5jb250cmFjdC5jb21taXRTcGVjLmVzdGltYXRlR2FzKFxuICAgICAgICAgIGNvbW1pdG1lbnQsIFxuICAgICAgICAgIHRhcmdldCwgXG4gICAgICAgICAgdGFyZ2V0Q2hhaW5JZCB8fCAxXG4gICAgICAgICk7XG5cbiAgICAgIH0gY2F0Y2ggKGdhc0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJHYXMgZXN0aW1hdGlvbiBmYWlsZWQ6XCIsIGdhc0Vycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHYXMgZXN0aW1hdGlvbiBmYWlsZWQ6ICR7Z2FzRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgY29tbWl0VHggPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmNvbW1pdFNwZWMoY29tbWl0bWVudCwgdGFyZ2V0LCB0YXJnZXRDaGFpbklkIHx8IDEpO1xuICAgICAgXG5cbiAgICAgIGNvbnN0IGNvbW1pdFJlY2VpcHQgPSBhd2FpdCBjb21taXRUeC53YWl0KCk7XG5cbiAgICAgIFxuICAgICAgLy8gU3RlcCAyOiBFeHRyYWN0IHRoZSBhY3R1YWwgY29tbWl0bWVudCBJRCBmcm9tIHRoZSBMb2dDb21taXRTcGVjIGV2ZW50XG4gICAgICBsZXQgY29tbWl0bWVudElkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBsb2cgb2YgY29tbWl0UmVjZWlwdC5sb2dzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5jb250cmFjdC5pbnRlcmZhY2UucGFyc2VMb2cobG9nKTtcbiAgICAgICAgICBpZiAocGFyc2VkICYmIHBhcnNlZC5uYW1lID09PSAnTG9nQ29tbWl0U3BlYycpIHtcbiAgICAgICAgICAgIGNvbW1pdG1lbnRJZCA9IHBhcnNlZC5hcmdzLmNvbW1pdG1lbnRJZDtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGxvZ3MgdGhhdCBjYW4ndCBiZSBwYXJzZWQgYnkgb3VyIGludGVyZmFjZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghY29tbWl0bWVudElkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIExvZ0NvbW1pdFNwZWMgZXZlbnQgaW4gdHJhbnNhY3Rpb24gbG9nc1wiKTtcbiAgICAgIH1cbiAgICAgIFxuXG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1pdG1lbnRJZCxcbiAgICAgICAgY29tbWl0VHhIYXNoOiBjb21taXRUeC5oYXNoLFxuICAgICAgICByZXZlYWxEZWFkbGluZTogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyAzNjAwLCAvLyAxIGhvdXIgZnJvbSBub3dcbiAgICAgICAgbm9uY2U6IE51bWJlcihub25jZSksXG4gICAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAgIG1ldGFkYXRhSGFzaFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcHJvcG9zaW5nIHNwZWM6XCIsIGVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gRW5oYW5jZWQgZXJyb3IgaGFuZGxpbmcgZm9yIFYxIGNvbnRyYWN0IHNwZWNpZmljIGlzc3Vlc1xuICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKFwibWlzc2luZyByZXZlcnQgZGF0YVwiKSAmJiAhZXJyb3IuZGF0YSkge1xuXG5cblxuXG5cblxuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IGEgZGlmZmVyZW50IGFwcHJvYWNoIC0gdXNlIGEga25vd24gZ29vZCBjb250cmFjdCBhcyB0YXJnZXRcbiAgICAgICAgY29uc3Qga25vd25Hb29kQ29udHJhY3RzID0gW1xuICAgICAgICAgIFwiMHgxYzdENEIxOTZDYjBDN0IwMWQ3NDNGYmM2MTE2YTkwMjM3OUM3MjM4XCIsIC8vIFVTREMgb24gU2Vwb2xpYVxuICAgICAgICAgIFwiMHg3Nzk4NzdBN0IwRDlFODYwMzE2OURkYkQ3ODM2ZTQ3OGI0NjI0Nzg5XCIsIC8vIEFub3RoZXIga25vd24gY29udHJhY3RcbiAgICAgICAgXTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgdGVzdFRhcmdldCBvZiBrbm93bkdvb2RDb250cmFjdHMpIHtcbiAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICBjb25zdCB0ZXN0Q29kZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIhLmdldENvZGUodGVzdFRhcmdldCk7XG4gICAgICAgICAgICBpZiAodGVzdENvZGUgIT09IFwiMHhcIikge1xuXG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRpcmVjdENvbW1pdFJldmVhbChpcGZzSGFzaCwgYm9uZEFtb3VudCwgdGVzdFRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAodGVzdEVycm9yKSB7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kaXJlY3RDb21taXRSZXZlYWwoaXBmc0hhc2gsIGJvbmRBbW91bnQsIFJBV19DT05UUkFDVF9BRERSRVNTKTtcbiAgICAgICAgfSBjYXRjaCAoZGlyZWN0RXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRGlyZWN0IHRyYW5zYWN0aW9uIGFsc28gZmFpbGVkOlwiLCBkaXJlY3RFcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgd2l0aCBvcmlnaW5hbCBlcnJvciBoYW5kbGluZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFRyeSB0byBkZWNvZGUgY3VzdG9tIGVycm9yXG4gICAgICBpZiAoZXJyb3IucmVhc29uKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb250cmFjdCByZXZlcnQgcmVhc29uOlwiLCBlcnJvci5yZWFzb24pO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yLmRhdGEpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNvbnRyYWN0IGVycm9yIGRhdGE6XCIsIGVycm9yLmRhdGEpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGRlY29kZSBrbm93biBjdXN0b20gZXJyb3JzIGZyb20gdGhlIFYxIGNvbnRyYWN0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JTaWduYXR1cmVzID0ge1xuICAgICAgICAgICAgXCIweDRjYTg4ODY3XCI6IFwiQWxyZWFkeVByb3Bvc2VkKClcIixcbiAgICAgICAgICAgIFwiMHhmYjhmNDFiMlwiOiBcIk5vdFByb3Bvc2VkKClcIiwgXG4gICAgICAgICAgICBcIjB4NDdkZjhjZTBcIjogXCJJbnN1ZmZpY2llbnRCb25kKClcIixcbiAgICAgICAgICAgIFwiMHhkMmU3NGM0Y1wiOiBcIkluc3VmZmljaWVudEluY2VudGl2ZSgpXCIsXG4gICAgICAgICAgICBcIjB4NmVmYzcyNjFcIjogXCJJbnZhbGlkQ29udHJhY3QoKVwiLFxuICAgICAgICAgICAgXCIweGVkNTkyNjI0XCI6IFwiQ29udHJhY3ROb3RGb3VuZCgpXCIsXG4gICAgICAgICAgICBcIjB4NWZkOWE2ZGVcIjogXCJJbnZhbGlkSVBGUygpXCIsXG4gICAgICAgICAgICBcIjB4MDk4MmU5YjVcIjogXCJDb21taXRtZW50Tm90Rm91bmQoKVwiLFxuICAgICAgICAgICAgXCIweDZlOWFkMGIzXCI6IFwiQ29tbWl0bWVudEV4cGlyZWQoKVwiLFxuICAgICAgICAgICAgXCIweDQyMjFkOWRjXCI6IFwiQ29tbWl0bWVudEFscmVhZHlSZXZlYWxlZCgpXCIsXG4gICAgICAgICAgICBcIjB4OGJhYTU3OWZcIjogXCJJbnZhbGlkUmV2ZWFsKClcIixcbiAgICAgICAgICAgIFwiMHhmMWEyYjYyYVwiOiBcIk5vdEZpbmFsaXplZCgpXCIsXG4gICAgICAgICAgICBcIjB4OWNmOGUxMWZcIjogXCJBbHJlYWR5U2V0dGxlZCgpXCIsXG4gICAgICAgICAgICBcIjB4YTc2NDhjMTlcIjogXCJOb0luY2VudGl2ZVRvQ2xhaW0oKVwiLFxuICAgICAgICAgICAgXCIweGMzZTJhOGIxXCI6IFwiSW5jZW50aXZlRXhwaXJlZCgpXCIsXG4gICAgICAgICAgICBcIjB4ODJiNDI5MDBcIjogXCJVbmF1dGhvcml6ZWQoKVwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBlcnJvclNlbGVjdG9yID0gZXJyb3IuZGF0YS5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgY29uc3QgY3VzdG9tRXJyb3IgPSBlcnJvclNpZ25hdHVyZXNbZXJyb3JTZWxlY3RvciBhcyBrZXlvZiB0eXBlb2YgZXJyb3JTaWduYXR1cmVzXTtcbiAgICAgICAgICBpZiAoY3VzdG9tRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udHJhY3QgcmV2ZXJ0ZWQgd2l0aDogJHtjdXN0b21FcnJvcn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGRlY29kZUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBkZWNvZGUgZXJyb3I6XCIsIGRlY29kZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiB3ZSBjYW4ndCBkZWNvZGUgaXQsIGNoZWNrIGZvciBjb21tb24gaXNzdWVzXG4gICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIikgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoXCJJbnN1ZmZpY2llbnRCb25kXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluc3VmZmljaWVudCBib25kIGFtb3VudC4gUGxlYXNlIGNoZWNrIHRoZSBtaW5pbXVtIGJvbmQgcmVxdWlyZW1lbnQuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKFwiQ29udHJhY3ROb3RGb3VuZFwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB0YXJnZXQgY29udHJhY3QgJHt0YXJnZXRDb250cmFjdCB8fCAnc3BlY2lmaWVkJ30gZG9lcyBub3QgZXhpc3Qgb24gU2Vwb2xpYSB0ZXN0bmV0LiBUaGUgVjEgY29udHJhY3QgcmVxdWlyZXMgdGFyZ2V0IGNvbnRyYWN0cyB0byBiZSBkZXBsb3llZCBvbiB0aGUgc2FtZSBuZXR3b3JrLiBQbGVhc2UgdXNlIGEgdmFsaWQgU2Vwb2xpYSBjb250cmFjdCBhZGRyZXNzIG9yIGxlYXZlIGVtcHR5IGZvciBnZW5lcmFsIHNwZWNpZmljYXRpb25zLmApO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKFwiSW52YWxpZENvbnRyYWN0XCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGFyZ2V0IGNvbnRyYWN0IGFkZHJlc3MgZm9ybWF0LlwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldmVhbCBzcGVjIHVzaW5nIFYxIGNvbnRyYWN0IChzdGVwIDIgb2YgY29tbWl0LXJldmVhbCBwYXR0ZXJuKVxuICAgKi9cbiAgYXN5bmMgcmV2ZWFsU3BlYyhjb21taXRtZW50SWQ6IHN0cmluZywgYmxvYkhhc2g6IHN0cmluZywgbWV0YWRhdGFIYXNoOiBzdHJpbmcsIG5vbmNlOiBudW1iZXIsIGJvbmRBbW91bnQ6IGJpZ2ludCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5jb250cmFjdCB8fCAhdGhpcy5zaWduZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbm5lY3RlZCB0byBNZXRhTWFzay4gUGxlYXNlIGNvbm5lY3QgZmlyc3QuXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcInJldmVhbFNwZWMgY2FsbGVkIHdpdGg6XCIsIHtcbiAgICAgICAgY29tbWl0bWVudElkLFxuICAgICAgICBibG9iSGFzaCxcbiAgICAgICAgbWV0YWRhdGFIYXNoLFxuICAgICAgICBub25jZSxcbiAgICAgICAgYm9uZEFtb3VudDogYm9uZEFtb3VudC50b1N0cmluZygpXG4gICAgICB9KTtcblxuICAgICAgLy8gRGVidWc6IENoZWNrIHdoYXQgdGhlIGNvbnRyYWN0IGhhcyBzdG9yZWQgZm9yIHRoaXMgY29tbWl0bWVudFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RvcmVkQ29tbWl0bWVudCA9IGF3YWl0IHRoaXMuY29udHJhY3QuY29tbWl0bWVudHMoY29tbWl0bWVudElkKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJTdG9yZWQgY29tbWl0bWVudCBkYXRhOlwiLCB7XG4gICAgICAgICAgY29tbWl0dGVyOiBzdG9yZWRDb21taXRtZW50WzBdLFxuICAgICAgICAgIGNvbW1pdFRpbWVzdGFtcDogc3RvcmVkQ29tbWl0bWVudFsxXS50b1N0cmluZygpLFxuICAgICAgICAgIHJlc2VydmVkMTogc3RvcmVkQ29tbWl0bWVudFsyXS50b1N0cmluZygpLFxuICAgICAgICAgIHRhcmdldENvbnRyYWN0OiBzdG9yZWRDb21taXRtZW50WzNdLFxuICAgICAgICAgIGlzUmV2ZWFsZWQ6IHN0b3JlZENvbW1pdG1lbnRbNF0sXG4gICAgICAgICAgYm9uZEFtb3VudDogc3RvcmVkQ29tbWl0bWVudFs1XS50b1N0cmluZygpLFxuICAgICAgICAgIHJlc2VydmVkOiBzdG9yZWRDb21taXRtZW50WzZdLnRvU3RyaW5nKCksXG4gICAgICAgICAgcmV2ZWFsRGVhZGxpbmU6IHN0b3JlZENvbW1pdG1lbnRbN10udG9TdHJpbmcoKSxcbiAgICAgICAgICBjaGFpbklkOiBzdG9yZWRDb21taXRtZW50WzhdLnRvU3RyaW5nKCksXG4gICAgICAgICAgaW5jZW50aXZlSWQ6IHN0b3JlZENvbW1pdG1lbnRbOV1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSB0aGUgcmlnaHQgY29tbWl0dGVyXG4gICAgICAgIGNvbnN0IG91ckFkZHJlc3MgPSBhd2FpdCB0aGlzLnNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT3VyIGFkZHJlc3M6XCIsIG91ckFkZHJlc3MpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNvbW1pdHRlciBhZGRyZXNzOlwiLCBzdG9yZWRDb21taXRtZW50WzBdKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGNvbW1pdG1lbnQgZXhwaXJlZFxuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICBjb25zdCByZXZlYWxEZWFkbGluZSA9IE51bWJlcihzdG9yZWRDb21taXRtZW50WzddKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJDdXJyZW50IHRpbWU6XCIsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJSZXZlYWwgZGVhZGxpbmU6XCIsIHJldmVhbERlYWRsaW5lKTtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lID4gcmV2ZWFsRGVhZGxpbmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21taXRtZW50IGhhcyBleHBpcmVkLiBQbGVhc2UgY3JlYXRlIGEgbmV3IGNvbW1pdG1lbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBMZXQncyB2ZXJpZnkgd2hhdCBjb21taXRtZW50IHRoZSBjb250cmFjdCBleHBlY3RzXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ29tbWl0bWVudCA9IGV0aGVycy5rZWNjYWsyNTYoXG4gICAgICAgICAgZXRoZXJzLnNvbGlkaXR5UGFja2VkKFtcImJ5dGVzMzJcIiwgXCJ1aW50MjU2XCJdLCBbbWV0YWRhdGFIYXNoLCBCaWdJbnQobm9uY2UpXSlcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJFeHBlY3RlZCBjb21taXRtZW50IGhhc2g6XCIsIGV4cGVjdGVkQ29tbWl0bWVudCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgY29tbWl0bWVudCBJRCBhcyB0aGUgY29udHJhY3Qgd291bGRcbiAgICAgICAgY29uc3QgcmVjb25zdHJ1Y3RlZENvbW1pdG1lbnRJZCA9IGV0aGVycy5rZWNjYWsyNTYoXG4gICAgICAgICAgZXRoZXJzLnNvbGlkaXR5UGFja2VkKFxuICAgICAgICAgICAgW1wiYnl0ZXMzMlwiLCBcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIFwidWludDI1NlwiLCBcInVpbnQ2NFwiXSxcbiAgICAgICAgICAgIFtleHBlY3RlZENvbW1pdG1lbnQsIHN0b3JlZENvbW1pdG1lbnRbMF0sIHN0b3JlZENvbW1pdG1lbnRbM10sIHN0b3JlZENvbW1pdG1lbnRbOF0sIHN0b3JlZENvbW1pdG1lbnRbMV1dXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJlY29uc3RydWN0ZWQgY29tbWl0bWVudCBJRDpcIiwgcmVjb25zdHJ1Y3RlZENvbW1pdG1lbnRJZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUHJvdmlkZWQgY29tbWl0bWVudCBJRDpcIiwgY29tbWl0bWVudElkKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJEbyB0aGV5IG1hdGNoP1wiLCByZWNvbnN0cnVjdGVkQ29tbWl0bWVudElkID09PSBjb21taXRtZW50SWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlY29uc3RydWN0ZWRDb21taXRtZW50SWQgIT09IGNvbW1pdG1lbnRJZCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb21taXRtZW50IElEIG1pc21hdGNoISBUaGUgbm9uY2Ugb3IgbWV0YWRhdGEgaGFzaCBkb2Vzbid0IG1hdGNoIHdoYXQgd2FzIHVzZWQgZHVyaW5nIGNvbW1pdC5cIik7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJUaGlzIGNvbW1pdG1lbnQgd2FzIGNyZWF0ZWQgd2l0aCBhIGRpZmZlcmVudCBub25jZSBvciBtZXRhZGF0YSBoYXNoLlwiKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlBsZWFzZSBlbnN1cmUgeW91J3JlIHVzaW5nIHRoZSBleGFjdCBzYW1lIG5vbmNlIHRoYXQgd2FzIHJldHVybmVkIGR1cmluZyBjb21taXQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZGVidWdFcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkRlYnVnIGVycm9yIChub24tY3JpdGljYWwpOlwiLCBkZWJ1Z0Vycm9yKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJ5IGEgc3RhdGljIGNhbGwgZmlyc3QgdG8gc2VlIHdoYXQgZXhhY3RseSBmYWlsc1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb250cmFjdC5yZXZlYWxTcGVjLnN0YXRpY0NhbGwoY29tbWl0bWVudElkLCBibG9iSGFzaCwgbWV0YWRhdGFIYXNoLCBCaWdJbnQobm9uY2UpLCB7IHZhbHVlOiBib25kQW1vdW50IH0pO1xuXG4gICAgICB9IGNhdGNoIChzdGF0aWNFcnJvcjogYW55KSB7XG5cblxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXZlYWxUeCA9IGF3YWl0IHRoaXMuY29udHJhY3QucmV2ZWFsU3BlYyhjb21taXRtZW50SWQsIGJsb2JIYXNoLCBtZXRhZGF0YUhhc2gsIEJpZ0ludChub25jZSksIHsgdmFsdWU6IGJvbmRBbW91bnQgfSk7XG5cbiAgICAgIGNvbnN0IHJldmVhbFJlY2VpcHQgPSBhd2FpdCByZXZlYWxUeC53YWl0KCk7XG5cblxuICAgICAgcmV0dXJuIHJldmVhbFR4Lmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJldmVhbGluZyBzcGVjOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJldmVhbCBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlIHN1Ym1pdCBmbG93IChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgICovXG4gIGFzeW5jIHN1Ym1pdFNwZWMoYmxvYkhhc2g6IHN0cmluZywgYm9uZEFtb3VudDogYmlnaW50LCB0YXJnZXRDb250cmFjdD86IHN0cmluZywgdGFyZ2V0Q2hhaW5JZD86IG51bWJlcik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgLy8gVGhlIHN1Ym1pdFNwZWMgY29udmVuaWVuY2UgbWV0aG9kIGNvbW1pdHMgdGhlbiBpbW1lZGlhdGVseSByZXZlYWxzIHRoZSBzcGVjLlxuICAgIC8vIEluY2VudGl2ZXMgYXJlIG5vIGxvbmdlciBwYXNzZWQgYXMgcGFydCBvZiBjb21taXQuXG4gICAgY29uc3QgY29tbWl0UmVzdWx0ID0gYXdhaXQgdGhpcy5jb21taXRTcGVjKGJsb2JIYXNoLCBib25kQW1vdW50LCB0YXJnZXRDb250cmFjdCwgdGFyZ2V0Q2hhaW5JZCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmV2ZWFsU3BlYyhjb21taXRSZXN1bHQuY29tbWl0bWVudElkLCBibG9iSGFzaCwgY29tbWl0UmVzdWx0Lm1ldGFkYXRhSGFzaCwgY29tbWl0UmVzdWx0Lm5vbmNlLCBib25kQW1vdW50KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgcXVlc3Rpb25JZCBmcm9tIHRoZSBjb250cmFjdCBmb3IgYSBnaXZlbiBJUEZTIGhhc2hcbiAgICogSW4gVjEsIHdlIG5lZWQgdG8gZmluZCB0aGUgc3BlY0lEIGZpcnN0LCB0aGVuIGdldCB0aGUgcXVlc3Rpb25JZCBmcm9tIHRoZSBzcGVjXG4gICAqL1xuICBhc3luYyBnZXRRdWVzdGlvbklkKGlwZnNIYXNoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuY29udHJhY3QgfHwgIXRoaXMuc2lnbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWQgdG8gTWV0YU1hc2suIFBsZWFzZSBjb25uZWN0IGZpcnN0LlwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gR2VuZXJhdGUgc3BlY0lEIGZyb20gdGhlIGJsb2IgdmVyc2lvbmVkIGhhc2hcbiAgICAgIGNvbnN0IHNwZWNJZCA9IGV0aGVycy5rZWNjYWsyNTYoZXRoZXJzLnRvVXRmOEJ5dGVzKGlwZnNIYXNoKSk7XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgc3BlYyBkYXRhXG4gICAgICBjb25zdCBzcGVjID0gYXdhaXQgdGhpcy5jb250cmFjdC5zcGVjcyhzcGVjSWQpO1xuXG4gICAgICBcbiAgICAgIGNvbnN0IHF1ZXN0aW9uSWQgPSBzcGVjLnF1ZXN0aW9uSWQ7XG5cbiAgICAgIHJldHVybiBxdWVzdGlvbklkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBxdWVzdGlvbklkOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHN0YXR1cyBvZiBhIHNwZWNpZmljYXRpb24gZnJvbSB0aGUgY29udHJhY3RcbiAgICogUmV0dXJuczogMCA9IFN1Ym1pdHRlZCwgMSA9IEFjY2VwdGVkLCAyID0gUmVqZWN0ZWRcbiAgICovXG4gIGFzeW5jIGdldFNwZWNTdGF0dXMoaXBmc0hhc2g6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5jb250cmFjdCB8fCAhdGhpcy5zaWduZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbm5lY3RlZCB0byBNZXRhTWFzay4gUGxlYXNlIGNvbm5lY3QgZmlyc3QuXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBXZSBrbm93IGNvbnRyYWN0IGlzIG5vdCBudWxsIGhlcmVcbiAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMuY29udHJhY3QuZ2V0U3RhdHVzKGlwZnNIYXNoKTtcblxuICAgICAgcmV0dXJuIE51bWJlcihzdGF0dXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBzcGVjIHN0YXR1czpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc3BlY2lmaWNhdGlvbiBpcyBhY2NlcHRlZFxuICAgKi9cbiAgYXN5bmMgaXNTcGVjQWNjZXB0ZWQoaXBmc0hhc2g6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuY29udHJhY3QgfHwgIXRoaXMuc2lnbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWQgdG8gTWV0YU1hc2suIFBsZWFzZSBjb25uZWN0IGZpcnN0LlwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gV2Uga25vdyBjb250cmFjdCBpcyBub3QgbnVsbCBoZXJlXG4gICAgICBjb25zdCBpc0FjY2VwdGVkID0gYXdhaXQgdGhpcy5jb250cmFjdC5pc0FjY2VwdGVkKGlwZnNIYXNoKTtcblxuICAgICAgcmV0dXJuIGlzQWNjZXB0ZWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjaGVja2luZyBpZiBzcGVjIGlzIGFjY2VwdGVkOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHRoZSByZXN1bHQgb2YgYSBSZWFsaXR5LmV0aCBxdWVzdGlvbiBieSBjYWxsaW5nIHRoZSBjb250cmFjdCdzIGhhbmRsZVJlc3VsdCBmdW5jdGlvblxuICAgKi9cbiAgYXN5bmMgaGFuZGxlUmVzdWx0KGlwZnNIYXNoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuY29udHJhY3QgfHwgIXRoaXMuc2lnbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWQgdG8gTWV0YU1hc2suIFBsZWFzZSBjb25uZWN0IGZpcnN0LlwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG9uIHRoZSBTZXBvbGlhIG5ldHdvcmtcbiAgICAgIC8vIE5ldHdvcmsgY2hlY2sgcmVtb3ZlZCAtIGxldCB1c2VycyBjb25uZWN0IG9uIGFueSBuZXR3b3JrXG4gICAgICBcblxuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSBzcGVjSUQgZnJvbSBJUEZTIGhhc2hcbiAgICAgIGNvbnN0IHNwZWNJZCA9IGV0aGVycy5rZWNjYWsyNTYoZXRoZXJzLnRvVXRmOEJ5dGVzKGlwZnNIYXNoKSk7XG4gICAgICBcbiAgICAgIC8vIFdlIGtub3cgY29udHJhY3QgaXMgbm90IG51bGwgaGVyZVxuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmhhbmRsZVJlc3VsdChzcGVjSWQpO1xuXG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zYWN0aW9uIHRvIGJlIGNvbmZpcm1lZFxuICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcblxuICAgICAgXG4gICAgICByZXR1cm4gdHguaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGhhbmRsaW5nIHJlc3VsdDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgSVBGUyBoYXNoIGZyb20gdGhlIGNvbnRyYWN0IGZvciBhIGdpdmVuIHNwZWNJRFxuICAgKi9cbiAgYXN5bmMgZ2V0SVBGU0J5SGFzaChzcGVjSUQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5jb250cmFjdCB8fCAhdGhpcy5zaWduZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbm5lY3RlZCB0byBNZXRhTWFzay4gUGxlYXNlIGNvbm5lY3QgZmlyc3QuXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJbiBWMSwgZ2V0IHRoZSBzcGVjIGRhdGEgYW5kIGV4dHJhY3QgSVBGU1xuICAgICAgY29uc3Qgc3BlYyA9IGF3YWl0IHRoaXMuY29udHJhY3Quc3BlY3Moc3BlY0lEKTtcbiAgICAgIGNvbnN0IGlwZnNIYXNoID0gc3BlYy5pcGZzO1xuXG4gICAgICByZXR1cm4gaXBmc0hhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIElQRlMgaGFzaDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbmNlbnRpdmUgZm9yIGEgdGFyZ2V0IGNvbnRyYWN0IChWMSBmZWF0dXJlKVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlSW5jZW50aXZlKFxuICAgIHRhcmdldENvbnRyYWN0OiBzdHJpbmcsXG4gICAgdGFyZ2V0Q2hhaW5JZDogbnVtYmVyLFxuICAgIGFtb3VudDogYmlnaW50LFxuICAgIGR1cmF0aW9uOiBiaWdpbnQsXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuY29udHJhY3QgfHwgIXRoaXMuc2lnbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWQgdG8gTWV0YU1hc2suIFBsZWFzZSBjb25uZWN0IGZpcnN0LlwiKTtcbiAgICAgIH1cblxuXG5cblxuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmNyZWF0ZUluY2VudGl2ZShcbiAgICAgICAgdGFyZ2V0Q29udHJhY3QsXG4gICAgICAgIHRhcmdldENoYWluSWQsXG4gICAgICAgIGFtb3VudCxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB7IHZhbHVlOiBhbW91bnQgfVxuICAgICAgKTtcblxuXG4gICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xuXG5cbiAgICAgIHJldHVybiB0eC5oYXNoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY3JlYXRpbmcgaW5jZW50aXZlOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNwZWNzIGJ5IGNvbnRyYWN0IGFkZHJlc3MgKFYxIGZlYXR1cmUpXG4gICAqL1xuICBhc3luYyBnZXRTcGVjc0J5Q29udHJhY3QoY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsIGNoYWluSWQ6IG51bWJlciA9IDExMTU1MTExKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuY29udHJhY3QgfHwgIXRoaXMuc2lnbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWQgdG8gTWV0YU1hc2suIFBsZWFzZSBjb25uZWN0IGZpcnN0LlwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3BlY0lkcyA9IGF3YWl0IHRoaXMuY29udHJhY3QuZ2V0U3BlY3NCeUNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgY2hhaW5JZCk7XG5cbiAgICAgIHJldHVybiBzcGVjSWRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBzcGVjcyBieSBjb250cmFjdDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBBTEwgc3BlY3MgZm9yIGEgdXNlciBieSBxdWVyeWluZyBTcGVjUmV2ZWFsZWQgZXZlbnRzXG4gICAqL1xuICBhc3luYyBnZXRBbGxVc2VyU3BlY3NCeUV2ZW50cyh1c2VyQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuY29udHJhY3QgfHwgIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbm5lY3RlZCB0byBNZXRhTWFzay4gUGxlYXNlIGNvbm5lY3QgZmlyc3QuXCIpO1xuICAgICAgfVxuXG5cbiAgICAgIFxuICAgICAgLy8gR2V0IHJlY2VudCBibG9ja3MgdG8gc2VhcmNoIGZvciBldmVudHNcbiAgICAgIGNvbnN0IGN1cnJlbnRCbG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgIGNvbnN0IGZyb21CbG9jayA9IE1hdGgubWF4KDAsIGN1cnJlbnRCbG9jayAtIDUwMDAwKTsgLy8gTGFzdCB+NyBkYXlzIG9uIG1haW5uZXRcbiAgICAgIFxuXG4gICAgICBcbiAgICAgIC8vIFF1ZXJ5IFNwZWNSZXZlYWxlZCBldmVudHMgZm9yIHRoaXMgdXNlclxuICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy5jb250cmFjdC5maWx0ZXJzLlNwZWNSZXZlYWxlZChudWxsLCB1c2VyQWRkcmVzcywgbnVsbCk7XG4gICAgICBjb25zdCBldmVudHMgPSBhd2FpdCB0aGlzLmNvbnRyYWN0LnF1ZXJ5RmlsdGVyKGZpbHRlciwgZnJvbUJsb2NrLCBjdXJyZW50QmxvY2spO1xuICAgICAgXG5cbiAgICAgIFxuICAgICAgY29uc3QgdXNlclNwZWNzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgaWYgKGV2ZW50LmFyZ3MgJiYgZXZlbnQuYXJncy5zcGVjSWQpIHtcbiAgICAgICAgICBjb25zdCBzcGVjSWQgPSBldmVudC5hcmdzLnNwZWNJZDtcblxuICAgICAgICAgIHVzZXJTcGVjcy5wdXNoKHNwZWNJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWxzbyBjaGVjayBMb2dSZXZlYWxTcGVjIGV2ZW50cyAob2xkZXIgZm9ybWF0KVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbG9nUmV2ZWFsRmlsdGVyID0gdGhpcy5jb250cmFjdC5maWx0ZXJzLkxvZ1JldmVhbFNwZWModXNlckFkZHJlc3MsIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICBjb25zdCBsb2dSZXZlYWxFdmVudHMgPSBhd2FpdCB0aGlzLmNvbnRyYWN0LnF1ZXJ5RmlsdGVyKGxvZ1JldmVhbEZpbHRlciwgZnJvbUJsb2NrLCBjdXJyZW50QmxvY2spO1xuICAgICAgICBcblxuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBsb2dSZXZlYWxFdmVudHMpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuYXJncyAmJiBldmVudC5hcmdzLnNwZWNJRCkge1xuICAgICAgICAgICAgY29uc3Qgc3BlY0lkID0gZXZlbnQuYXJncy5zcGVjSUQ7XG5cbiAgICAgICAgICAgIGlmICghdXNlclNwZWNzLmluY2x1ZGVzKHNwZWNJZCkpIHtcbiAgICAgICAgICAgICAgdXNlclNwZWNzLnB1c2goc3BlY0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGxvZ0Vycm9yKSB7XG5cbiAgICAgIH1cbiAgICAgIFxuXG4gICAgICByZXR1cm4gdXNlclNwZWNzO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIHVzZXIgc3BlY3MgYnkgZXZlbnRzOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbnRyYWN0IHNwZWMgY291bnQgKFYxIGZlYXR1cmUpXG4gICAqL1xuICBhc3luYyBnZXRDb250cmFjdFNwZWNDb3VudChjb250cmFjdEFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5jb250cmFjdCB8fCAhdGhpcy5zaWduZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbm5lY3RlZCB0byBNZXRhTWFzay4gUGxlYXNlIGNvbm5lY3QgZmlyc3QuXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb3VudCA9IGF3YWl0IHRoaXMuY29udHJhY3QuZ2V0Q29udHJhY3RTcGVjQ291bnQoY29udHJhY3RBZGRyZXNzKTtcblxuICAgICAgcmV0dXJuIE51bWJlcihjb3VudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIGNvbnRyYWN0IHNwZWMgY291bnQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIERpYWdub3N0aWMgZnVuY3Rpb25zIHJlbW92ZWQgdG8gY2xlYW4gdXAgY29uc29sZSBvdXRwdXRcblxuICAvKipcbiAgICogRGlyZWN0IGNvbW1pdC1yZXZlYWwgaW1wbGVtZW50YXRpb24gZm9yIHRyb3VibGVzaG9vdGluZ1xuICAgKi9cbiAgYXN5bmMgZGlyZWN0Q29tbWl0UmV2ZWFsKGlwZnNIYXNoOiBzdHJpbmcsIGJvbmRBbW91bnQ6IGJpZ2ludCwgdGFyZ2V0Q29udHJhY3Q6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5zaWduZXIgfHwgIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbm5lY3RlZCB0byBNZXRhTWFzay4gUGxlYXNlIGNvbm5lY3QgZmlyc3QuXCIpO1xuICAgICAgfVxuXG5cbiAgICAgIFxuICAgICAgY29uc3Qgbm9uY2UgPSBCaWdJbnQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMCkpO1xuICAgICAgY29uc3QgY29tbWl0bWVudCA9IGV0aGVycy5rZWNjYWsyNTYoZXRoZXJzLnNvbGlkaXR5UGFja2VkKFtcInN0cmluZ1wiLCBcInVpbnQyNTZcIl0sIFtpcGZzSGFzaCwgbm9uY2VdKSk7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRDb250cmFjdCB8fCBSQVdfQ09OVFJBQ1RfQUREUkVTUztcbiAgICAgIC8vIERldGVybWluZSB0aGUgY2hhaW5JZCBmcm9tIHRoZSBwcm92aWRlcidzIG5ldHdvcms7IGZhbGxiYWNrIHRvIDEgKFNlcG9saWEpXG4gICAgICBsZXQgbmV0d29ya0NoYWluSWQgPSAxO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICBuZXR3b3JrQ2hhaW5JZCA9IE51bWJlcihuZXR3b3JrLmNoYWluSWQpO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICBuZXR3b3JrQ2hhaW5JZCA9IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hbnVhbGx5IGVuY29kZSB0aGUgZnVuY3Rpb24gY2FsbCBmb3IgY29tbWl0U3BlYyhieXRlczMyLGFkZHJlc3MsdWludDI1NilcbiAgICAgIGNvbnN0IGZ1bmN0aW9uU2VsZWN0b3IgPSBldGhlcnMuaWQoXCJjb21taXRTcGVjKGJ5dGVzMzIsYWRkcmVzcyx1aW50MjU2KVwiKS5zbGljZSgwLCAxMCk7XG4gICAgICBjb25zdCBlbmNvZGVkUGFyYW1zID0gZXRoZXJzLmNvbmNhdChbXG4gICAgICAgIGV0aGVycy56ZXJvUGFkVmFsdWUoY29tbWl0bWVudCwgMzIpLFxuICAgICAgICBldGhlcnMuemVyb1BhZFZhbHVlKHRhcmdldCwgMzIpLFxuICAgICAgICBldGhlcnMuemVyb1BhZFZhbHVlKGV0aGVycy50b0JlSGV4KG5ldHdvcmtDaGFpbklkKSwgMzIpXG4gICAgICBdKTtcblxuICAgICAgY29uc3QgdHhEYXRhID0gZXRoZXJzLmNvbmNhdChbZnVuY3Rpb25TZWxlY3RvciwgZW5jb2RlZFBhcmFtc10pO1xuICAgICAgXG5cblxuXG5cblxuICAgICAgXG4gICAgICAvLyBTZW5kIHRoZSB0cmFuc2FjdGlvbiBkaXJlY3RseVxuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICB0bzogUkFXX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgIGRhdGE6IHR4RGF0YSxcbiAgICAgICAgdmFsdWU6IGJvbmRBbW91bnQsXG4gICAgICAgIGdhc0xpbWl0OiA1MDAwMDAgLy8gU2V0IGEgcmVhc29uYWJsZSBnYXMgbGltaXRcbiAgICAgIH0pO1xuICAgICAgXG5cbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgY29uZmlybWF0aW9uICBcbiAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG5cbiAgICAgIFxuICAgICAgaWYgKHJlY2VpcHQuc3RhdHVzID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgVHJhbnNhY3Rpb24gcmV2ZXJ0ZWQgd2l0aCBzdGF0dXMgMFwiKTtcblxuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGdldCB0aGUgcmV2ZXJ0IHJlYXNvbiB1c2luZyBldGhfY2FsbCB3aXRoIHRoZSBzYW1lIHRyYW5zYWN0aW9uIGRhdGEgYXQgdGhlIGJsb2NrIGJlZm9yZVxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgIHRvOiBSQVdfQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgICAgIGRhdGE6IHR4RGF0YSxcbiAgICAgICAgICAgIHZhbHVlOiBib25kQW1vdW50LFxuICAgICAgICAgICAgZnJvbTogYXdhaXQgdGhpcy5zaWduZXIuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgYmxvY2tUYWc6IHJlY2VpcHQuYmxvY2tOdW1iZXIgLSAxXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBjYXRjaCAoY2FsbEVycm9yOiBhbnkpIHtcblxuICAgICAgICAgIGlmIChjYWxsRXJyb3IuZGF0YSkge1xuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBlcnJvciBzaWduYXR1cmVzIGR5bmFtaWNhbGx5IHRvIGVuc3VyZSBhY2N1cmFjeVxuICAgICAgICAgICAgY29uc3QgZXJyb3JNYXBwaW5ncyA9IFtcbiAgICAgICAgICAgICAgXCJBbHJlYWR5UHJvcG9zZWQoKVwiLFxuICAgICAgICAgICAgICBcIk5vdFByb3Bvc2VkKClcIixcbiAgICAgICAgICAgICAgXCJJbnN1ZmZpY2llbnRCb25kKClcIixcbiAgICAgICAgICAgICAgXCJJbnN1ZmZpY2llbnRJbmNlbnRpdmUoKVwiLFxuICAgICAgICAgICAgICBcIkludmFsaWRDb250cmFjdCgpXCIsXG4gICAgICAgICAgICAgIFwiQ29udHJhY3ROb3RGb3VuZCgpXCIsXG4gICAgICAgICAgICAgIFwiSW52YWxpZElQRlMoKVwiLFxuICAgICAgICAgICAgICBcIkNvbW1pdG1lbnROb3RGb3VuZCgpXCIsXG4gICAgICAgICAgICAgIFwiQ29tbWl0bWVudEV4cGlyZWQoKVwiLFxuICAgICAgICAgICAgICBcIkNvbW1pdG1lbnRBbHJlYWR5UmV2ZWFsZWQoKVwiLFxuICAgICAgICAgICAgICBcIkludmFsaWRSZXZlYWwoKVwiLFxuICAgICAgICAgICAgICBcIk5vdEZpbmFsaXplZCgpXCIsXG4gICAgICAgICAgICAgIFwiQWxyZWFkeVNldHRsZWQoKVwiLFxuICAgICAgICAgICAgICBcIk5vSW5jZW50aXZlVG9DbGFpbSgpXCIsXG4gICAgICAgICAgICAgIFwiSW5jZW50aXZlRXhwaXJlZCgpXCIsXG4gICAgICAgICAgICAgIFwiVW5hdXRob3JpemVkKClcIlxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZXJyb3JTaWduYXR1cmVzID0ge307XG4gICAgICAgICAgICBlcnJvck1hcHBpbmdzLmZvckVhY2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGV0aGVycy5pZChlcnJvcikuc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgICBlcnJvclNpZ25hdHVyZXNbc2VsZWN0b3JdID0gZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIGdlbmVyaWMgZXJyb3JcbiAgICAgICAgICAgIGVycm9yU2lnbmF0dXJlc1tcIjB4MDhjMzc5YTBcIl0gPSBcIkVycm9yKHN0cmluZylcIjtcbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gY2FsbEVycm9yLmRhdGEuc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgaWYgKGVycm9yU2lnbmF0dXJlc1tzZWxlY3Rvcl0pIHtcblxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUHJvdmlkZSBzcGVjaWZpYyBndWlkYW5jZVxuICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IFwiMHhlZDU5MjYyNFwiKSB7XG5cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RvciA9PT0gXCIweDQ3ZGY4Y2UwXCIpIHtcblxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdG9yID09PSBcIjB4ODJiNDI5MDBcIikge1xuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udHJhY3QgcmV2ZXJ0ZWQgd2l0aDogJHtlcnJvclNpZ25hdHVyZXNbc2VsZWN0b3JdfWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gd2FzIG1pbmVkIGJ1dCByZXZlcnRlZC4gQ2hlY2sgY29uc29sZSBsb2dzIGZvciBkZXRhaWxzLlwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHR4Lmhhc2g7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBEaXJlY3QgdHJhbnNhY3Rpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUnVuIGNvbXByZWhlbnNpdmUgZGlhZ25vc3RpY3MgYmVmb3JlIGF0dGVtcHRpbmcgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgcnVuUHJlVHJhbnNhY3Rpb25EaWFnbm9zdGljcyh0YXJnZXRDb250cmFjdDogc3RyaW5nLCBib25kQW1vdW50OiBiaWdpbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRyYWN0IHx8ICF0aGlzLnNpZ25lciB8fCAhdGhpcy5wcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkXCIpO1xuICAgICAgfVxuXG5cbiAgICAgIGNvbnN0IHVzZXJBZGRyZXNzID0gYXdhaXQgdGhpcy5zaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgXG4gICAgICAvLyAxLiBDaGVjayB1c2VyJ3MgRVRIIGJhbGFuY2VcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJhbGFuY2UodXNlckFkZHJlc3MpO1xuXG5cbiAgICAgIFxuICAgICAgaWYgKGJhbGFuY2UgPCBib25kQW1vdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IEVUSCBiYWxhbmNlLiBOZWVkICR7ZXRoZXJzLmZvcm1hdEV0aGVyKGJvbmRBbW91bnQpfSBFVEggYnV0IG9ubHkgaGF2ZSAke2V0aGVycy5mb3JtYXRFdGhlcihiYWxhbmNlKX0gRVRIYCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIDIuIENoZWNrIGNvbnRyYWN0IHBhdXNlIHN0YXR1c1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGF1c2VkUmVzdWx0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5jYWxsKHtcbiAgICAgICAgICB0bzogUkFXX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgICAgZGF0YTogXCIweDVjOTc1YWJiXCIgLy8gcGF1c2VkKCkgc2VsZWN0b3JcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGlzUGF1c2VkID0gcGF1c2VkUmVzdWx0ID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMVwiO1xuXG4gICAgICAgIFxuICAgICAgICBpZiAoaXNQYXVzZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250cmFjdCBpcyBjdXJyZW50bHkgcGF1c2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChwYXVzZUVycm9yKSB7XG5cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gMy4gVmFsaWRhdGUgdGFyZ2V0IGNvbnRyYWN0IGV4aXN0cyBhbmQgaGFzIGJ5dGVjb2RlXG4gICAgICBjb25zdCB0YXJnZXRDb2RlID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRDb2RlKHRhcmdldENvbnRyYWN0KTtcblxuXG4gICAgICBcbiAgICAgIGlmICh0YXJnZXRDb2RlID09PSBcIjB4XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYXJnZXQgY29udHJhY3QgJHt0YXJnZXRDb250cmFjdH0gZG9lcyBub3QgZXhpc3Qgb24gU2Vwb2xpYSB0ZXN0bmV0YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIDQuIENoZWNrIHRyZWFzdXJ5IGFkZHJlc3MgY29uZmlndXJhdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHJlYXN1cnlBZGRyZXNzID0gYXdhaXQgdGhpcy5jb250cmFjdCEudHJlYXN1cnkoKTtcblxuICAgICAgICBcbiAgICAgICAgaWYgKHRyZWFzdXJ5QWRkcmVzcyA9PT0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyZWFzdXJ5IGFkZHJlc3MgaXMgbm90IGNvbmZpZ3VyZWQgKHplcm8gYWRkcmVzcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRyZWFzdXJ5IGNhbiByZWNlaXZlIGZ1bmRzXG4gICAgICAgIGNvbnN0IHRyZWFzdXJ5Q29kZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0Q29kZSh0cmVhc3VyeUFkZHJlc3MpO1xuXG4gICAgICAgIFxuICAgICAgICBpZiAodHJlYXN1cnlDb2RlLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAvLyBUcmVhc3VyeSBpcyBhIGNvbnRyYWN0LCB0ZXN0IGlmIGl0IGNhbiByZWNlaXZlIGZ1bmRzXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgIHRvOiB0cmVhc3VyeUFkZHJlc3MsXG4gICAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMSksIC8vIDEgd2VpIHRlc3RcbiAgICAgICAgICAgICAgZnJvbTogdXNlckFkZHJlc3NcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgfSBjYXRjaCAodHJlYXN1cnlUZXN0RXJyb3IpIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVHJlYXN1cnkgdGVzdCBmYWlsZWQ6XCIsIHRyZWFzdXJ5VGVzdEVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENSSVRJQ0FMOiBUZXN0IHRoZSBleGFjdCBwbGF0Zm9ybSBmZWUgdHJhbnNmZXIgdGhhdCBoYXBwZW5zIGluIGNvbW1pdFNwZWNcbiAgICAgICAgY29uc3QgcGxhdGZvcm1GZWUgPSAoYm9uZEFtb3VudCAqIEJpZ0ludCg1KSkgLyBCaWdJbnQoMTAwKTtcbiAgICAgICAgaWYgKHBsYXRmb3JtRmVlID4gQmlnSW50KDApKSB7XG5cblxuXG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgIHRvOiB0cmVhc3VyeUFkZHJlc3MsXG4gICAgICAgICAgICAgIHZhbHVlOiBwbGF0Zm9ybUZlZSxcbiAgICAgICAgICAgICAgZnJvbTogdXNlckFkZHJlc3MsXG4gICAgICAgICAgICAgIGdhc0xpbWl0OiA1MDAwMCAvLyBNYXRjaCBjb250cmFjdCBnYXMgbGltaXRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgfSBjYXRjaCAodGVzdEVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgVHJlYXN1cnkgdHJhbnNmZXIgdGVzdCBmYWlsZWQ6XCIsIHRlc3RFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRyYW5zYWN0aW9uIG1heSBmYWlsIGF0IHRyZWFzdXJ5IHRyYW5zZmVyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodHJlYXN1cnlFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUcmVhc3VyeSBjaGVjayBmYWlsZWQ6XCIsIHRyZWFzdXJ5RXJyb3IpO1xuICAgICAgICBjb25zb2xlLndhcm4oXCJDb250aW51aW5nIGRlc3BpdGUgdHJlYXN1cnkgaXNzdWVzIC0gdHJhbnNhY3Rpb24gd2lsbCBsaWtlbHkgZmFpbFwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gNS4gQ2hlY2sgbWluaW11bSBib25kIHJlcXVpcmVtZW50XG4gICAgICBjb25zdCBjb250cmFjdE1pbkJvbmQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0Lm1pbkJvbmQoKTtcblxuXG4gICAgICBcbiAgICAgIC8vIFNraXAgYm9uZCBhbW91bnQgY2hlY2sgZm9yIGNvbW1pdFNwZWMgKGJvbmRBbW91bnQgaXMgMCBmb3IgY29tbWl0KVxuICAgICAgLy8gQm9uZHMgYXJlIG9ubHkgcmVxdWlyZWQgZHVyaW5nIHJldmVhbFxuICAgICAgaWYgKGJvbmRBbW91bnQgPiAwbiAmJiBib25kQW1vdW50IDwgY29udHJhY3RNaW5Cb25kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQm9uZCBhbW91bnQgJHtldGhlcnMuZm9ybWF0RXRoZXIoYm9uZEFtb3VudCl9IEVUSCBpcyBiZWxvdyBtaW5pbXVtIHJlcXVpcmVkICR7ZXRoZXJzLmZvcm1hdEV0aGVyKGNvbnRyYWN0TWluQm9uZCl9IEVUSGApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyA2LiBDYWxjdWxhdGUgcGxhdGZvcm0gZmVlIGFuZCB2ZXJpZnkgc3VmZmljaWVudCBmdW5kc1xuICAgICAgLy8gTk9URTogY29tbWl0U3BlYyBkb2Vzbid0IHRha2UgYW55IHBheW1lbnQsIHNvIHNraXAgdGhpcyBjaGVjayB3aGVuIGJvbmRBbW91bnQgaXMgMFxuICAgICAgLy8gVGhlIGJvbmQgaXMgb25seSBwYWlkIGR1cmluZyByZXZlYWxcbiAgICAgIGlmIChib25kQW1vdW50ID4gMG4pIHtcbiAgICAgICAgY29uc3QgcGxhdGZvcm1GZWUgPSAoYm9uZEFtb3VudCAqIEJpZ0ludCg1KSkgLyBCaWdJbnQoMTAwKTsgLy8gNSUgcGxhdGZvcm0gZmVlXG4gICAgICAgIGNvbnN0IG5ldEJvbmRBbW91bnQgPSBib25kQW1vdW50IC0gcGxhdGZvcm1GZWU7IC8vIEFtb3VudCBhY3R1YWxseSB1c2VkIGFzIGJvbmRcbiAgICAgICAgXG4gICAgICAgIGlmIChuZXRCb25kQW1vdW50IDwgY29udHJhY3RNaW5Cb25kKSB7XG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIHJlcXVpcmVkIHRvdGFsIHRvIG1lZXQgbWluaW11bSBhZnRlciBmZWUgZGVkdWN0aW9uXG4gICAgICAgICAgY29uc3QgcmVxdWlyZWRUb3RhbCA9IChjb250cmFjdE1pbkJvbmQgKiBCaWdJbnQoMTAwKSkgLyBCaWdJbnQoOTUpOyAvLyBSZXZlcnNlIGNhbGN1bGF0aW9uXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZnRlciBwbGF0Zm9ybSBmZWUsIG5ldCBib25kIHdvdWxkIGJlICR7ZXRoZXJzLmZvcm1hdEV0aGVyKG5ldEJvbmRBbW91bnQpfSBFVEgsIGJ1dCBtaW5pbXVtIHJlcXVpcmVkIGlzICR7ZXRoZXJzLmZvcm1hdEV0aGVyKGNvbnRyYWN0TWluQm9uZCl9IEVUSC4gU2VuZCBhdCBsZWFzdCAke2V0aGVycy5mb3JtYXRFdGhlcihyZXF1aXJlZFRvdGFsKX0gRVRIYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gNy4gVGVzdCBSZWFsaXR5LmV0aCBjb250cmFjdCBjb25uZWN0aXZpdHlcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFNraXAgUmVhbGl0eS5ldGggY29ubmVjdGl2aXR5IHRlc3QgZm9yIG5vd1xuICAgICAgICBjb25zb2xlLmxvZyhcIuKckyBTa2lwcGluZyBSZWFsaXR5LmV0aCBjb25uZWN0aXZpdHkgdGVzdFwiKTtcblxuICAgICAgICBcbiAgICAgICAgLy8gY29uc3QgcmVhbGl0eUNvZGUgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldENvZGUocmVhbGl0eUV0aEFkZHJlc3MpO1xuXG4gICAgICAgIFxuICAgICAgICAvLyBpZiAocmVhbGl0eUNvZGUgPT09IFwiMHhcIikge1xuICAgICAgICAvLyAgIHRocm93IG5ldyBFcnJvcihcIlJlYWxpdHkuZXRoIGNvbnRyYWN0IG5vdCBmb3VuZCBhdCBjb25maWd1cmVkIGFkZHJlc3NcIik7XG4gICAgICAgIC8vIH1cbiAgICAgIH0gY2F0Y2ggKHJlYWxpdHlFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUmVhbGl0eS5ldGggY2hlY2sgZmFpbGVkOlwiLCByZWFsaXR5RXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgdmVyaWZ5IFJlYWxpdHkuZXRoIGludGVncmF0aW9uXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyA4LiBUZXN0IGNvbnRyYWN0IGZ1bmN0aW9uIGF2YWlsYWJpbGl0eSB3aXRoIHN0YXRpYyBjYWxsXG4gICAgICB0cnkge1xuXG4gICAgICAgIGNvbnN0IHRlc3RDb21taXRtZW50ID1cbiAgICAgICAgICBcIjB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZlwiO1xuXG4gICAgICAgIC8vIGNvbW1pdFNwZWMgaW4gVjEgYWNjZXB0cyBvbmx5IChieXRlczMyIGNvbW1pdG1lbnQsIGFkZHJlc3MgdGFyZ2V0Q29udHJhY3QsIHVpbnQyNTYgY2hhaW5JZCkuXG4gICAgICAgIC8vIERvIG5vdCBwYXNzIGFuIGluY2VudGl2ZUlkIGhlcmUsIGFzIHRoZSBWMSBjb250cmFjdCBkb2VzIG5vdCBpbmNsdWRlIHRoYXQgcGFyYW1ldGVyLlxuICAgICAgICAvLyBJTVBPUlRBTlQ6IGNvbW1pdFNwZWMgaXMgTk9UIHBheWFibGUgLSBubyB2YWx1ZSBzaG91bGQgYmUgc2VudFxuICAgICAgICBhd2FpdCB0aGlzLmNvbnRyYWN0LmNvbW1pdFNwZWMuc3RhdGljQ2FsbChcbiAgICAgICAgICB0ZXN0Q29tbWl0bWVudCxcbiAgICAgICAgICB0YXJnZXRDb250cmFjdCxcbiAgICAgICAgICAxLCAvLyBEZWZhdWx0IHRvIG1haW5uZXQgZm9yIHRlc3RcbiAgICAgICAgICB7IGZyb206IHVzZXJBZGRyZXNzIH1cbiAgICAgICAgKTtcblxuXG4gICAgICB9IGNhdGNoIChzdGF0aWNFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MIFN0YXRpYyBjYWxsIGZhaWxlZDpcIiwgc3RhdGljRXJyb3IpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN0YXRpY0Vycm9yLmRhdGEpIHtcblxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGVycm9yXG4gICAgICAgICAgY29uc3QgZXJyb3JNYXBwaW5ncyA9IFtcbiAgICAgICAgICAgIHsgc2VsZWN0b3I6IGV0aGVycy5pZChcIkluc3VmZmljaWVudEJvbmQoKVwiKS5zbGljZSgwLCAxMCksIG5hbWU6IFwiSW5zdWZmaWNpZW50Qm9uZFwiIH0sXG4gICAgICAgICAgICB7IHNlbGVjdG9yOiBldGhlcnMuaWQoXCJDb250cmFjdE5vdEZvdW5kKClcIikuc2xpY2UoMCwgMTApLCBuYW1lOiBcIkNvbnRyYWN0Tm90Rm91bmRcIiB9LFxuICAgICAgICAgICAgeyBzZWxlY3RvcjogZXRoZXJzLmlkKFwiSW52YWxpZENvbnRyYWN0KClcIikuc2xpY2UoMCwgMTApLCBuYW1lOiBcIkludmFsaWRDb250cmFjdFwiIH0sXG4gICAgICAgICAgICB7IHNlbGVjdG9yOiBldGhlcnMuaWQoXCJVbmF1dGhvcml6ZWQoKVwiKS5zbGljZSgwLCAxMCksIG5hbWU6IFwiVW5hdXRob3JpemVkXCIgfSxcbiAgICAgICAgICAgIHsgc2VsZWN0b3I6IFwiMHhkOTJlMjMzZFwiLCBuYW1lOiBcIlBhdXNlZFwiIH1cbiAgICAgICAgICBdO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGVycm9yU2VsZWN0b3IgPSBzdGF0aWNFcnJvci5kYXRhLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICBjb25zdCBrbm93bkVycm9yID0gZXJyb3JNYXBwaW5ncy5maW5kKGUgPT4gZS5zZWxlY3RvciA9PT0gZXJyb3JTZWxlY3Rvcik7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGtub3duRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udHJhY3Qgd291bGQgcmV2ZXJ0IHdpdGg6ICR7a25vd25FcnJvci5uYW1lfSgpYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udHJhY3Qgd291bGQgcmV2ZXJ0IHdpdGggdW5rbm93biBlcnJvcjogJHtlcnJvclNlbGVjdG9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250cmFjdCBmdW5jdGlvbiBjYWxsIHdvdWxkIGZhaWwgKG5vIHJldmVydCBkYXRhIGF2YWlsYWJsZSlcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gOS4gR2FzIGVzdGltYXRpb24gdGVzdFxuICAgICAgdHJ5IHtcblxuICAgICAgICBjb25zdCB0ZXN0Q29tbWl0bWVudCA9XG4gICAgICAgICAgXCIweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWZcIjtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHRlc3RJbmNlbnRpdmUgcGFyYW1ldGVyOyBjb21taXRTcGVjIG9ubHkgdGFrZXMgdGhyZWUgYXJndW1lbnRzLlxuICAgICAgICBjb25zdCBnYXNFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuY29udHJhY3QuY29tbWl0U3BlYy5lc3RpbWF0ZUdhcyhcbiAgICAgICAgICB0ZXN0Q29tbWl0bWVudCxcbiAgICAgICAgICB0YXJnZXRDb250cmFjdCxcbiAgICAgICAgICAxLCAvLyBEZWZhdWx0IHRvIG1haW5uZXQgZm9yIHRlc3RcbiAgICAgICAgICB7IHZhbHVlOiBib25kQW1vdW50IH1cbiAgICAgICAgKTtcblxuXG5cbiAgICAgICAgaWYgKGdhc0VzdGltYXRlID4gQmlnSW50KDEwMDAwMDApKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIEhpZ2ggZ2FzIGVzdGltYXRlIC0gdHJhbnNhY3Rpb24gbWlnaHQgYmUgY29tcGxleFwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGdhc0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJHYXMgZXN0aW1hdGlvbiBmYWlsZWQ6XCIsIGdhc0Vycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGVzdGltYXRlIGdhcyBmb3IgdHJhbnNhY3Rpb25cIik7XG4gICAgICB9XG4gICAgICBcblxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgUHJlLXRyYW5zYWN0aW9uIGRpYWdub3N0aWNzIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZWhlbnNpdmUgY29udHJhY3QgYW5hbHlzaXMgdG8gdW5kZXJzdGFuZCB3aGF0J3MgZGVwbG95ZWRcbiAgICovXG4gIGFzeW5jIGFuYWx5emVDb250cmFjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyIHx8ICF0aGlzLnNpZ25lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkXCIpO1xuICAgICAgfVxuXG5cblxuXG5cbiAgICAgIC8vIDEuIENoZWNrIGlmIHRoZXJlJ3MgYW55IGJ5dGVjb2RlXG4gICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRDb2RlKFJBV19DT05UUkFDVF9BRERSRVNTKTtcblxuXG5cbiAgICAgIGlmIChjb2RlID09PSBcIjB4XCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBObyBjb250cmFjdCBkZXBsb3llZCBhdCB0aGlzIGFkZHJlc3NcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gMi4gVGVzdCBmdW5jdGlvbiBzZWxlY3RvcnMgdG8gaWRlbnRpZnkgd2hpY2ggY29udHJhY3QgaXMgZGVwbG95ZWRcbiAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IHtcbiAgICAgICAgXCJtaW5Cb25kKClcIjogXCIweDFiYjY1OWFlXCIsXG4gICAgICAgIC8vIFVzZSB0aGUgbmV3IDMtcGFyYW1ldGVyIGNvbW1pdFNwZWMgc2VsZWN0b3IgZm9yIFYxIGNvbnRyYWN0c1xuICAgICAgICBcImNvbW1pdFNwZWMoYnl0ZXMzMixhZGRyZXNzLHVpbnQyNTYpXCI6IFwiMHhcIiArIGV0aGVycy5pZChcImNvbW1pdFNwZWMoYnl0ZXMzMixhZGRyZXNzLHVpbnQyNTYpXCIpLnNsaWNlKDIsIDEwKSxcbiAgICAgICAgXCJjcmVhdGVTcGVjKHN0cmluZylcIjogXCIweDhjZDhkYjQ5XCIsIC8vIE9yaWdpbmFsXG4gICAgICAgIFwicGF1c2VkKClcIjogXCIweDVjOTc1YWJiXCIsIC8vIFYxIChQYXVzYWJsZSlcbiAgICAgICAgXCJBRE1JTl9ST0xFKClcIjogXCIweDc1YjIzOGZjXCIsIC8vIFYxIChBY2Nlc3NDb250cm9sKVxuICAgICAgICBcInJlYWxpdHlFVEgoKVwiOiBcIjB4YjBiNjFiOWJcIixcbiAgICAgICAgXCJ0ZW1wbGF0ZUlkKClcIjogXCIweDY2ZDhhYzE5XCJcbiAgICAgIH07XG5cbiAgICAgIGZvciAoY29uc3QgW2Z1bmNOYW1lLCBzZWxlY3Rvcl0gb2YgT2JqZWN0LmVudHJpZXMoc2VsZWN0b3JzKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICB0bzogUkFXX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgICAgICBkYXRhOiBzZWxlY3RvciArIFwiMFwiLnJlcGVhdCgxOTIpIC8vIEFkZCBwYWRkaW5nIGZvciBwYXJhbWV0ZXJzXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgIGlmIChlcnJvci5kYXRhICYmIGVycm9yLmRhdGEgIT09IFwiMHhcIikge1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBUZXN0IGNvbW1pdFNwZWMgc3BlY2lmaWNhbGx5IHdpdGggZGV0YWlsZWQgYW5hbHlzaXNcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGVzdENvbW1pdG1lbnQgPSBcIjB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZlwiO1xuICAgICAgICBjb25zdCB0ZXN0VGFyZ2V0ID0gUkFXX0NPTlRSQUNUX0FERFJFU1M7XG4gICAgICAgIGNvbnN0IG1pbkJvbmQgPSBCaWdJbnQoXCIxMDAwMDAwMDAwMDAwMDBcIik7IC8vIDAuMDAwMSBFVEhcblxuICAgICAgICAvLyBFbmNvZGUgdGhlIGNhbGwgdG8gdGhlIG5ldyAzLXBhcmFtZXRlciBjb21taXRTcGVjXG4gICAgICAgIGNvbnN0IGVuY29kZWRDYWxsID0gZXRoZXJzLmNvbmNhdChbXG4gICAgICAgICAgZXRoZXJzLmlkKFwiY29tbWl0U3BlYyhieXRlczMyLGFkZHJlc3MsdWludDI1NilcIikuc2xpY2UoMCwgMTApLCAvLyBjb21taXRTcGVjIHNlbGVjdG9yXG4gICAgICAgICAgZXRoZXJzLnplcm9QYWRWYWx1ZSh0ZXN0Q29tbWl0bWVudCwgMzIpLFxuICAgICAgICAgIGV0aGVycy56ZXJvUGFkVmFsdWUodGVzdFRhcmdldCwgMzIpLFxuICAgICAgICAgIGV0aGVycy56ZXJvUGFkVmFsdWUoZXRoZXJzLnRvQmVIZXgoMSksIDMyKSAvLyBjaGFpbklkID0gMSBmb3IgdGVzdFxuICAgICAgICBdKTtcblxuXG5cbiAgICAgICAgLy8gVHJ5IHN0YXRpYyBjYWxsXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgdG86IFJBV19DT05UUkFDVF9BRERSRVNTLFxuICAgICAgICAgIGRhdGE6IGVuY29kZWRDYWxsLFxuICAgICAgICAgIHZhbHVlOiBtaW5Cb25kLFxuICAgICAgICAgIGZyb206IGF3YWl0IHRoaXMuc2lnbmVyLmdldEFkZHJlc3MoKVxuICAgICAgICB9KTtcblxuXG5cbiAgICAgIH0gY2F0Y2ggKGNvbW1pdEVycm9yOiBhbnkpIHtcblxuICAgICAgICBpZiAoY29tbWl0RXJyb3IuZGF0YSkge1xuXG5cbiAgICAgICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBlcnJvclxuICAgICAgICAgIGlmIChjb21taXRFcnJvci5kYXRhLmxlbmd0aCA+PSAxMCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JTZWxlY3RvciA9IGNvbW1pdEVycm9yLmRhdGEuc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGVycm9yIHNpZ25hdHVyZXMgZHluYW1pY2FsbHkgdG8gZW5zdXJlIGFjY3VyYWN5XG4gICAgICAgICAgICBjb25zdCBlcnJvck1hcHBpbmdzID0gW1xuICAgICAgICAgICAgICBcIkFscmVhZHlQcm9wb3NlZCgpXCIsXG4gICAgICAgICAgICAgIFwiTm90UHJvcG9zZWQoKVwiLFxuICAgICAgICAgICAgICBcIkluc3VmZmljaWVudEJvbmQoKVwiLFxuICAgICAgICAgICAgICBcIkluc3VmZmljaWVudEluY2VudGl2ZSgpXCIsXG4gICAgICAgICAgICAgIFwiSW52YWxpZENvbnRyYWN0KClcIixcbiAgICAgICAgICAgICAgXCJDb250cmFjdE5vdEZvdW5kKClcIixcbiAgICAgICAgICAgICAgXCJJbnZhbGlkSVBGUygpXCIsXG4gICAgICAgICAgICAgIFwiQ29tbWl0bWVudE5vdEZvdW5kKClcIixcbiAgICAgICAgICAgICAgXCJDb21taXRtZW50RXhwaXJlZCgpXCIsXG4gICAgICAgICAgICAgIFwiQ29tbWl0bWVudEFscmVhZHlSZXZlYWxlZCgpXCIsXG4gICAgICAgICAgICAgIFwiSW52YWxpZFJldmVhbCgpXCIsXG4gICAgICAgICAgICAgIFwiTm90RmluYWxpemVkKClcIixcbiAgICAgICAgICAgICAgXCJBbHJlYWR5U2V0dGxlZCgpXCIsXG4gICAgICAgICAgICAgIFwiTm9JbmNlbnRpdmVUb0NsYWltKClcIixcbiAgICAgICAgICAgICAgXCJJbmNlbnRpdmVFeHBpcmVkKClcIixcbiAgICAgICAgICAgICAgXCJVbmF1dGhvcml6ZWQoKVwiXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBrbm93bkVycm9ycyA9IHt9O1xuICAgICAgICAgICAgZXJyb3JNYXBwaW5ncy5mb3JFYWNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBldGhlcnMuaWQoZXJyb3IpLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgICAga25vd25FcnJvcnNbc2VsZWN0b3JdID0gZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIGtub3duIE9wZW5aZXBwZWxpbiBlcnJvcnNcbiAgICAgICAgICAgIGtub3duRXJyb3JzW1wiMHhkOTJlMjMzZFwiXSA9IFwiUGF1c2VkKClcIjtcbiAgICAgICAgICAgIGtub3duRXJyb3JzW1wiMHgwOGMzNzlhMFwiXSA9IFwiRXJyb3Ioc3RyaW5nKVwiO1xuICAgICAgICAgICAgXG5cblxuICAgICAgICAgICAgaWYgKGtub3duRXJyb3JzW2Vycm9yU2VsZWN0b3JdKSB7XG5cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIElmIGl0J3MgQ29udHJhY3ROb3RGb3VuZCwgdGhhdCdzIG91ciBtYWluIHN1c3BlY3RcbiAgICAgICAgICAgICAgaWYgKGVycm9yU2VsZWN0b3IgPT09IFwiMHhlZDU5MjYyNFwiKSB7XG5cblxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIExldCdzIGNoZWNrIHRoZSB0YXJnZXQgY29udHJhY3QgYnl0ZWNvZGUgc2l6ZVxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldENvZGUgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldENvZGUodGVzdFRhcmdldCk7XG5cblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkNvbnRyYWN0IGFuYWx5c2lzIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZGVudGlmeSB3aGljaCBjb250cmFjdCB2ZXJzaW9uIGlzIGFjdHVhbGx5IGRlcGxveWVkXG4gICAqL1xuICBhc3luYyBpZGVudGlmeURlcGxveWVkQ29udHJhY3QoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5wcm92aWRlciB8fCAhdGhpcy5zaWduZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbm5lY3RlZFwiKTtcbiAgICAgIH1cblxuXG5cbiAgICAgIC8vIFRlc3Qgc2lnbmF0dXJlIGRpZmZlcmVuY2VzIGJldHdlZW4gVjEgYW5kIG9yaWdpbmFsIC0gY2FsY3VsYXRlIHByb3BlciBzZWxlY3RvcnNcbiAgICAgIGNvbnN0IHRlc3RzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJPcmlnaW5hbCBLYWlTaWduXCIsXG4gICAgICAgICAgc2VsZWN0b3I6IGV0aGVycy5pZChcImNyZWF0ZVNwZWMoc3RyaW5nKVwiKS5zbGljZSgwLCAxMCksIC8vIGNyZWF0ZVNwZWMoc3RyaW5nKVxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkhhcyBjcmVhdGVTcGVjKHN0cmluZykgZnVuY3Rpb25cIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJLYWlTaWduIFYxXCIsXG4gICAgICAgICAgc2VsZWN0b3I6IGV0aGVycy5pZChcImNvbW1pdFNwZWMoYnl0ZXMzMixhZGRyZXNzLHVpbnQyNTYpXCIpLnNsaWNlKDAsIDEwKSwgLy8gY29tbWl0U3BlYyhieXRlczMyLGFkZHJlc3MsdWludDI1NilcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJIYXMgY29tbWl0U3BlYyhieXRlczMyLGFkZHJlc3MsdWludDI1NikgZnVuY3Rpb25cIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJWMSBQYXVzYWJsZVwiLFxuICAgICAgICAgIHNlbGVjdG9yOiBldGhlcnMuaWQoXCJwYXVzZWQoKVwiKS5zbGljZSgwLCAxMCksIC8vIHBhdXNlZCgpXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiSGFzIHBhdXNlZCgpIGZ1bmN0aW9uIGZyb20gUGF1c2FibGVcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJWMSBBY2Nlc3NDb250cm9sXCIsXG4gICAgICAgICAgc2VsZWN0b3I6IGV0aGVycy5pZChcIkFETUlOX1JPTEUoKVwiKS5zbGljZSgwLCAxMCksIC8vIEFETUlOX1JPTEUoKVxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkhhcyBBRE1JTl9ST0xFIGNvbnN0YW50IGZyb20gQWNjZXNzQ29udHJvbFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkNvbnRyYWN0IG1pbkJvbmRcIixcbiAgICAgICAgICBzZWxlY3RvcjogZXRoZXJzLmlkKFwibWluQm9uZCgpXCIpLnNsaWNlKDAsIDEwKSwgLy8gbWluQm9uZCgpXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiSGFzIG1pbkJvbmQoKSBmdW5jdGlvblwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkNvbnRyYWN0IHJlYWxpdHlFVEhcIixcbiAgICAgICAgICBzZWxlY3RvcjogZXRoZXJzLmlkKFwicmVhbGl0eUVUSCgpXCIpLnNsaWNlKDAsIDEwKSwgLy8gcmVhbGl0eUVUSCgpXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiSGFzIHJlYWxpdHlFVEgoKSBmdW5jdGlvblwiXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgICBcblxuICAgICAgdGVzdHMuZm9yRWFjaCh0ZXN0ID0+IHtcblxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgdGVzdCBvZiB0ZXN0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICB0bzogUkFXX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgICAgICBkYXRhOiB0ZXN0LnNlbGVjdG9yXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGDinIUgJHt0ZXN0Lm5hbWV9OiBZRVMgKCR7dGVzdC5kZXNjcmlwdGlvbn0pYCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgIGlmIChlcnJvci5kYXRhICYmIGVycm9yLmRhdGEgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGDimqDvuI8gJHt0ZXN0Lm5hbWV9OiBFWElTVFMgQlVUIFJFVkVSVFMgKCR7dGVzdC5kZXNjcmlwdGlvbn0pYCk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGDinYwgJHt0ZXN0Lm5hbWV9OiBOTyAoJHt0ZXN0LmRlc2NyaXB0aW9ufSlgKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggY29udHJhY3QgdGhpcyBpc1xuICAgICAgY29uc3QgaGFzQ29tbWl0U3BlYyA9IHJlc3VsdHNbMV0uaW5jbHVkZXMoXCLinIVcIikgfHwgcmVzdWx0c1sxXS5pbmNsdWRlcyhcIuKaoO+4j1wiKTtcbiAgICAgIGNvbnN0IGhhc0NyZWF0ZVNwZWMgPSByZXN1bHRzWzBdLmluY2x1ZGVzKFwi4pyFXCIpIHx8IHJlc3VsdHNbMF0uaW5jbHVkZXMoXCLimqDvuI9cIik7XG4gICAgICBjb25zdCBoYXNQYXVzZWQgPSByZXN1bHRzWzJdLmluY2x1ZGVzKFwi4pyFXCIpIHx8IHJlc3VsdHNbMl0uaW5jbHVkZXMoXCLimqDvuI9cIik7XG4gICAgICBjb25zdCBoYXNNaW5Cb25kID0gcmVzdWx0c1s0XS5pbmNsdWRlcyhcIuKchVwiKSB8fCByZXN1bHRzWzRdLmluY2x1ZGVzKFwi4pqg77iPXCIpO1xuICAgICAgY29uc3QgaGFzUmVhbGl0eUVUSCA9IHJlc3VsdHNbNV0uaW5jbHVkZXMoXCLinIVcIikgfHwgcmVzdWx0c1s1XS5pbmNsdWRlcyhcIuKaoO+4j1wiKTtcblxuICAgICAgaWYgKGhhc0NvbW1pdFNwZWMgJiYgaGFzUGF1c2VkKSB7XG5cbiAgICAgIH0gZWxzZSBpZiAoaGFzQ3JlYXRlU3BlYyAmJiAhaGFzQ29tbWl0U3BlYyAmJiBoYXNNaW5Cb25kICYmIGhhc1JlYWxpdHlFVEgpIHtcblxuXG5cbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIHRoaXMgaW5mb3JtYXRpb24gZm9yIGxhdGVyIHVzZVxuICAgICAgICAod2luZG93IGFzIGFueSkuX19LQUlTSUdOX0NPTlRSQUNUX1RZUEUgPSBcIm9yaWdpbmFsXCI7XG4gICAgICB9IGVsc2UgaWYgKCFoYXNDcmVhdGVTcGVjICYmICFoYXNDb21taXRTcGVjKSB7XG5cblxuICAgICAgfSBlbHNlIHtcblxuXG4gICAgICB9XG5cbiAgICAgIC8vIFByaW50IHN1bW1hcnlcblxuICAgICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiBjb25zb2xlLmxvZyhcIiAgXCIgKyByZXN1bHQpKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ29udHJhY3QgaWRlbnRpZmljYXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgY29udHJhY3QgY29ubmVjdGl2aXR5IGFuZCBiYXNpYyBmdW5jdGlvbnNcbiAgICovXG4gIGFzeW5jIHRlc3RDb250cmFjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRyYWN0IHx8ICF0aGlzLnNpZ25lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkIHRvIE1ldGFNYXNrLiBQbGVhc2UgY29ubmVjdCBmaXJzdC5cIik7XG4gICAgICB9XG5cblxuXG4gICAgICBcbiAgICAgIC8vIFRlc3QgMTogQ2hlY2sgaWYgY29udHJhY3QgZXhpc3RzXG4gICAgICBjb25zdCBjb250cmFjdENvZGUgPSBhd2FpdCB0aGlzLnByb3ZpZGVyIS5nZXRDb2RlKFJBV19DT05UUkFDVF9BRERSRVNTKTtcblxuXG4gICAgICBcbiAgICAgIGlmIChjb250cmFjdENvZGUgPT09IFwiMHhcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjb250cmFjdCBkZXBsb3llZCBhdCB0aGlzIGFkZHJlc3NcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFRlc3QgMjogR2V0IG1pbmltdW0gYm9uZFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWluQm9uZCA9IGF3YWl0IHRoaXMuY29udHJhY3QubWluQm9uZCgpO1xuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi4pyXIG1pbkJvbmQoKSBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udHJhY3QgZXhpc3RzIGJ1dCBtaW5Cb25kKCkgZnVuY3Rpb24gZmFpbGVkIC0gd3JvbmcgQUJJP1wiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVGVzdCAyYjogQ2hlY2sgaWYgdGhpcyBsb29rcyBsaWtlIHRoZSBWMSBjb250cmFjdCBieSBjaGVja2luZyBjb25zdHJ1Y3RvciBlbGVtZW50c1xuICAgICAgdHJ5IHtcblxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHBhdXNlZCBmdW5jdGlvbiAoVjEgc3BlY2lmaWMpXG4gICAgICAgIGNvbnN0IHBhdXNlZFJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIhLmNhbGwoe1xuICAgICAgICAgIHRvOiBSQVdfQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgICBkYXRhOiBcIjB4NWM5NzVhYmJcIiAvLyBwYXVzZWQoKSBzZWxlY3RvclxuICAgICAgICB9KTtcblxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgZm9yIEFETUlOX1JPTEUgY29uc3RhbnQgKFYxIHNwZWNpZmljKVxuICAgICAgICBjb25zdCBhZG1pblJvbGVSZXN1bHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyIS5jYWxsKHtcbiAgICAgICAgICB0bzogUkFXX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgICAgZGF0YTogXCIweDc1YjIzOGZjXCIgLy8gQURNSU5fUk9MRSgpIHNlbGVjdG9yICBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGZvciBDT01NSVRfUkVWRUFMX1RJTUVPVVQgY29uc3RhbnRcbiAgICAgICAgY29uc3QgdGltZW91dFJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIhLmNhbGwoe1xuICAgICAgICAgIHRvOiBSQVdfQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgICBkYXRhOiBcIjB4MTIzNDU2Nzg5MGFiY2RlZlwiIC8vIFRoaXMgd291bGQgYmUgdGhlIHNlbGVjdG9yIGZvciB0aGUgY29uc3RhbnRcbiAgICAgICAgfSk7XG4gICAgICAgIFxuXG4gICAgICB9IGNhdGNoICh2MUNoZWNrRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IHZlcmlmeSBWMSBjb250cmFjdCBmZWF0dXJlczpcIiwgdjFDaGVja0Vycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVGVzdCAzOiBHZXQgUmVhbGl0eS5ldGggYWRkcmVzc1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gU2tpcCBSZWFsaXR5LmV0aCBhZGRyZXNzIHRlc3RcbiAgICAgICAgY29uc29sZS5sb2coXCLinJMgU2tpcHBpbmcgUmVhbGl0eS5ldGggYWRkcmVzcyB0ZXN0XCIpO1xuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi4pyXIHJlYWxpdHlFVEgoKSBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVGVzdCA0OiBDaGVjayBpZiB5b3UgaGF2ZSBuZWNlc3Nhcnkgcm9sZXNcbiAgICAgIHRyeSB7XG5cbiAgICAgICAgY29uc3QgdXNlckFkZHJlc3MgPSBhd2FpdCB0aGlzLnNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgaGFzUm9sZSBmdW5jdGlvbiB0byBBQkkgY2hlY2tcbiAgICAgICAgY29uc3QgaGFzQWRtaW5Sb2xlID0gYXdhaXQgdGhpcy5wcm92aWRlciEuY2FsbCh7XG4gICAgICAgICAgdG86IFJBV19DT05UUkFDVF9BRERSRVNTLFxuICAgICAgICAgIGRhdGE6IGV0aGVycy5jb25jYXQoW1xuICAgICAgICAgICAgXCIweDkxZDE0ODU0XCIsIC8vIGhhc1JvbGUoYnl0ZXMzMixhZGRyZXNzKSBzZWxlY3RvclxuICAgICAgICAgICAgZXRoZXJzLnplcm9QYWRWYWx1ZShcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLCAzMiksIC8vIERFRkFVTFRfQURNSU5fUk9MRVxuICAgICAgICAgICAgZXRoZXJzLnplcm9QYWRWYWx1ZSh1c2VyQWRkcmVzcywgMzIpXG4gICAgICAgICAgXSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChyb2xlRXJyb3IpIHtcblxuICAgICAgfVxuXG4gICAgICAvLyBUZXN0IDU6IENoZWNrIGlmIGNvbW1pdFNwZWMgZnVuY3Rpb24gZXhpc3RzICh1c2luZyB0aGUgbmV3IDMtcGFyYW1ldGVyIHNpZ25hdHVyZSlcbiAgICAgIHRyeSB7XG5cblxuICAgICAgICAvLyBUcnkgdG8gY2FsbCB0aGUgZnVuY3Rpb24gc2VsZWN0b3IgZGlyZWN0bHlcbiAgICAgICAgY29uc3QgY29tbWl0U3BlY1NlbGVjdG9yID0gZXRoZXJzLmlkKFwiY29tbWl0U3BlYyhieXRlczMyLGFkZHJlc3MsdWludDI1NilcIikuc2xpY2UoMCwgMTApO1xuICAgICAgICAvLyBNaW5pbWFsIGNhbGxkYXRhIGZvciAzIHBhcmFtZXRlcnM6IDMgKiAzMiBieXRlcyA9IDk2IGJ5dGVzIG9mIHBhZGRpbmcgKDE5MiBoZXggY2hhcnMpXG4gICAgICAgIGNvbnN0IHRlc3RDYWxsZGF0YSA9IGNvbW1pdFNwZWNTZWxlY3RvciArIFwiMFwiLnJlcGVhdCgxOTIpO1xuXG4gICAgICAgIGNvbnN0IHRlc3RDYWxsID0gYXdhaXQgdGhpcy5wcm92aWRlciEuY2FsbCh7XG4gICAgICAgICAgdG86IFJBV19DT05UUkFDVF9BRERSRVNTLFxuICAgICAgICAgIGRhdGE6IHRlc3RDYWxsZGF0YVxuICAgICAgICB9KTtcblxuICAgICAgfSBjYXRjaCAoc2VsZWN0b3JFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi4pyXIGNvbW1pdFNwZWMgZnVuY3Rpb24gdGVzdCBmYWlsZWQ6XCIsIHNlbGVjdG9yRXJyb3IpO1xuICAgICAgICBpZiAoc2VsZWN0b3JFcnJvci5kYXRhKSB7XG5cblxuICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MganVzdCBhIHJldmVydCBkdWUgdG8gaW52YWxpZCBwYXJhbWV0ZXJzIHZzIGZ1bmN0aW9uIG5vdCBmb3VuZFxuICAgICAgICAgIGlmIChzZWxlY3RvckVycm9yLmRhdGEgPT09IFwiMHhcIiB8fCBzZWxlY3RvckVycm9yLmRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLimqDvuI8gIEZ1bmN0aW9uIG1pZ2h0IG5vdCBleGlzdCAtIG5vIHJldmVydCBkYXRhIHJldHVybmVkXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGVzdCA2OiBUcnkgdG8gY2FsbCBjb21taXRTcGVjIHdpdGggZHJ5IHJ1biB1c2luZyByZWFsaXN0aWMgY29tbWl0bWVudFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGVzdElwZnMgPSBcIlFtVGVzdDEyM1wiO1xuICAgICAgICBjb25zdCB0ZXN0Tm9uY2UgPSBCaWdJbnQoMTIzNDUpO1xuICAgICAgICBjb25zdCB0ZXN0Q29tbWl0bWVudCA9IGV0aGVycy5rZWNjYWsyNTYoZXRoZXJzLnNvbGlkaXR5UGFja2VkKFxuICAgICAgICAgIFtcInN0cmluZ1wiLCBcInVpbnQyNTZcIl0sXG4gICAgICAgICAgW3Rlc3RJcGZzLCB0ZXN0Tm9uY2VdXG4gICAgICAgICkpO1xuICAgICAgICBjb25zdCB0ZXN0VGFyZ2V0ID0gUkFXX0NPTlRSQUNUX0FERFJFU1M7XG4gICAgICAgIC8vIE5vdGU6IGNvbW1pdFNwZWMgaW4gVjEgYWNjZXB0cyBvbmx5IChieXRlczMyIGNvbW1pdG1lbnQsIGFkZHJlc3MgdGFyZ2V0Q29udHJhY3QsIHVpbnQyNTYgY2hhaW5JZCkuXG4gICAgICAgIC8vIERvIG5vdCBkZWZpbmUgb3IgcGFzcyBhIHRlc3RJbmNlbnRpdmUgcGFyYW1ldGVyIGhlcmUuXG5cblxuXG4gICAgICAgIGNvbnN0IGdhc0VzdGltYXRlID0gYXdhaXQgdGhpcy5jb250cmFjdC5jb21taXRTcGVjLmVzdGltYXRlR2FzKFxuICAgICAgICAgIHRlc3RDb21taXRtZW50LFxuICAgICAgICAgIHRlc3RUYXJnZXQsXG4gICAgICAgICAgMSwgLy8gRGVmYXVsdCB0byBtYWlubmV0IGZvciB0ZXN0XG4gICAgICAgICAgeyB2YWx1ZTogYXdhaXQgdGhpcy5jb250cmFjdC5taW5Cb25kKCkgfVxuICAgICAgICApO1xuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi4pyXIGNvbW1pdFNwZWMgdGVzdCBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRoaXMgc3VnZ2VzdHMgdGhlIGNvbnRyYWN0IG1pZ2h0IGJlIHBhdXNlZCwgaGF2ZSBhY2Nlc3MgY29udHJvbCwgb3IgZGlmZmVyZW50IGZ1bmN0aW9uIHNpZ25hdHVyZVwiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGVycm9yXG4gICAgICAgIGlmIChlcnJvci5kYXRhKSB7XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkNvbnRyYWN0IHRlc3QgZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgS0FJU0lHTiBWMSBGVU5DVElPTlNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBhc3luYyBjcmVhdGVJbmNlbnRpdmUoXG4gICAgdGFyZ2V0Q29udHJhY3Q6IHN0cmluZyxcbiAgICB0YXJnZXRDaGFpbklkOiBudW1iZXIsXG4gICAgYW1vdW50OiBzdHJpbmcsXG4gICAgZHVyYXRpb25TZWNvbmRzOiBudW1iZXIsXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICghdGhpcy5jb250cmFjdCB8fCAhdGhpcy5zaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWQgdG8gTWV0YU1hc2suIFBsZWFzZSBjb25uZWN0IGZpcnN0LlwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gTmV0d29yayBjaGVjayByZW1vdmVkIC0gbGV0IHVzZXJzIGNvbm5lY3Qgb24gYW55IG5ldHdvcmtcbiAgICAgIFxuXG4gICAgICBjb25zb2xlLmxvZyhcIvCfkrAgUGFyYW1ldGVyczpcIiwge1xuICAgICAgICB0YXJnZXRDb250cmFjdCxcbiAgICAgICAgdGFyZ2V0Q2hhaW5JZCxcbiAgICAgICAgdG9rZW4sXG4gICAgICAgIGFtb3VudCxcbiAgICAgICAgZHVyYXRpb25TZWNvbmRzLFxuICAgICAgICBkZXNjcmlwdGlvblxuICAgICAgfSk7XG5cbiAgICAgIC8vIEVUSCBvbmx5IC0gdmFsdWUgaXMgdGhlIGFtb3VudFxuXG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGNvbnRyYWN0IGhhcyB0aGUgY3JlYXRlSW5jZW50aXZlIGZ1bmN0aW9uXG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5jb250cmFjdC5jcmVhdGVJbmNlbnRpdmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udHJhY3QgZG9lcyBub3QgaGF2ZSBjcmVhdGVJbmNlbnRpdmUgZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgICBcblxuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmNyZWF0ZUluY2VudGl2ZShcbiAgICAgICAgdGFyZ2V0Q29udHJhY3QsXG4gICAgICAgIHRhcmdldENoYWluSWQsXG4gICAgICAgIGFtb3VudCxcbiAgICAgICAgZHVyYXRpb25TZWNvbmRzLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgeyB2YWx1ZTogYW1vdW50IH1cbiAgICAgICk7XG4gICAgICBcblxuXG4gICAgICBcbiAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG5cbiAgICAgIFxuICAgICAgLy8gTG9nIGFueSBldmVudHMgZW1pdHRlZFxuICAgICAgaWYgKHJlY2VpcHQubG9ncyAmJiByZWNlaXB0LmxvZ3MubGVuZ3RoID4gMCkge1xuXG4gICAgICAgIHJlY2VpcHQubG9ncy5mb3JFYWNoKChsb2c6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdHguaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi8J+SpSBFcnJvciBjcmVhdGluZyBpbmNlbnRpdmU6XCIsIGVycm9yKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLwn5SnIENvbnRyYWN0IGFkZHJlc3M6XCIsIHRoaXMuY29udHJhY3Q/LnRhcmdldCk7XG4gICAgICBjb25zb2xlLmVycm9yKFwi8J+RpCBTaWduZXIgYWRkcmVzczpcIiwgYXdhaXQgdGhpcy5zaWduZXI/LmdldEFkZHJlc3MoKSk7XG4gICAgICBcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSAnVU5QUkVESUNUQUJMRV9HQVNfTElNSVQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIHdvdWxkIGZhaWwgLSBjaGVjayB5b3VyIHBhcmFtZXRlcnMgYW5kIGFjY291bnQgYmFsYW5jZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5jb2RlID09PSAnSU5TVUZGSUNJRU5UX0ZVTkRTJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnN1ZmZpY2llbnQgRVRIIGJhbGFuY2UgdG8gY29tcGxldGUgdHJhbnNhY3Rpb25cIik7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3VzZXIgcmVqZWN0ZWQnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiB3YXMgcmVqZWN0ZWQgYnkgdXNlclwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0VXNlckluY2VudGl2ZXModXNlckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAvLyBBdXRvLWNvbm5lY3QgaWYgbm90IGNvbm5lY3RlZFxuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJDb250cmFjdCBub3QgY29ubmVjdGVkLCBhdHRlbXB0aW5nIHRvIGNvbm5lY3QuLi5cIik7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuICAgICAgfSBjYXRjaCAoY29ubmVjdEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBhdXRvLWNvbm5lY3QgZm9yIGdldFVzZXJJbmNlbnRpdmVzOlwiLCBjb25uZWN0RXJyb3IpO1xuICAgICAgICAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgaW5zdGVhZCBvZiB0aHJvd2luZyB0byBwcmV2ZW50IGJsb2NraW5nIHRoZSBVSVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRG91YmxlIGNoZWNrIGFmdGVyIGNvbm5lY3Rpb24gYXR0ZW1wdFxuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgY29uc29sZS53YXJuKFwiQ29udHJhY3Qgc3RpbGwgbm90IGF2YWlsYWJsZSBhZnRlciBjb25uZWN0aW9uIGF0dGVtcHQsIHJldHVybmluZyBlbXB0eSBhcnJheVwiKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgaW5jZW50aXZlSWRzID0gYXdhaXQgdGhpcy5jb250cmFjdC5nZXRVc2VySW5jZW50aXZlcyh1c2VyQWRkcmVzcyk7XG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgZnJvbSBldGhlcnMgcmVzdWx0IHRvIHN0cmluZyBhcnJheVxuICAgICAgY29uc3QgaWRzID0gQXJyYXkuZnJvbShpbmNlbnRpdmVJZHMpO1xuICAgICAgXG4gICAgICByZXR1cm4gaWRzO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLwn5KlIEVycm9yIGdldHRpbmcgdXNlciBpbmNlbnRpdmVzOlwiLCBlcnJvcik7XG4gICAgICBjb25zb2xlLmVycm9yKFwi8J+UpyBDb250cmFjdCBhZGRyZXNzOlwiLCB0aGlzLmNvbnRyYWN0Py50YXJnZXQpO1xuICAgICAgY29uc29sZS5lcnJvcihcIvCfk50gRnVuY3Rpb24gc2lnbmF0dXJlOiBnZXRVc2VySW5jZW50aXZlcyhhZGRyZXNzKVwiKTtcbiAgICAgIFxuICAgICAgLy8gSWYgZnVuY3Rpb24gZG9lc24ndCBleGlzdCBvciByZXR1cm5zIGVtcHR5IGRhdGEsIHJldHVybiBlbXB0eSBhcnJheSBpbnN0ZWFkIG9mIHRocm93aW5nXG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gXCJCQURfREFUQVwiIHx8IGVycm9yLmluZm8/Lm1ldGhvZCA9PT0gXCJnZXRVc2VySW5jZW50aXZlc1wiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBnZXRVc2VySW5jZW50aXZlcyBmdW5jdGlvbiBtYXkgbm90IGV4aXN0IG9uIHRoaXMgY29udHJhY3QsIHJldHVybmluZyBlbXB0eSBhcnJheVwiKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGb3Igb3RoZXIgZXJyb3JzLCBhbHNvIHJldHVybiBlbXB0eSBhcnJheSB0byBwcmV2ZW50IFVJIGJsb2NraW5nXG4gICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gZ2V0VXNlckluY2VudGl2ZXMgZmFpbGVkLCByZXR1cm5pbmcgZW1wdHkgYXJyYXkgdG8gcHJldmVudCBVSSBibG9ja2luZ1wiKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRJbmNlbnRpdmVEYXRhKGluY2VudGl2ZUlkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbm5lY3RlZCB0byBjb250cmFjdC5cIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGluY2VudGl2ZSA9IGF3YWl0IHRoaXMuY29udHJhY3QuaW5jZW50aXZlcyhpbmNlbnRpdmVJZCk7XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSB0aGUgc3RydWN0IHJlc3BvbnNlIHByb3Blcmx5XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGNyZWF0b3I6IGluY2VudGl2ZVswXSwgICAgICAgICAgICAgIC8vIGFkZHJlc3MgY3JlYXRvclxuICAgICAgICB0b2tlbjogaW5jZW50aXZlWzFdLCAgICAgICAgICAgICAgICAvLyBhZGRyZXNzIHRva2VuICBcbiAgICAgICAgYW1vdW50OiBpbmNlbnRpdmVbMl0udG9TdHJpbmcoKSwgICAgLy8gdWludDEyOCBhbW91bnRcbiAgICAgICAgZGVhZGxpbmU6IE51bWJlcihpbmNlbnRpdmVbM10pLCAgICAgLy8gdWludDY0IGRlYWRsaW5lXG4gICAgICAgIGNyZWF0ZWRBdDogTnVtYmVyKGluY2VudGl2ZVs0XSksICAgIC8vIHVpbnQ2NCBjcmVhdGVkQXRcbiAgICAgICAgdGFyZ2V0Q29udHJhY3Q6IGluY2VudGl2ZVs1XSwgICAgICAgLy8gYWRkcmVzcyB0YXJnZXRDb250cmFjdFxuICAgICAgICBpc0NsYWltZWQ6IGluY2VudGl2ZVs2XSwgICAgICAgICAgICAvLyBib29sIGlzQ2xhaW1lZFxuICAgICAgICBpc0FjdGl2ZTogaW5jZW50aXZlWzddLCAgICAgICAgICAgICAvLyBib29sIGlzQWN0aXZlXG4gICAgICAgIHJlc2VydmVkOiBOdW1iZXIoaW5jZW50aXZlWzhdKSwgICAgIC8vIHVpbnQ4MCByZXNlcnZlZFxuICAgICAgICBjaGFpbklkOiBOdW1iZXIoaW5jZW50aXZlWzldKSwgICAgICAvLyB1aW50MjU2IGNoYWluSWRcbiAgICAgICAgZGVzY3JpcHRpb246IGluY2VudGl2ZVsxMF0gICAgICAgICAgLy8gc3RyaW5nIGRlc2NyaXB0aW9uXG4gICAgICB9O1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLwn5KlIEVycm9yIGdldHRpbmcgaW5jZW50aXZlIGRhdGE6XCIsIGVycm9yKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLwn5SNIEluY2VudGl2ZSBJRDpcIiwgaW5jZW50aXZlSWQpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cblxuICBhc3luYyBnZXRTcGVjc0J5Q29udHJhY3RQYWdpbmF0ZWQoXG4gICAgdGFyZ2V0Q29udHJhY3Q6IHN0cmluZyxcbiAgICBvZmZzZXQ6IG51bWJlcixcbiAgICBsaW1pdDogbnVtYmVyXG4gICk6IFByb21pc2U8eyBzcGVjSWRzOiBzdHJpbmdbXTsgdG90YWw6IG51bWJlciB9PiB7XG4gICAgaWYgKCF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkIHRvIGNvbnRyYWN0LlwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb250cmFjdC5nZXRTcGVjc0J5Q29udHJhY3RQYWdpbmF0ZWQoXG4gICAgICAgIHRhcmdldENvbnRyYWN0LFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGxpbWl0XG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3BlY0lkczogcmVzdWx0LnNwZWNJZHMsXG4gICAgICAgIHRvdGFsOiBOdW1iZXIocmVzdWx0LnRvdGFsKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBwYWdpbmF0ZWQgc3BlY3M6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFNwZWNEYXRhKHNwZWNJZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWQgdG8gY29udHJhY3QuXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG5cbiAgICAgIFxuICAgICAgLy8gQ2FsbCB0aGUgc3BlY3MgZnVuY3Rpb24gYW5kIGhhbmRsZSBwb3RlbnRpYWwgc3RydWN0dXJlIHZhcmlhdGlvbnNcbiAgICAgIGNvbnN0IHNwZWMgPSBhd2FpdCB0aGlzLmNvbnRyYWN0LnNwZWNzKHNwZWNJZCk7XG5cbiAgICAgIFxuICAgICAgLy8gVGhlIGNvbnRyYWN0IG1pZ2h0IGhhdmUgZGlmZmVyZW50IHN0cnVjdCBsYXlvdXRzLCBzbyB3ZSBuZWVkIHRvIGhhbmRsZSBib3RoIGNhc2VzXG4gICAgICAvLyBUcnkgdG8gcGFyc2UgYXNzdW1pbmcgdGhlIG5ld2VyIGZvcm1hdCB3aXRoICdyZXNlcnZlZCcgZmllbGRcbiAgICAgIGxldCBwYXJzZWRTcGVjO1xuICAgICAgXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzcGVjKSAmJiBzcGVjLmxlbmd0aCA+PSAxMSkge1xuICAgICAgICAvLyBIYW5kbGUgdHVwbGUvYXJyYXkgZm9ybWF0IC0gVXBkYXRlZCB0byBtYXRjaCBleGFjdCBjb250cmFjdCBzdHJ1Y3Qgb3JkZXJcbiAgICAgICAgcGFyc2VkU3BlYyA9IHtcbiAgICAgICAgICBjcmVhdGVkVGltZXN0YW1wOiBOdW1iZXIoc3BlY1swXSksICAgICAvLyB1aW50NjQgY3JlYXRlZFRpbWVzdGFtcFxuICAgICAgICAgIHByb3Bvc2VkVGltZXN0YW1wOiBOdW1iZXIoc3BlY1sxXSksICAgIC8vIHVpbnQ2NCBwcm9wb3NlZFRpbWVzdGFtcFxuICAgICAgICAgIHN0YXR1czogTnVtYmVyKHNwZWNbMl0pLCAgICAgICAgICAgICAgIC8vIFN0YXR1cyBlbnVtICh1aW50OClcbiAgICAgICAgICB0b3RhbEJvbmRzOiBzcGVjWzNdLnRvU3RyaW5nKCksICAgICAgICAvLyB1aW50ODAgdG90YWxCb25kc1xuICAgICAgICAgIHJlc2VydmVkOiBOdW1iZXIoc3BlY1s0XSksICAgICAgICAgICAgIC8vIHVpbnQzMiByZXNlcnZlZFxuICAgICAgICAgIGNyZWF0b3I6IHNwZWNbNV0sICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZHJlc3MgY3JlYXRvclxuICAgICAgICAgIHRhcmdldENvbnRyYWN0OiBzcGVjWzZdLCAgICAgICAgICAgICAgIC8vIGFkZHJlc3MgdGFyZ2V0Q29udHJhY3RcbiAgICAgICAgICBibG9iSGFzaDogc3BlY1s3XSwgICAgICAgICAgICAgICAgICAgICAvLyBieXRlczMyIGJsb2JIYXNoXG4gICAgICAgICAgcXVlc3Rpb25JZDogc3BlY1s4XSwgICAgICAgICAgICAgICAgICAgLy8gYnl0ZXMzMiBxdWVzdGlvbklkXG4gICAgICAgICAgaW5jZW50aXZlSWQ6IHNwZWNbOV0sICAgICAgICAgICAgICAgICAgLy8gYnl0ZXMzMiBpbmNlbnRpdmVJZFxuICAgICAgICAgIGNoYWluSWQ6IE51bWJlcihzcGVjWzEwXSkgICAgICAgICAgICAgIC8vIHVpbnQyNTYgY2hhaW5JZFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIG5hbWVkIHN0cnVjdCBmb3JtYXRcbiAgICAgICAgcGFyc2VkU3BlYyA9IHtcbiAgICAgICAgICBjcmVhdGVkVGltZXN0YW1wOiBOdW1iZXIoc3BlYy5jcmVhdGVkVGltZXN0YW1wIHx8IDApLFxuICAgICAgICAgIHByb3Bvc2VkVGltZXN0YW1wOiBOdW1iZXIoc3BlYy5wcm9wb3NlZFRpbWVzdGFtcCB8fCAwKSxcbiAgICAgICAgICBzdGF0dXM6IE51bWJlcihzcGVjLnN0YXR1cyB8fCAwKSxcbiAgICAgICAgICB0b3RhbEJvbmRzOiAoc3BlYy50b3RhbEJvbmRzIHx8IDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgcmVzZXJ2ZWQ6IE51bWJlcihzcGVjLnJlc2VydmVkIHx8IDApLFxuICAgICAgICAgIGNyZWF0b3I6IHNwZWMuY3JlYXRvciB8fCBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICAgIHRhcmdldENvbnRyYWN0OiBzcGVjLnRhcmdldENvbnRyYWN0IHx8IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgICAgYmxvYkhhc2g6IHNwZWMuYmxvYkhhc2ggfHwgXCIweFwiLFxuICAgICAgICAgIHF1ZXN0aW9uSWQ6IHNwZWMucXVlc3Rpb25JZCB8fCBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICAgIGluY2VudGl2ZUlkOiBzcGVjLmluY2VudGl2ZUlkIHx8IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgICAgY2hhaW5JZDogTnVtYmVyKHNwZWMuY2hhaW5JZCB8fCAwKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG5cbiAgICAgIHJldHVybiBwYXJzZWRTcGVjO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIvCfkqUgRXJyb3IgZ2V0dGluZyBzcGVjIGRhdGE6XCIsIGVycm9yKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLwn5OLIFNwZWNJZCB0aGF0IGZhaWxlZDpcIiwgc3BlY0lkKTtcbiAgICAgIFxuICAgICAgLy8gVHJ5IHRvIHByb3ZpZGUgbW9yZSBoZWxwZnVsIGVycm9yIGluZm9ybWF0aW9uXG4gICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoXCJjb3VsZCBub3QgZGVjb2RlIHJlc3VsdCBkYXRhXCIpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCLwn5SnIFRoaXMgbG9va3MgbGlrZSBhbiBBQkkgbWlzbWF0Y2guIFRoZSBjb250cmFjdCBzdHJ1Y3QgbWlnaHQgaGF2ZSBjaGFuZ2VkLlwiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSB0byBleHRyYWN0IHNvbWUgYmFzaWMgaW5mbyBmcm9tIHRoZSByYXcgZXJyb3IgaWYgcG9zc2libGVcbiAgICAgICAgaWYgKGVycm9yLnZhbHVlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIvCfk4ogUmF3IGNvbnRyYWN0IHJldHVybiB2YWx1ZTpcIiwgZXJyb3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlY29kZSBzcGVjaWZpY2F0aW9uIGRhdGEuIFRoaXMgbWlnaHQgYmUgZHVlIHRvIGEgY29udHJhY3QgdmVyc2lvbiBtaXNtYXRjaC4gT3JpZ2luYWwgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBwcm9wb3NlU3BlYyhzcGVjSWQ6IHN0cmluZywgYm9uZEFtb3VudDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuY29udHJhY3QgfHwgIXRoaXMuc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkIHRvIE1ldGFNYXNrLiBQbGVhc2UgY29ubmVjdCBmaXJzdC5cIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIE5ldHdvcmsgY2hlY2sgcmVtb3ZlZCAtIGxldCB1c2VycyBjb25uZWN0IG9uIGFueSBuZXR3b3JrXG5cbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5jb250cmFjdC5wcm9wb3NlU3BlYyhzcGVjSWQsIHsgdmFsdWU6IGJvbmRBbW91bnQgfSk7XG4gICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xuXG4gICAgICByZXR1cm4gdHguaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcHJvcG9zaW5nIHNwZWM6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGFzc2VydFNwZWNWYWxpZChzcGVjSWQ6IHN0cmluZywgYm9uZEFtb3VudDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuY29udHJhY3QgfHwgIXRoaXMuc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkIHRvIE1ldGFNYXNrLiBQbGVhc2UgY29ubmVjdCBmaXJzdC5cIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIE5ldHdvcmsgY2hlY2sgcmVtb3ZlZCAtIGxldCB1c2VycyBjb25uZWN0IG9uIGFueSBuZXR3b3JrXG5cbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5jb250cmFjdC5hc3NlcnRTcGVjVmFsaWQoc3BlY0lkLCB7IHZhbHVlOiBib25kQW1vdW50IH0pO1xuICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcblxuICAgICAgcmV0dXJuIHR4Lmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFzc2VydGluZyBzcGVjIHZhbGlkOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBhc3NlcnRTcGVjSW52YWxpZChzcGVjSWQ6IHN0cmluZywgYm9uZEFtb3VudDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuY29udHJhY3QgfHwgIXRoaXMuc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkIHRvIE1ldGFNYXNrLiBQbGVhc2UgY29ubmVjdCBmaXJzdC5cIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIE5ldHdvcmsgY2hlY2sgcmVtb3ZlZCAtIGxldCB1c2VycyBjb25uZWN0IG9uIGFueSBuZXR3b3JrXG5cbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5jb250cmFjdC5hc3NlcnRTcGVjSW52YWxpZChzcGVjSWQsIHsgdmFsdWU6IGJvbmRBbW91bnQgfSk7XG4gICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xuXG4gICAgICByZXR1cm4gdHguaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYXNzZXJ0aW5nIHNwZWMgaW52YWxpZDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaGFuZGxlUmVzdWx0KHNwZWNJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuY29udHJhY3QgfHwgIXRoaXMuc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkIHRvIE1ldGFNYXNrLiBQbGVhc2UgY29ubmVjdCBmaXJzdC5cIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcblxuICAgICAgXG4gICAgICAvLyBGaXJzdCBjaGVjayB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIHNwZWNcbiAgICAgIGNvbnN0IHNwZWNEYXRhID0gYXdhaXQgdGhpcy5jb250cmFjdC5zcGVjcyhzcGVjSWQpO1xuXG5cbiAgICAgIFxuICAgICAgLy8gU3RhdHVzOiAwPUNvbW1pdHRlZCwgMT1TdWJtaXR0ZWQsIDI9UHJvcG9zZWQsIDM9RmluYWxpemVkLCA0PUNhbmNlbGxlZFxuICAgICAgaWYgKE51bWJlcihzcGVjRGF0YS5zdGF0dXMpID09PSAzKSB7XG4gICAgICAgIC8vIFNwZWMgaXMgYWxyZWFkeSBmaW5hbGl6ZWQsIGJ1dCBpbmNlbnRpdmVzIG1pZ2h0IG5vdCBiZSBjbGFpbWVkXG4gICAgICAgIC8vIExldCdzIHRyeSB0byBjbGFpbSBFVEggaW5jZW50aXZlcyBtYW51YWxseSBpZiB0aGV5IGV4aXN0XG5cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhdmFpbGFibGUgRVRIIGluY2VudGl2ZXMgZm9yIHRoaXMgc3BlYydzIHRhcmdldCBjb250cmFjdFxuICAgICAgICBjb25zdCBhdmFpbGFibGVJbmNlbnRpdmVzID0gYXdhaXQgdGhpcy5nZXRBdmFpbGFibGVJbmNlbnRpdmVzKHNwZWNEYXRhLnRhcmdldENvbnRyYWN0LCBOdW1iZXIoc3BlY0RhdGEuY2hhaW5JZCkpO1xuXG4gICAgICAgIFxuICAgICAgICBjb25zdCBldGhJbmNlbnRpdmVzID0gYXZhaWxhYmxlSW5jZW50aXZlcy5maWx0ZXIoaW5jID0+IFxuICAgICAgICAgIGluYy50b2tlbiA9PT0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiAmJiBcbiAgICAgICAgICAhaW5jLmlzQ2xhaW1lZCAmJiBcbiAgICAgICAgICBpbmMuaXNBY3RpdmVcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChldGhJbmNlbnRpdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBUaGVyZSBhcmUgdW5jbGFpbWVkIEVUSCBpbmNlbnRpdmVzIC0gdGhlIHNwZWMgbWlnaHQgaGF2ZSBiZWVuIGZpbmFsaXplZCB3aXRob3V0IHByb2Nlc3NpbmcgaW5jZW50aXZlc1xuICAgICAgICAgIC8vIFRoaXMgY291bGQgaGFwcGVuIGlmIGhhbmRsZVJlc3VsdCB3YXMgbmV2ZXIgY2FsbGVkIG9yIGZhaWxlZCBwYXJ0aWFsbHlcblxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSBjYWxsaW5nIGhhbmRsZVJlc3VsdCBhbnl3YXkgLSBpdCBtaWdodCB3b3JrIGlmIHRoZSBSZWFsaXR5LmV0aCBxdWVzdGlvbiBuZWVkcyBwcm9jZXNzaW5nXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5jb250cmFjdC5oYW5kbGVSZXN1bHQoc3BlY0lkKTtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0eC5oYXNoO1xuICAgICAgICAgIH0gY2F0Y2ggKGhhbmRsZUVycm9yOiBhbnkpIHtcblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3BlY2lmaWNhdGlvbiBpcyBmaW5hbGl6ZWQgYnV0IGluY2VudGl2ZXMgd2VyZW4ndCBjbGFpbWVkIGF1dG9tYXRpY2FsbHkuIFRoaXMgbWF5IHJlcXVpcmUgY29udHJhY3QgYWRtaW4gaW50ZXJ2ZW50aW9uIG9yIHRoZSBpbmNlbnRpdmVzIG1heSBoYXZlIGV4cGlyZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcGVjaWZpY2F0aW9uIGlzIGFscmVhZHkgZmluYWxpemVkIGFuZCBubyB1bmNsYWltZWQgRVRIIGluY2VudGl2ZXMgZm91bmQuIENoZWNrIGlmIGluY2VudGl2ZXMgd2VyZSBhbHJlYWR5IGNsYWltZWQgb3IgdXNlIGNsYWltQWN0aXZlVG9rZW5JbmNlbnRpdmUgZm9yIEVSQzIwIHRva2Vucy5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoTnVtYmVyKHNwZWNEYXRhLnN0YXR1cykgIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaGFuZGxlIHJlc3VsdCBmb3Igc3BlYyBpbiBzdGF0dXMgJHtzcGVjRGF0YS5zdGF0dXN9LiBTcGVjIG11c3QgYmUgUHJvcG9zZWQgKHN0YXR1cyAyKS5gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmhhbmRsZVJlc3VsdChzcGVjSWQpO1xuICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcblxuICAgICAgcmV0dXJuIHR4Lmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGhhbmRsaW5nIHJlc3VsdDpcIiwgZXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBEZWNvZGUgc3BlY2lmaWMgY29udHJhY3QgZXJyb3JzXG4gICAgICBpZiAoZXJyb3IuZGF0YSA9PT0gXCIweGYyYTg3ZDVlXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90UHJvcG9zZWQ6IFNwZWNpZmljYXRpb24gaXMgbm90IGluIFByb3Bvc2VkIHN0YXR1cy4gSXQgbWF5IGFscmVhZHkgYmUgZmluYWxpemVkLlwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IuZGF0YSA9PT0gXCIweDFiZWUwZDVhXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90RmluYWxpemVkOiBSZWFsaXR5LmV0aCBxdWVzdGlvbiBpcyBub3QgeWV0IGZpbmFsaXplZC4gV2FpdCBmb3IgdGhlIHRpbWVvdXQgcGVyaW9kLlwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2V0dGxlQm9uZHMoc3BlY0lkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICghdGhpcy5jb250cmFjdCB8fCAhdGhpcy5zaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWQgdG8gTWV0YU1hc2suIFBsZWFzZSBjb25uZWN0IGZpcnN0LlwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuXG4gICAgICBcbiAgICAgIC8vIENoZWNrIHNwZWMgc3RhdHVzIGZpcnN0XG4gICAgICBjb25zdCBzcGVjRGF0YSA9IGF3YWl0IHRoaXMuY29udHJhY3Quc3BlY3Moc3BlY0lkKTtcblxuXG5cbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgcmVxdWlyZW1lbnRzIGJlZm9yZSBhdHRlbXB0aW5nIHNldHRsZW1lbnRcbiAgICAgIGlmIChOdW1iZXIoc3BlY0RhdGEuc3RhdHVzKSAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzZXR0bGUgYm9uZHM6IFNwZWNpZmljYXRpb24gbXVzdCBiZSBmaW5hbGl6ZWQgKHN0YXR1cyAzKSwgYnV0IGN1cnJlbnQgc3RhdHVzIGlzICR7TnVtYmVyKHNwZWNEYXRhLnN0YXR1cyl9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChzcGVjRGF0YS5ib25kc1NldHRsZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldHRsZSBib25kczogQm9uZHMgaGF2ZSBhbHJlYWR5IGJlZW4gc2V0dGxlZCBmb3IgdGhpcyBzcGVjaWZpY2F0aW9uXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBSZWFsaXR5LmV0aCBxdWVzdGlvbiBzdGF0dXNcbiAgICAgIGNvbnN0IHF1ZXN0aW9uSWQgPSBzcGVjRGF0YS5xdWVzdGlvbklkO1xuXG4gICAgICBcbiAgICAgIC8vIElNUE9SVEFOVDogRG91YmxlLWNoZWNrIGJ5IGNhbGxpbmcgdGhlIGNvbnRyYWN0J3MgYm9uZHNTZXR0bGVkIG1hcHBpbmcgZGlyZWN0bHlcbiAgICAgIC8vIFRoaXMgbWlnaHQgYmUgZGlmZmVyZW50IGZyb20gdGhlIHNwZWMgc3RydWN0IHZhbHVlXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGUgY29udHJhY3QgbWlnaHQgaGF2ZSBhIGJvbmRzU2V0dGxlZCBtYXBwaW5nIHRoYXQncyBzZXBhcmF0ZSBmcm9tIHRoZSBzdHJ1Y3RcbiAgICAgICAgLy8gTGV0IG1lIHRyeSBhIGRpZmZlcmVudCBhcHByb2FjaCAtIGNoZWNrIHRoZSBBQkkgZm9yIGF2YWlsYWJsZSB2aWV3IGZ1bmN0aW9uc1xuXG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udHJhY3QgaGFzIGFueSBvdGhlciBzdGF0ZSB3ZSBuZWVkIHRvIHZlcmlmeVxuXG5cblxuICAgICAgICBcbiAgICAgICAgLy8gQ1JJVElDQUw6IENoZWNrIHRoZSBib25kc1NldHRsZWQgbWFwcGluZyBkaXJlY3RseVxuICAgICAgICBjb25zdCBtYXBwaW5nU2V0dGxlZCA9IGF3YWl0IHRoaXMuY29udHJhY3QuYm9uZHNTZXR0bGVkKHNwZWNJZCk7XG5cblxuICAgICAgICBcbiAgICAgICAgaWYgKG1hcHBpbmdTZXR0bGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldHRsZSBib25kczogVGhlIGJvbmRzU2V0dGxlZCBtYXBwaW5nIHNob3dzIGJvbmRzIGFyZSBhbHJlYWR5IHNldHRsZWQsIGV2ZW4gdGhvdWdoIHRoZSBzcGVjIHN0cnVjdCBzYXlzIGZhbHNlLiBUaGlzIGluZGljYXRlcyB0aGUgYm9uZHMgd2VyZSBhbHJlYWR5IHByb2Nlc3NlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChzdGF0ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjaGVja2luZyBhZGRpdGlvbmFsIHN0YXRlOlwiLCBzdGF0ZUVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHF1ZXN0aW9uSWQgPT09IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldHRsZSBib25kczogTm8gUmVhbGl0eS5ldGggcXVlc3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3BlY2lmaWNhdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVHJ5IHRvIGdldCBSZWFsaXR5LmV0aCBjb250cmFjdCBhbmQgY2hlY2sgaWYgcXVlc3Rpb24gaXMgZmluYWxpemVkXG4gICAgICB0cnkge1xuICAgICAgICAvLyBTa2lwIFJlYWxpdHkuZXRoIGNvbnRyYWN0IGluaXRpYWxpemF0aW9uIGZvciBub3dcbiAgICAgICAgY29uc29sZS5sb2coXCLinJMgU2tpcHBpbmcgUmVhbGl0eS5ldGggY29udHJhY3QgaW5pdGlhbGl6YXRpb25cIik7XG5cbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBSZWFsaXR5LmV0aCBjb250cmFjdCBpbnN0YW5jZVxuICAgICAgICBjb25zdCByZWFsaXR5RXRoQWJpID0gW1xuICAgICAgICAgIFwiZnVuY3Rpb24gaXNGaW5hbGl6ZWQoYnl0ZXMzMiBxdWVzdGlvbl9pZCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChib29sKVwiLFxuICAgICAgICAgIFwiZnVuY3Rpb24gcmVzdWx0Rm9yKGJ5dGVzMzIgcXVlc3Rpb25faWQpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYnl0ZXMzMilcIlxuICAgICAgICBdO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVhbGl0eUV0aENvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChyZWFsaXR5RXRoQWRkcmVzcywgcmVhbGl0eUV0aEFiaSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBpc0ZpbmFsaXplZCA9IGF3YWl0IHJlYWxpdHlFdGhDb250cmFjdC5pc0ZpbmFsaXplZChxdWVzdGlvbklkKTtcblxuICAgICAgICBcbiAgICAgICAgaWYgKGlzRmluYWxpemVkKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhbGl0eUV0aENvbnRyYWN0LnJlc3VsdEZvcihxdWVzdGlvbklkKTtcblxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAocmVhbGl0eUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjaGVja2luZyBSZWFsaXR5LmV0aCBzdGF0dXM6XCIsIHJlYWxpdHlFcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGNvbnRyYWN0IGhhcyBlbm91Z2ggYmFsYW5jZSB0byBwYXkgb3V0IGJvbmRzIChhbHdheXMgcnVuIHRoaXMpXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBrYWlzaWduQ29udHJhY3RBZGRyZXNzID0gXCIweDRkRkVBMEMyQjQ3MmExNGNEMDUyYThmOURGOWYxOWZhNUNGMDM3MTlcIjtcbiAgICAgICAgY29uc3QgY29udHJhY3RCYWxhbmNlID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCYWxhbmNlKGthaXNpZ25Db250cmFjdEFkZHJlc3MpO1xuXG5cblxuICAgICAgICBcbiAgICAgICAgaWYgKGNvbnRyYWN0QmFsYW5jZSA8IHNwZWNEYXRhLnRvdGFsQm9uZHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYPCfmqggQ09OVFJBQ1QgSU5TVUZGSUNJRU5UIEZVTkRTOiBDb250cmFjdCBiYWxhbmNlOiAke2V0aGVycy5mb3JtYXRFdGhlcihjb250cmFjdEJhbGFuY2UpfSBFVEgsIFJlcXVpcmVkOiAke2V0aGVycy5mb3JtYXRFdGhlcihzcGVjRGF0YS50b3RhbEJvbmRzKX0gRVRIYCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGJhbGFuY2VFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2hlY2tpbmcgY29udHJhY3QgYmFsYW5jZTpcIiwgYmFsYW5jZUVycm9yKTtcbiAgICAgICAgdGhyb3cgYmFsYW5jZUVycm9yO1xuICAgICAgfVxuXG4gICAgICAvLyBUcnkgd2l0aCBtYW51YWwgZ2FzIGVzdGltYXRpb24gdG8gYXZvaWQgZXN0aW1hdGlvbiBlcnJvcnNcblxuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBnYXNFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuY29udHJhY3Quc2V0dGxlQm9uZHMuZXN0aW1hdGVHYXMoc3BlY0lkKTtcblxuICAgICAgICBcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmNvbnRyYWN0LnNldHRsZUJvbmRzKHNwZWNJZCwge1xuICAgICAgICAgIGdhc0xpbWl0OiBnYXNFc3RpbWF0ZSArIEJpZ0ludCg1MDAwMCkgLy8gQWRkIGJ1ZmZlclxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcblxuICAgICAgICByZXR1cm4gdHguaGFzaDtcbiAgICAgIH0gY2F0Y2ggKGdhc0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJHYXMgZXN0aW1hdGlvbiBmYWlsZWQsIHRyeWluZyB3aXRoIGZpeGVkIGdhczpcIiwgZ2FzRXJyb3IpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHdpdGggYSBmaXhlZCBnYXMgbGltaXRcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmNvbnRyYWN0LnNldHRsZUJvbmRzKHNwZWNJZCwge1xuICAgICAgICAgIGdhc0xpbWl0OiBCaWdJbnQoMjAwMDAwKSAvLyBGaXhlZCBnYXMgbGltaXRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG5cbiAgICAgICAgcmV0dXJuIHR4Lmhhc2g7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNldHRsaW5nIGJvbmRzOlwiLCBlcnJvcik7XG4gICAgICBcbiAgICAgIC8vIERlY29kZSBzcGVjaWZpYyBjb250cmFjdCBlcnJvcnMgZm9yIHNldHRsZUJvbmRzXG4gICAgICBpZiAoZXJyb3IuZGF0YSA9PT0gXCIweDFiZWUwZDVhXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90RmluYWxpemVkOiBTcGVjaWZpY2F0aW9uIG11c3QgYmUgZmluYWxpemVkIGJlZm9yZSBzZXR0bGluZyBib25kcy5cIik7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yLmRhdGEgPT09IFwiMHgyY2IxNTkzOFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHlTZXR0bGVkOiBCb25kcyBmb3IgdGhpcyBzcGVjaWZpY2F0aW9uIGhhdmUgYWxyZWFkeSBiZWVuIHNldHRsZWQuXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBpdCdzIGEgZ2VuZXJpYyByZXZlcnRcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiZXhlY3V0aW9uIHJldmVydGVkXCIpICYmICFlcnJvci5kYXRhKSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgbW9yZSBpbmZvIGFib3V0IHdoeSBpdCBmYWlsZWRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCb25kIHNldHRsZW1lbnQgZmFpbGVkLiBUaGlzIGNvdWxkIGJlIGJlY2F1c2U6IDEpIFNwZWNpZmljYXRpb24gaXMgbm90IGZpbmFsaXplZCwgMikgQm9uZHMgYWxyZWFkeSBzZXR0bGVkLCAzKSBZb3UncmUgbm90IGF1dGhvcml6ZWQgdG8gc2V0dGxlLCBvciA0KSBDb250cmFjdCBzdGF0ZSBpc3N1ZS4gU3BlYyBJRDogJHtzcGVjSWR9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldEN1cnJlbnRBY2NvdW50KCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5wcm92aWRlci5saXN0QWNjb3VudHMoKTtcbiAgICAgIHJldHVybiBhY2NvdW50cy5sZW5ndGggPiAwID8gYWNjb3VudHNbMF0/LmFkZHJlc3MgfHwgbnVsbCA6IG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIGN1cnJlbnQgYWNjb3VudDpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0Q29udHJhY3RTcGVjQ291bnQodGFyZ2V0Q29udHJhY3Q6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgaWYgKCF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkIHRvIGNvbnRyYWN0LlwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY291bnQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmdldENvbnRyYWN0U3BlY0NvdW50KHRhcmdldENvbnRyYWN0KTtcbiAgICAgIHJldHVybiBOdW1iZXIoY291bnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIGNvbnRyYWN0IHNwZWMgY291bnQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldEF2YWlsYWJsZUluY2VudGl2ZXModGFyZ2V0Q29udHJhY3Q6IHN0cmluZywgdGFyZ2V0Q2hhaW5JZD86IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWQgdG8gY29udHJhY3QuXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBpbmNlbnRpdmVzID0gW107XG4gICAgICBcbiAgICAgIC8vIEdldCByZWFsIGluY2VudGl2ZXMgZnJvbSBjb250cmFjdCBldmVudHNcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuY29udHJhY3QuZmlsdGVycy5Mb2dJbmNlbnRpdmVDcmVhdGVkKG51bGwsIG51bGwsIHRhcmdldENvbnRyYWN0KTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gYXdhaXQgdGhpcy5jb250cmFjdC5xdWVyeUZpbHRlcihmaWx0ZXIsIC0xMDAwMCk7IC8vIExhc3QgMTBrIGJsb2Nrc1xuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgICBjb25zdCBpbmNlbnRpdmVJZCA9IGV2ZW50LmFyZ3M/LmluY2VudGl2ZUlkO1xuICAgICAgICAgIGlmIChpbmNlbnRpdmVJZCkge1xuICAgICAgICAgICAgY29uc3QgaW5jZW50aXZlRGF0YSA9IGF3YWl0IHRoaXMuY29udHJhY3QuaW5jZW50aXZlcyhpbmNlbnRpdmVJZCk7XG4gICAgICAgICAgICAvLyBPbmx5IGluY2x1ZGUgaW5jZW50aXZlcyB0aGF0IGV4YWN0bHkgbWF0Y2ggdGhlIHRhcmdldCBjaGFpbiBJRFxuICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBjcm9zcy1jaGFpbiBpbmNlbnRpdmUgY29uZnVzaW9uXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGluY2VudGl2ZURhdGEuaXNBY3RpdmUgJiZcbiAgICAgICAgICAgICAgIWluY2VudGl2ZURhdGEuaXNDbGFpbWVkICYmXG4gICAgICAgICAgICAgICh0YXJnZXRDaGFpbklkID09PSB1bmRlZmluZWQgfHwgaW5jZW50aXZlRGF0YS5jaGFpbklkLnRvU3RyaW5nKCkgPT09IHRhcmdldENoYWluSWQudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpbmNlbnRpdmVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBpbmNlbnRpdmVJZCxcbiAgICAgICAgICAgICAgICBjcmVhdG9yOiBpbmNlbnRpdmVEYXRhLmNyZWF0b3IsXG4gICAgICAgICAgICAgICAgdG9rZW46IGluY2VudGl2ZURhdGEudG9rZW4sXG4gICAgICAgICAgICAgICAgYW1vdW50OlxuICAgICAgICAgICAgICAgICAgaW5jZW50aXZlRGF0YS50b2tlbiA9PT1cbiAgICAgICAgICAgICAgICAgIFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJcbiAgICAgICAgICAgICAgICAgICAgPyAoTnVtYmVyKGluY2VudGl2ZURhdGEuYW1vdW50KSAvIDFlMTgpLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgOiBpbmNlbnRpdmVEYXRhLmFtb3VudC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRlYWRsaW5lOiBOdW1iZXIoaW5jZW50aXZlRGF0YS5kZWFkbGluZSksXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGluY2VudGl2ZURhdGEuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgaXNBY3RpdmU6IGluY2VudGl2ZURhdGEuaXNBY3RpdmUsXG4gICAgICAgICAgICAgICAgaXNDbGFpbWVkOiBpbmNlbnRpdmVEYXRhLmlzQ2xhaW1lZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGV2ZW50RXJyb3IpIHtcblxuICAgICAgfVxuICAgICAgXG5cbiAgICAgIHJldHVybiBpbmNlbnRpdmVzO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIGF2YWlsYWJsZSBpbmNlbnRpdmVzOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRJbmNlbnRpdmVzQnlUYXJnZXRDb250cmFjdCh0YXJnZXRDb250cmFjdDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbm5lY3RlZCB0byBjb250cmFjdC5cIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoaXMgd291bGQgcmVxdWlyZSBldmVudCBmaWx0ZXJpbmcgb3IgYSBzdWJncmFwaFxuICAgICAgLy8gRm9yIG5vdywgcmV0dXJuaW5nIGVtcHR5IGFycmF5IGFzIHBsYWNlaG9sZGVyXG4gICAgICBjb25zb2xlLndhcm4oXCJnZXRJbmNlbnRpdmVzQnlUYXJnZXRDb250cmFjdDogVGhpcyBmdW5jdGlvbiBuZWVkcyBldmVudCBmaWx0ZXJpbmcgaW1wbGVtZW50YXRpb25cIik7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgaW5jZW50aXZlcyBieSB0YXJnZXQgY29udHJhY3Q6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNsYWltQWN0aXZlVG9rZW5JbmNlbnRpdmUoc3BlY0lkOiBzdHJpbmcsIHRva2VuQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWQgdG8gY29udHJhY3QuXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG5cbiAgICAgIFxuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmNsYWltQWN0aXZlVG9rZW5JbmNlbnRpdmUoc3BlY0lkLCB0b2tlbkFkZHJlc3MpO1xuXG4gICAgICBcbiAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG5cbiAgICAgIFxuICAgICAgcmV0dXJuIHR4Lmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNsYWltaW5nIGFjdGl2ZSB0b2tlbiBpbmNlbnRpdmU6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjbGFpbSBFVEggaW5jZW50aXZlcyBtYW51YWxseVxuICBhc3luYyBjbGFpbUVUSEluY2VudGl2ZShzcGVjSWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkIHRvIGNvbnRyYWN0LlwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuXG4gICAgICBcbiAgICAgIC8vIEVUSCB0b2tlbiBhZGRyZXNzIGlzIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFxuICAgICAgY29uc3QgZXRoQWRkcmVzcyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gICAgICBcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5jb250cmFjdC5jbGFpbUFjdGl2ZVRva2VuSW5jZW50aXZlKHNwZWNJZCwgZXRoQWRkcmVzcyk7XG5cbiAgICAgIFxuICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcblxuICAgICAgXG4gICAgICByZXR1cm4gdHguaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2xhaW1pbmcgRVRIIGluY2VudGl2ZTpcIiwgZXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBJZiBjbGFpbUFjdGl2ZVRva2VuSW5jZW50aXZlIGZhaWxzIGZvciBFVEgsIHRyeSBoYW5kbGVSZXN1bHQgYXMgZmFsbGJhY2tcbiAgICAgIGlmIChlcnJvci5kYXRhID09PSBcIjB4MmI0ZmEzNjBcIikgeyAvLyBJbnZhbGlkQ29udHJhY3QoKSAtIGNsYWltQWN0aXZlVG9rZW5JbmNlbnRpdmUgcmVqZWN0cyBFVEhcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5oYW5kbGVSZXN1bHQoc3BlY0lkKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBhIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IHdlYjNTZXJ2aWNlID0gbmV3IFdlYjNTZXJ2aWNlKCk7ICJdLCJuYW1lcyI6WyJldGhlcnMiLCJDT05UUkFDVF9BQkkiLCJSRUFMSVRZX0VUSF9BQkkiLCJSRUFMSVRZX0VUSF9BRERSRVNTIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1JFQUxJVFlfRVRIX0FERFJFU1MiLCJSQVdfQ09OVFJBQ1RfQUREUkVTUyIsIk5FWFRfUFVCTElDX0tBSVNJR05fQ09OVFJBQ1RfQUREUkVTUyIsIlNFUE9MSUFfQ0hBSU5fSUQiLCJOdW1iZXIiLCJORVhUX1BVQkxJQ19DSEFJTl9JRCIsIldlYjNTZXJ2aWNlIiwiY29ubmVjdCIsIkVycm9yIiwid2luZG93IiwiZXRoZXJldW0iLCJhY2NvdW50cyIsInJlcXVlc3QiLCJtZXRob2QiLCJsZW5ndGgiLCJwcm92aWRlciIsIkJyb3dzZXJQcm92aWRlciIsInNpZ25lciIsImdldFNpZ25lciIsImthaXNpZ25Db250cmFjdCIsIkNvbnRyYWN0IiwiY29udHJhY3QiLCJyZWFsaXR5RXRoQ29udHJhY3QiLCJlcnJvciIsImNvbnNvbGUiLCJjaGVja05ldHdvcmsiLCJuZXR3b3JrIiwiZ2V0TmV0d29yayIsImNoYWluSWQiLCJnZXRNaW5Cb25kIiwibWluQm9uZCIsImZhbGxiYWNrQm9uZCIsIkJpZ0ludCIsImdldFJlcXVpcmVkQm9uZEZvclF1ZXN0aW9uIiwicXVlc3Rpb25JZCIsImN1cnJlbnRCb25kIiwiZ2V0Qm9uZCIsInJlcXVpcmVkQm9uZCIsImdldEJvbmRJbmZvIiwiaXBmc0hhc2giLCJzcGVjSWQiLCJrZWNjYWsyNTYiLCJ0b1V0ZjhCeXRlcyIsInNwZWMiLCJzcGVjcyIsImNvbnRyYWN0TWluQm9uZCIsInJlcXVpcmVkTmV4dEJvbmQiLCJoYXNBbnN3ZXJzIiwiYmFzZVJlcXVpcmVkQm9uZCIsInNwZWNFcnJvciIsImNvbW1pdFNwZWMiLCJibG9iSGFzaCIsImJvbmRBbW91bnQiLCJ0YXJnZXRDb250cmFjdCIsInRhcmdldENoYWluSWQiLCJub25jZSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsIm1ldGFkYXRhSGFzaCIsImNvbW1pdG1lbnQiLCJzb2xpZGl0eVBhY2tlZCIsInRhcmdldCIsInZhbGlkU2Vwb2xpYUNvbnRyYWN0cyIsInRyaW0iLCJtYXRjaCIsInRhcmdldENvZGUiLCJnZXRDb2RlIiwid2FybiIsImNvZGVDaGVja0Vycm9yIiwiZmluYWxJbmNlbnRpdmVJZCIsInRvRml4ZWQiLCJydW5QcmVUcmFuc2FjdGlvbkRpYWdub3N0aWNzIiwiY29udHJhY3RDb2RlIiwidGVzdE1pbkJvbmQiLCJwYXVzZWRDYWxsIiwiY2FsbCIsInRvIiwiZGF0YSIsImlzUGF1c2VkIiwicGF1c2VDaGVja0Vycm9yIiwidGFyZ2V0Q29udHJhY3RDb2RlIiwidHJlYXN1cnlTZWxlY3RvciIsInRyZWFzdXJ5UmVzdWx0IiwidHJlYXN1cnlBZGRyZXNzIiwic2xpY2UiLCJ0cmVhc3VyeUNvZGUiLCJ0ZXN0QW1vdW50IiwidmFsdWUiLCJmcm9tIiwiZ2V0QWRkcmVzcyIsInRyZWFzdXJ5VGVzdEVycm9yIiwidHJlYXN1cnlFcnJvciIsImNvbnRyYWN0RXJyb3IiLCJjb21taXRtZW50SWQiLCJEYXRlIiwibm93IiwiZXhpc3RpbmdDb21taXRtZW50IiwiY29tbWl0bWVudHMiLCJsb2ciLCJjb21taXR0ZXIiLCJaZXJvQWRkcmVzcyIsInN0YXRpY1Jlc3VsdCIsInN0YXRpY0NhbGwiLCJjaGVja0Vycm9yIiwibWVzc2FnZSIsImdhc0VzdGltYXRlIiwiZXN0aW1hdGVHYXMiLCJnYXNFcnJvciIsImNvbW1pdFR4IiwiY29tbWl0UmVjZWlwdCIsIndhaXQiLCJsb2dzIiwicGFyc2VkIiwiaW50ZXJmYWNlIiwicGFyc2VMb2ciLCJuYW1lIiwiYXJncyIsImUiLCJjb21taXRUeEhhc2giLCJoYXNoIiwicmV2ZWFsRGVhZGxpbmUiLCJpbmNsdWRlcyIsImtub3duR29vZENvbnRyYWN0cyIsInRlc3RUYXJnZXQiLCJ0ZXN0Q29kZSIsImRpcmVjdENvbW1pdFJldmVhbCIsInRlc3RFcnJvciIsImRpcmVjdEVycm9yIiwicmVhc29uIiwiZXJyb3JTaWduYXR1cmVzIiwiZXJyb3JTZWxlY3RvciIsImN1c3RvbUVycm9yIiwiZGVjb2RlRXJyb3IiLCJyZXZlYWxTcGVjIiwidG9TdHJpbmciLCJzdG9yZWRDb21taXRtZW50IiwiY29tbWl0VGltZXN0YW1wIiwicmVzZXJ2ZWQxIiwiaXNSZXZlYWxlZCIsInJlc2VydmVkIiwiaW5jZW50aXZlSWQiLCJvdXJBZGRyZXNzIiwiY3VycmVudFRpbWUiLCJleHBlY3RlZENvbW1pdG1lbnQiLCJyZWNvbnN0cnVjdGVkQ29tbWl0bWVudElkIiwiZGVidWdFcnJvciIsInN0YXRpY0Vycm9yIiwicmV2ZWFsVHgiLCJyZXZlYWxSZWNlaXB0Iiwic3VibWl0U3BlYyIsImNvbW1pdFJlc3VsdCIsImdldFF1ZXN0aW9uSWQiLCJnZXRTcGVjU3RhdHVzIiwic3RhdHVzIiwiZ2V0U3RhdHVzIiwiaXNTcGVjQWNjZXB0ZWQiLCJpc0FjY2VwdGVkIiwiaGFuZGxlUmVzdWx0IiwidHgiLCJyZWNlaXB0IiwiZ2V0SVBGU0J5SGFzaCIsInNwZWNJRCIsImlwZnMiLCJjcmVhdGVJbmNlbnRpdmUiLCJhbW91bnQiLCJkdXJhdGlvbiIsImRlc2NyaXB0aW9uIiwiZ2V0U3BlY3NCeUNvbnRyYWN0IiwiY29udHJhY3RBZGRyZXNzIiwic3BlY0lkcyIsImdldEFsbFVzZXJTcGVjc0J5RXZlbnRzIiwidXNlckFkZHJlc3MiLCJjdXJyZW50QmxvY2siLCJnZXRCbG9ja051bWJlciIsImZyb21CbG9jayIsIm1heCIsImZpbHRlciIsImZpbHRlcnMiLCJTcGVjUmV2ZWFsZWQiLCJldmVudHMiLCJxdWVyeUZpbHRlciIsInVzZXJTcGVjcyIsImV2ZW50IiwicHVzaCIsImxvZ1JldmVhbEZpbHRlciIsIkxvZ1JldmVhbFNwZWMiLCJsb2dSZXZlYWxFdmVudHMiLCJsb2dFcnJvciIsImdldENvbnRyYWN0U3BlY0NvdW50IiwiY291bnQiLCJuZXR3b3JrQ2hhaW5JZCIsIl8iLCJmdW5jdGlvblNlbGVjdG9yIiwiaWQiLCJlbmNvZGVkUGFyYW1zIiwiY29uY2F0IiwiemVyb1BhZFZhbHVlIiwidG9CZUhleCIsInR4RGF0YSIsInNlbmRUcmFuc2FjdGlvbiIsImdhc0xpbWl0IiwiYmxvY2tUYWciLCJibG9ja051bWJlciIsImNhbGxFcnJvciIsImVycm9yTWFwcGluZ3MiLCJmb3JFYWNoIiwic2VsZWN0b3IiLCJiYWxhbmNlIiwiZ2V0QmFsYW5jZSIsImZvcm1hdEV0aGVyIiwicGF1c2VkUmVzdWx0IiwicGF1c2VFcnJvciIsInRyZWFzdXJ5IiwicGxhdGZvcm1GZWUiLCJuZXRCb25kQW1vdW50IiwicmVxdWlyZWRUb3RhbCIsInJlYWxpdHlFcnJvciIsInRlc3RDb21taXRtZW50Iiwia25vd25FcnJvciIsImZpbmQiLCJhbmFseXplQ29udHJhY3QiLCJjb2RlIiwic2VsZWN0b3JzIiwiZnVuY05hbWUiLCJPYmplY3QiLCJlbnRyaWVzIiwicmVzdWx0IiwicmVwZWF0IiwiZW5jb2RlZENhbGwiLCJjb21taXRFcnJvciIsImtub3duRXJyb3JzIiwiaWRlbnRpZnlEZXBsb3llZENvbnRyYWN0IiwidGVzdHMiLCJ0ZXN0IiwicmVzdWx0cyIsImhhc0NvbW1pdFNwZWMiLCJoYXNDcmVhdGVTcGVjIiwiaGFzUGF1c2VkIiwiaGFzTWluQm9uZCIsImhhc1JlYWxpdHlFVEgiLCJfX0tBSVNJR05fQ09OVFJBQ1RfVFlQRSIsInRlc3RDb250cmFjdCIsImFkbWluUm9sZVJlc3VsdCIsInRpbWVvdXRSZXN1bHQiLCJ2MUNoZWNrRXJyb3IiLCJoYXNBZG1pblJvbGUiLCJyb2xlRXJyb3IiLCJjb21taXRTcGVjU2VsZWN0b3IiLCJ0ZXN0Q2FsbGRhdGEiLCJ0ZXN0Q2FsbCIsInNlbGVjdG9yRXJyb3IiLCJ0ZXN0SXBmcyIsInRlc3ROb25jZSIsImR1cmF0aW9uU2Vjb25kcyIsInRva2VuIiwiaW5kZXgiLCJnZXRVc2VySW5jZW50aXZlcyIsImNvbm5lY3RFcnJvciIsImluY2VudGl2ZUlkcyIsImlkcyIsIkFycmF5IiwiaW5mbyIsImdldEluY2VudGl2ZURhdGEiLCJpbmNlbnRpdmUiLCJpbmNlbnRpdmVzIiwiY3JlYXRvciIsImRlYWRsaW5lIiwiY3JlYXRlZEF0IiwiaXNDbGFpbWVkIiwiaXNBY3RpdmUiLCJnZXRTcGVjc0J5Q29udHJhY3RQYWdpbmF0ZWQiLCJvZmZzZXQiLCJsaW1pdCIsInRvdGFsIiwiZ2V0U3BlY0RhdGEiLCJwYXJzZWRTcGVjIiwiaXNBcnJheSIsImNyZWF0ZWRUaW1lc3RhbXAiLCJwcm9wb3NlZFRpbWVzdGFtcCIsInRvdGFsQm9uZHMiLCJwcm9wb3NlU3BlYyIsImFzc2VydFNwZWNWYWxpZCIsImFzc2VydFNwZWNJbnZhbGlkIiwic3BlY0RhdGEiLCJhdmFpbGFibGVJbmNlbnRpdmVzIiwiZ2V0QXZhaWxhYmxlSW5jZW50aXZlcyIsImV0aEluY2VudGl2ZXMiLCJpbmMiLCJoYW5kbGVFcnJvciIsInNldHRsZUJvbmRzIiwiYm9uZHNTZXR0bGVkIiwibWFwcGluZ1NldHRsZWQiLCJzdGF0ZUVycm9yIiwicmVhbGl0eUV0aEFiaSIsInJlYWxpdHlFdGhBZGRyZXNzIiwiaXNGaW5hbGl6ZWQiLCJyZXN1bHRGb3IiLCJrYWlzaWduQ29udHJhY3RBZGRyZXNzIiwiY29udHJhY3RCYWxhbmNlIiwiYmFsYW5jZUVycm9yIiwiZ2V0Q3VycmVudEFjY291bnQiLCJsaXN0QWNjb3VudHMiLCJhZGRyZXNzIiwiTG9nSW5jZW50aXZlQ3JlYXRlZCIsImluY2VudGl2ZURhdGEiLCJ1bmRlZmluZWQiLCJldmVudEVycm9yIiwiZ2V0SW5jZW50aXZlc0J5VGFyZ2V0Q29udHJhY3QiLCJjbGFpbUFjdGl2ZVRva2VuSW5jZW50aXZlIiwidG9rZW5BZGRyZXNzIiwiY2xhaW1FVEhJbmNlbnRpdmUiLCJldGhBZGRyZXNzIiwid2ViM1NlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/web3Service.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/styles/globals.css":
/*!********************************!*\
  !*** ./src/styles/globals.css ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"cd3cc5b0ffa5\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdHlsZXMvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvcmljaGFyZGhhL0RvY3VtZW50cy/ou5/pq5Tlt6XnqIsvUHJvamVjdHMvS2FpLVNpZ24tQnVpbGRlci9mcm9udGVuZC9zcmMvc3R5bGVzL2dsb2JhbHMuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiY2QzY2M1YjBmZmE1XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/styles/globals.css\n"));

/***/ })

});