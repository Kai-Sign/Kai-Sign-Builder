"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_lib_blobService_ts",{

/***/ "(app-pages-browser)/./src/lib/blobValidationService.ts":
/*!******************************************!*\
  !*** ./src/lib/blobValidationService.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobValidationService: () => (/* binding */ BlobValidationService),\n/* harmony export */   blobValidationService: () => (/* binding */ blobValidationService)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../node_modules/ethers/lib.esm/providers/provider-browser.js\");\n\nclass BlobValidationService {\n    /**\n   * Validates blob hash format and checks if it exists on-chain\n   */ async validateBlobHash(blobHash) {\n        try {\n            // Step 1: Basic format validation\n            const formatValidation = this.validateBlobHashFormat(blobHash);\n            if (!formatValidation.isValid) {\n                return formatValidation;\n            }\n            // Step 2: Check if blob exists on-chain\n            const existenceCheck = await this.checkBlobExists(blobHash);\n            if (!existenceCheck.exists) {\n                return {\n                    isValid: false,\n                    exists: false,\n                    error: \"Blob hash \".concat(blobHash, \" does not exist on-chain. This could be because:\\n1. The blob was never posted to the blockchain\\n2. The blob hash is incorrect\\n3. The blob transaction failed or was reverted\\n4. You're checking on the wrong network (should be Sepolia)\")\n                };\n            }\n            return {\n                isValid: true,\n                exists: true,\n                blobData: existenceCheck.blobData\n            };\n        } catch (error) {\n            console.error('Blob validation error:', error);\n            return {\n                isValid: false,\n                exists: false,\n                error: \"Validation failed: \".concat(error instanceof Error ? error.message : String(error))\n            };\n        }\n    }\n    /**\n   * Validates the basic format of a blob hash\n   */ validateBlobHashFormat(blobHash) {\n        // Check if it's a string\n        if (typeof blobHash !== 'string') {\n            return {\n                isValid: false,\n                exists: false,\n                error: 'Blob hash must be a string'\n            };\n        }\n        // Check if it starts with 0x01 (EIP-4844 blob version)\n        if (!blobHash.startsWith('0x01')) {\n            return {\n                isValid: false,\n                exists: false,\n                error: 'Blob hash must start with 0x01 (EIP-4844 blob version)'\n            };\n        }\n        // Check if it's exactly 68 characters (0x01 + 64 hex chars)\n        if (blobHash.length !== 68) {\n            return {\n                isValid: false,\n                exists: false,\n                error: \"Blob hash must be exactly 68 characters (got \".concat(blobHash.length, \"). Expected format: 0x01 + 64 hex characters\")\n            };\n        }\n        // Check if it contains only valid hex characters\n        const hexRegex = /^0x01[a-fA-F0-9]{64}$/;\n        if (!hexRegex.test(blobHash)) {\n            // Find the first invalid character for better error reporting\n            const afterPrefix = blobHash.substring(4); // Remove \"0x01\"\n            let invalidChar = '';\n            let invalidPos = -1;\n            for(let i = 0; i < afterPrefix.length; i++){\n                const char = afterPrefix[i];\n                if (!/[0-9a-fA-F]/.test(char)) {\n                    invalidChar = char;\n                    invalidPos = i + 4; // +4 to account for \"0x01\" prefix\n                    break;\n                }\n            }\n            const errorMessage = invalidChar ? \"Invalid character '\".concat(invalidChar, \"' at position \").concat(invalidPos, \". Only hex characters (0-9, a-f, A-F) are allowed after 0x01\") : 'Blob hash contains invalid characters. Only hex characters (0-9, a-f, A-F) are allowed after 0x01';\n            return {\n                isValid: false,\n                exists: false,\n                error: errorMessage\n            };\n        }\n        // Check for common invalid patterns\n        if (blobHash === '0x010000000000000000000000000000000000000000000000000000000000000000') {\n            return {\n                isValid: false,\n                exists: false,\n                error: 'This is a zero blob hash which is invalid. Blob hashes cannot be all zeros.'\n            };\n        }\n        // Check for the specific invalid example mentioned\n        if (blobHash === '0x0100000000000') {\n            return {\n                isValid: false,\n                exists: false,\n                error: 'This blob hash is too short and invalid. Valid blob hashes must be 66 characters long starting with 0x01.'\n            };\n        }\n        return {\n            isValid: true,\n            exists: false // Will be checked in next step\n        };\n    }\n    /**\n   * Checks if a blob hash actually exists on the blockchain\n   */ async checkBlobExists(blobHash) {\n        if (!this.provider) {\n            throw new Error('No provider available for blockchain queries');\n        }\n        try {\n            // Method 1: Try to get blob data using eth_getBlobByHash (if supported)\n            try {\n                const blobData = await this.provider.send('eth_getBlobByHash', [\n                    blobHash\n                ]);\n                if (blobData && blobData !== '0x') {\n                    return {\n                        exists: true,\n                        blobData: {\n                            txHash: 'Unknown',\n                            blockNumber: 0,\n                            blobIndex: 0,\n                            etherscanUrl: \"https://sepolia.etherscan.io/blob/\".concat(blobHash)\n                        }\n                    };\n                }\n            } catch (blobError) {\n                // eth_getBlobByHash might not be supported by all RPCs\n                console.log('eth_getBlobByHash not supported, trying alternative methods');\n            }\n            // Method 2: Search for blob transactions in recent blocks\n            const currentBlock = await this.provider.getBlockNumber();\n            const searchBlocks = Math.min(1000, currentBlock); // Search last 1000 blocks\n            for(let i = 0; i < searchBlocks; i += 10){\n                const blockNumber = currentBlock - i;\n                try {\n                    const block = await this.provider.getBlock(blockNumber, true);\n                    if (!block || !block.transactions) continue;\n                    for (const tx of block.transactions){\n                        if (tx && typeof tx === 'object' && 'type' in tx && tx.type === 3 && 'blobVersionedHashes' in tx && tx.blobVersionedHashes) {\n                            const blobHashes = tx.blobVersionedHashes;\n                            for(let j = 0; j < blobHashes.length; j++){\n                                var _blobHashes_j;\n                                if (((_blobHashes_j = blobHashes[j]) === null || _blobHashes_j === void 0 ? void 0 : _blobHashes_j.toLowerCase()) === blobHash.toLowerCase()) {\n                                    return {\n                                        exists: true,\n                                        blobData: {\n                                            txHash: tx.hash || 'Unknown',\n                                            blockNumber: blockNumber,\n                                            blobIndex: j,\n                                            etherscanUrl: \"https://sepolia.etherscan.io/blob/\".concat(blobHash)\n                                        }\n                                    };\n                                }\n                            }\n                        }\n                    }\n                } catch (blockError) {\n                    continue;\n                }\n            }\n            // Method 3: Try to get transaction receipt by searching for blob events\n            // This is a fallback method that might work on some RPCs\n            try {\n                const filter = {\n                    fromBlock: currentBlock - 1000,\n                    toBlock: 'latest',\n                    topics: [\n                        '0x' + ethers__WEBPACK_IMPORTED_MODULE_0__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes('LogRevealSpec(address,bytes32,bytes32,bytes32,address,uint256)')).slice(2, 10)\n                    ]\n                };\n                const logs = await this.provider.getLogs(filter);\n                for (const log of logs){\n                    if (log.topics && log.topics.length >= 3) {\n                        const logBlobHash = log.topics[2]; // blobHash is the third topic\n                        if (logBlobHash.toLowerCase() === blobHash.toLowerCase()) {\n                            return {\n                                exists: true,\n                                blobData: {\n                                    txHash: log.transactionHash,\n                                    blockNumber: log.blockNumber,\n                                    blobIndex: 0,\n                                    etherscanUrl: \"https://sepolia.etherscan.io/blob/\".concat(blobHash)\n                                }\n                            };\n                        }\n                    }\n                }\n            } catch (logError) {\n                console.log('Log search failed:', logError);\n            }\n            return {\n                exists: false\n            };\n        } catch (error) {\n            console.error('Error checking blob existence:', error);\n            throw new Error(\"Failed to check blob existence: \".concat(error instanceof Error ? error.message : String(error)));\n        }\n    }\n    /**\n   * Validates multiple blob hashes at once\n   */ async validateMultipleBlobHashes(blobHashes) {\n        const results = new Map();\n        for (const blobHash of blobHashes){\n            const result = await this.validateBlobHash(blobHash);\n            results.set(blobHash, result);\n        }\n        return results;\n    }\n    /**\n   * Gets blob data from Etherscan API (alternative method)\n   */ async getBlobDataFromEtherscan(blobHash) {\n        try {\n            const response = await fetch(\"https://api-sepolia.etherscan.io/api?module=proxy&action=eth_getTransactionByHash&txhash=\".concat(blobHash));\n            const data = await response.json();\n            if (data.result && data.result.blobVersionedHashes) {\n                return {\n                    exists: true,\n                    blobData: {\n                        txHash: data.result.hash,\n                        blockNumber: parseInt(data.result.blockNumber, 16),\n                        blobIndex: 0,\n                        etherscanUrl: \"https://sepolia.etherscan.io/blob/\".concat(blobHash)\n                    }\n                };\n            }\n            return {\n                exists: false\n            };\n        } catch (error) {\n            console.error('Etherscan API error:', error);\n            return {\n                exists: false\n            };\n        }\n    }\n    constructor(rpcUrl){\n        this.provider = null;\n        if (rpcUrl) {\n            this.provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider(rpcUrl);\n        } else if ( true && window.ethereum) {\n            this.provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.BrowserProvider(window.ethereum);\n        }\n    }\n}\n// Export singleton instance\nconst blobValidationService = new BlobValidationService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYmxvYlZhbGlkYXRpb25TZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFnQztBQWN6QixNQUFNQztJQVdYOztHQUVDLEdBQ0QsTUFBTUMsaUJBQWlCQyxRQUFnQixFQUFpQztRQUN0RSxJQUFJO1lBQ0Ysa0NBQWtDO1lBQ2xDLE1BQU1DLG1CQUFtQixJQUFJLENBQUNDLHNCQUFzQixDQUFDRjtZQUNyRCxJQUFJLENBQUNDLGlCQUFpQkUsT0FBTyxFQUFFO2dCQUM3QixPQUFPRjtZQUNUO1lBRUEsd0NBQXdDO1lBQ3hDLE1BQU1HLGlCQUFpQixNQUFNLElBQUksQ0FBQ0MsZUFBZSxDQUFDTDtZQUNsRCxJQUFJLENBQUNJLGVBQWVFLE1BQU0sRUFBRTtnQkFDMUIsT0FBTztvQkFDTEgsU0FBUztvQkFDVEcsUUFBUTtvQkFDUkMsT0FBTyxhQUFzQixPQUFUUCxVQUFTO2dCQUsvQjtZQUNGO1lBRUEsT0FBTztnQkFDTEcsU0FBUztnQkFDVEcsUUFBUTtnQkFDUkUsVUFBVUosZUFBZUksUUFBUTtZQUNuQztRQUVGLEVBQUUsT0FBT0QsT0FBTztZQUNkRSxRQUFRRixLQUFLLENBQUMsMEJBQTBCQTtZQUN4QyxPQUFPO2dCQUNMSixTQUFTO2dCQUNURyxRQUFRO2dCQUNSQyxPQUFPLHNCQUE2RSxPQUF2REEsaUJBQWlCRyxRQUFRSCxNQUFNSSxPQUFPLEdBQUdDLE9BQU9MO1lBQy9FO1FBQ0Y7SUFDRjtJQUVBOztHQUVDLEdBQ0QsdUJBQStCUCxRQUFnQixFQUF3QjtRQUNyRSx5QkFBeUI7UUFDekIsSUFBSSxPQUFPQSxhQUFhLFVBQVU7WUFDaEMsT0FBTztnQkFDTEcsU0FBUztnQkFDVEcsUUFBUTtnQkFDUkMsT0FBTztZQUNUO1FBQ0Y7UUFFQSx1REFBdUQ7UUFDdkQsSUFBSSxDQUFDUCxTQUFTYSxVQUFVLENBQUMsU0FBUztZQUNoQyxPQUFPO2dCQUNMVixTQUFTO2dCQUNURyxRQUFRO2dCQUNSQyxP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QUMsd0JBQXdCQTtZQUN0QyxPQUFPO2dCQUFFRCxRQUFRO1lBQU07UUFDekI7SUFDRjtJQWpSQSxZQUFZaUUsTUFBZSxDQUFFO2FBRnJCL0MsV0FBbUU7UUFHekUsSUFBSStDLFFBQVE7WUFDVixJQUFJLENBQUMvQyxRQUFRLEdBQUcsSUFBSTNCLG1EQUFzQixDQUFDMEU7UUFDN0MsT0FBTyxJQUFJLEtBQTZCLElBQUksT0FBZ0JHLFFBQVEsRUFBRTtZQUNwRSxJQUFJLENBQUNsRCxRQUFRLEdBQUcsSUFBSTNCLG1EQUFzQixDQUFDLE9BQWdCNkUsUUFBUTtRQUNyRTtJQUNGO0FBNFFGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1FLHdCQUF3QixJQUFJOUUsd0JBQXdCIiwic291cmNlcyI6WyIvVXNlcnMvcmljaGFyZGhhL0RvY3VtZW50cy/ou5/pq5Tlt6XnqIsvUHJvamVjdHMvS2FpLVNpZ24tQnVpbGRlci9mcm9udGVuZC9zcmMvbGliL2Jsb2JWYWxpZGF0aW9uU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBldGhlcnMgfSBmcm9tIFwiZXRoZXJzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmxvYlZhbGlkYXRpb25SZXN1bHQge1xuICBpc1ZhbGlkOiBib29sZWFuO1xuICBleGlzdHM6IGJvb2xlYW47XG4gIGVycm9yPzogc3RyaW5nO1xuICBibG9iRGF0YT86IHtcbiAgICB0eEhhc2g6IHN0cmluZztcbiAgICBibG9ja051bWJlcjogbnVtYmVyO1xuICAgIGJsb2JJbmRleDogbnVtYmVyO1xuICAgIGV0aGVyc2NhblVybDogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgY2xhc3MgQmxvYlZhbGlkYXRpb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSBwcm92aWRlcjogZXRoZXJzLkpzb25ScGNQcm92aWRlciB8IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihycGNVcmw/OiBzdHJpbmcpIHtcbiAgICBpZiAocnBjVXJsKSB7XG4gICAgICB0aGlzLnByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIocnBjVXJsKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bSkge1xuICAgICAgdGhpcy5wcm92aWRlciA9IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKCh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBibG9iIGhhc2ggZm9ybWF0IGFuZCBjaGVja3MgaWYgaXQgZXhpc3RzIG9uLWNoYWluXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZUJsb2JIYXNoKGJsb2JIYXNoOiBzdHJpbmcpOiBQcm9taXNlPEJsb2JWYWxpZGF0aW9uUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFN0ZXAgMTogQmFzaWMgZm9ybWF0IHZhbGlkYXRpb25cbiAgICAgIGNvbnN0IGZvcm1hdFZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlQmxvYkhhc2hGb3JtYXQoYmxvYkhhc2gpO1xuICAgICAgaWYgKCFmb3JtYXRWYWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFZhbGlkYXRpb247XG4gICAgICB9XG5cbiAgICAgIC8vIFN0ZXAgMjogQ2hlY2sgaWYgYmxvYiBleGlzdHMgb24tY2hhaW5cbiAgICAgIGNvbnN0IGV4aXN0ZW5jZUNoZWNrID0gYXdhaXQgdGhpcy5jaGVja0Jsb2JFeGlzdHMoYmxvYkhhc2gpO1xuICAgICAgaWYgKCFleGlzdGVuY2VDaGVjay5leGlzdHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBleGlzdHM6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBgQmxvYiBoYXNoICR7YmxvYkhhc2h9IGRvZXMgbm90IGV4aXN0IG9uLWNoYWluLiBUaGlzIGNvdWxkIGJlIGJlY2F1c2U6XG4xLiBUaGUgYmxvYiB3YXMgbmV2ZXIgcG9zdGVkIHRvIHRoZSBibG9ja2NoYWluXG4yLiBUaGUgYmxvYiBoYXNoIGlzIGluY29ycmVjdFxuMy4gVGhlIGJsb2IgdHJhbnNhY3Rpb24gZmFpbGVkIG9yIHdhcyByZXZlcnRlZFxuNC4gWW91J3JlIGNoZWNraW5nIG9uIHRoZSB3cm9uZyBuZXR3b3JrIChzaG91bGQgYmUgU2Vwb2xpYSlgXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgIGV4aXN0czogdHJ1ZSxcbiAgICAgICAgYmxvYkRhdGE6IGV4aXN0ZW5jZUNoZWNrLmJsb2JEYXRhXG4gICAgICB9O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Jsb2IgdmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXhpc3RzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBWYWxpZGF0aW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBiYXNpYyBmb3JtYXQgb2YgYSBibG9iIGhhc2hcbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVCbG9iSGFzaEZvcm1hdChibG9iSGFzaDogc3RyaW5nKTogQmxvYlZhbGlkYXRpb25SZXN1bHQge1xuICAgIC8vIENoZWNrIGlmIGl0J3MgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIGJsb2JIYXNoICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGV4aXN0czogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnQmxvYiBoYXNoIG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGl0IHN0YXJ0cyB3aXRoIDB4MDEgKEVJUC00ODQ0IGJsb2IgdmVyc2lvbilcbiAgICBpZiAoIWJsb2JIYXNoLnN0YXJ0c1dpdGgoJzB4MDEnKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGV4aXN0czogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnQmxvYiBoYXNoIG11c3Qgc3RhcnQgd2l0aCAweDAxIChFSVAtNDg0NCBibG9iIHZlcnNpb24pJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBpdCdzIGV4YWN0bHkgNjggY2hhcmFjdGVycyAoMHgwMSArIDY0IGhleCBjaGFycylcbiAgICBpZiAoYmxvYkhhc2gubGVuZ3RoICE9PSA2OCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGV4aXN0czogZmFsc2UsXG4gICAgICAgIGVycm9yOiBgQmxvYiBoYXNoIG11c3QgYmUgZXhhY3RseSA2OCBjaGFyYWN0ZXJzIChnb3QgJHtibG9iSGFzaC5sZW5ndGh9KS4gRXhwZWN0ZWQgZm9ybWF0OiAweDAxICsgNjQgaGV4IGNoYXJhY3RlcnNgXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGl0IGNvbnRhaW5zIG9ubHkgdmFsaWQgaGV4IGNoYXJhY3RlcnNcbiAgICBjb25zdCBoZXhSZWdleCA9IC9eMHgwMVthLWZBLUYwLTldezY0fSQvO1xuICAgIGlmICghaGV4UmVnZXgudGVzdChibG9iSGFzaCkpIHtcbiAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIGZvciBiZXR0ZXIgZXJyb3IgcmVwb3J0aW5nXG4gICAgICBjb25zdCBhZnRlclByZWZpeCA9IGJsb2JIYXNoLnN1YnN0cmluZyg0KTsgLy8gUmVtb3ZlIFwiMHgwMVwiXG4gICAgICBsZXQgaW52YWxpZENoYXIgPSAnJztcbiAgICAgIGxldCBpbnZhbGlkUG9zID0gLTE7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWZ0ZXJQcmVmaXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IGFmdGVyUHJlZml4W2ldO1xuICAgICAgICBpZiAoIS9bMC05YS1mQS1GXS8udGVzdChjaGFyKSkge1xuICAgICAgICAgIGludmFsaWRDaGFyID0gY2hhcjtcbiAgICAgICAgICBpbnZhbGlkUG9zID0gaSArIDQ7IC8vICs0IHRvIGFjY291bnQgZm9yIFwiMHgwMVwiIHByZWZpeFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGludmFsaWRDaGFyIFxuICAgICAgICA/IGBJbnZhbGlkIGNoYXJhY3RlciAnJHtpbnZhbGlkQ2hhcn0nIGF0IHBvc2l0aW9uICR7aW52YWxpZFBvc30uIE9ubHkgaGV4IGNoYXJhY3RlcnMgKDAtOSwgYS1mLCBBLUYpIGFyZSBhbGxvd2VkIGFmdGVyIDB4MDFgXG4gICAgICAgIDogJ0Jsb2IgaGFzaCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMuIE9ubHkgaGV4IGNoYXJhY3RlcnMgKDAtOSwgYS1mLCBBLUYpIGFyZSBhbGxvd2VkIGFmdGVyIDB4MDEnO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXhpc3RzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29tbW9uIGludmFsaWQgcGF0dGVybnNcbiAgICBpZiAoYmxvYkhhc2ggPT09ICcweDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBleGlzdHM6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ1RoaXMgaXMgYSB6ZXJvIGJsb2IgaGFzaCB3aGljaCBpcyBpbnZhbGlkLiBCbG9iIGhhc2hlcyBjYW5ub3QgYmUgYWxsIHplcm9zLidcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHRoZSBzcGVjaWZpYyBpbnZhbGlkIGV4YW1wbGUgbWVudGlvbmVkXG4gICAgaWYgKGJsb2JIYXNoID09PSAnMHgwMTAwMDAwMDAwMDAwJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGV4aXN0czogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnVGhpcyBibG9iIGhhc2ggaXMgdG9vIHNob3J0IGFuZCBpbnZhbGlkLiBWYWxpZCBibG9iIGhhc2hlcyBtdXN0IGJlIDY2IGNoYXJhY3RlcnMgbG9uZyBzdGFydGluZyB3aXRoIDB4MDEuJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgIGV4aXN0czogZmFsc2UgLy8gV2lsbCBiZSBjaGVja2VkIGluIG5leHQgc3RlcFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgYmxvYiBoYXNoIGFjdHVhbGx5IGV4aXN0cyBvbiB0aGUgYmxvY2tjaGFpblxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjaGVja0Jsb2JFeGlzdHMoYmxvYkhhc2g6IHN0cmluZyk6IFByb21pc2U8eyBleGlzdHM6IGJvb2xlYW47IGJsb2JEYXRhPzogYW55IH0+IHtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJvdmlkZXIgYXZhaWxhYmxlIGZvciBibG9ja2NoYWluIHF1ZXJpZXMnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gTWV0aG9kIDE6IFRyeSB0byBnZXQgYmxvYiBkYXRhIHVzaW5nIGV0aF9nZXRCbG9iQnlIYXNoIChpZiBzdXBwb3J0ZWQpXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBibG9iRGF0YSA9IGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZCgnZXRoX2dldEJsb2JCeUhhc2gnLCBbYmxvYkhhc2hdKTtcbiAgICAgICAgaWYgKGJsb2JEYXRhICYmIGJsb2JEYXRhICE9PSAnMHgnKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4aXN0czogdHJ1ZSxcbiAgICAgICAgICAgIGJsb2JEYXRhOiB7XG4gICAgICAgICAgICAgIHR4SGFzaDogJ1Vua25vd24nLFxuICAgICAgICAgICAgICBibG9ja051bWJlcjogMCxcbiAgICAgICAgICAgICAgYmxvYkluZGV4OiAwLFxuICAgICAgICAgICAgICBldGhlcnNjYW5Vcmw6IGBodHRwczovL3NlcG9saWEuZXRoZXJzY2FuLmlvL2Jsb2IvJHtibG9iSGFzaH1gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoYmxvYkVycm9yKSB7XG4gICAgICAgIC8vIGV0aF9nZXRCbG9iQnlIYXNoIG1pZ2h0IG5vdCBiZSBzdXBwb3J0ZWQgYnkgYWxsIFJQQ3NcbiAgICAgICAgY29uc29sZS5sb2coJ2V0aF9nZXRCbG9iQnlIYXNoIG5vdCBzdXBwb3J0ZWQsIHRyeWluZyBhbHRlcm5hdGl2ZSBtZXRob2RzJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ldGhvZCAyOiBTZWFyY2ggZm9yIGJsb2IgdHJhbnNhY3Rpb25zIGluIHJlY2VudCBibG9ja3NcbiAgICAgIGNvbnN0IGN1cnJlbnRCbG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgIGNvbnN0IHNlYXJjaEJsb2NrcyA9IE1hdGgubWluKDEwMDAsIGN1cnJlbnRCbG9jayk7IC8vIFNlYXJjaCBsYXN0IDEwMDAgYmxvY2tzXG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoQmxvY2tzOyBpICs9IDEwKSB7IC8vIENoZWNrIGV2ZXJ5IDEwdGggYmxvY2sgZm9yIGVmZmljaWVuY3lcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBjdXJyZW50QmxvY2sgLSBpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja051bWJlciwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKCFibG9jayB8fCAhYmxvY2sudHJhbnNhY3Rpb25zKSBjb250aW51ZTtcblxuICAgICAgICAgIGZvciAoY29uc3QgdHggb2YgYmxvY2sudHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAodHggJiYgdHlwZW9mIHR4ID09PSAnb2JqZWN0JyAmJiAndHlwZScgaW4gdHggJiYgdHgudHlwZSA9PT0gMyAmJiAnYmxvYlZlcnNpb25lZEhhc2hlcycgaW4gdHggJiYgdHguYmxvYlZlcnNpb25lZEhhc2hlcykge1xuICAgICAgICAgICAgICBjb25zdCBibG9iSGFzaGVzID0gdHguYmxvYlZlcnNpb25lZEhhc2hlcyBhcyBzdHJpbmdbXTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9iSGFzaGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2JIYXNoZXNbal0/LnRvTG93ZXJDYXNlKCkgPT09IGJsb2JIYXNoLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYmxvYkRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICB0eEhhc2g6ICh0eCBhcyBhbnkpLmhhc2ggfHwgJ1Vua25vd24nLFxuICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBibG9ja051bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBibG9iSW5kZXg6IGosXG4gICAgICAgICAgICAgICAgICAgICAgZXRoZXJzY2FuVXJsOiBgaHR0cHM6Ly9zZXBvbGlhLmV0aGVyc2Nhbi5pby9ibG9iLyR7YmxvYkhhc2h9YFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoYmxvY2tFcnJvcikge1xuICAgICAgICAgIC8vIFNraXAgYmxvY2tzIHRoYXQgY2FuJ3QgYmUgZmV0Y2hlZFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1ldGhvZCAzOiBUcnkgdG8gZ2V0IHRyYW5zYWN0aW9uIHJlY2VpcHQgYnkgc2VhcmNoaW5nIGZvciBibG9iIGV2ZW50c1xuICAgICAgLy8gVGhpcyBpcyBhIGZhbGxiYWNrIG1ldGhvZCB0aGF0IG1pZ2h0IHdvcmsgb24gc29tZSBSUENzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgZnJvbUJsb2NrOiBjdXJyZW50QmxvY2sgLSAxMDAwLFxuICAgICAgICAgIHRvQmxvY2s6ICdsYXRlc3QnLFxuICAgICAgICAgIHRvcGljczogW1xuICAgICAgICAgICAgJzB4JyArIGV0aGVycy5rZWNjYWsyNTYoZXRoZXJzLnRvVXRmOEJ5dGVzKCdMb2dSZXZlYWxTcGVjKGFkZHJlc3MsYnl0ZXMzMixieXRlczMyLGJ5dGVzMzIsYWRkcmVzcyx1aW50MjU2KScpKS5zbGljZSgyLCAxMClcbiAgICAgICAgICBdXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbG9ncyA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgICAgaWYgKGxvZy50b3BpY3MgJiYgbG9nLnRvcGljcy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgY29uc3QgbG9nQmxvYkhhc2ggPSBsb2cudG9waWNzWzJdOyAvLyBibG9iSGFzaCBpcyB0aGUgdGhpcmQgdG9waWNcbiAgICAgICAgICAgIGlmIChsb2dCbG9iSGFzaC50b0xvd2VyQ2FzZSgpID09PSBibG9iSGFzaC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXhpc3RzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGJsb2JEYXRhOiB7XG4gICAgICAgICAgICAgICAgICB0eEhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgICBibG9ja051bWJlcjogbG9nLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgYmxvYkluZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgZXRoZXJzY2FuVXJsOiBgaHR0cHM6Ly9zZXBvbGlhLmV0aGVyc2Nhbi5pby9ibG9iLyR7YmxvYkhhc2h9YFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGxvZ0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2cgc2VhcmNoIGZhaWxlZDonLCBsb2dFcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGV4aXN0czogZmFsc2UgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBibG9iIGV4aXN0ZW5jZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjaGVjayBibG9iIGV4aXN0ZW5jZTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBtdWx0aXBsZSBibG9iIGhhc2hlcyBhdCBvbmNlXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZU11bHRpcGxlQmxvYkhhc2hlcyhibG9iSGFzaGVzOiBzdHJpbmdbXSk6IFByb21pc2U8TWFwPHN0cmluZywgQmxvYlZhbGlkYXRpb25SZXN1bHQ+PiB7XG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBNYXA8c3RyaW5nLCBCbG9iVmFsaWRhdGlvblJlc3VsdD4oKTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGJsb2JIYXNoIG9mIGJsb2JIYXNoZXMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudmFsaWRhdGVCbG9iSGFzaChibG9iSGFzaCk7XG4gICAgICByZXN1bHRzLnNldChibG9iSGFzaCwgcmVzdWx0KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBibG9iIGRhdGEgZnJvbSBFdGhlcnNjYW4gQVBJIChhbHRlcm5hdGl2ZSBtZXRob2QpXG4gICAqL1xuICBhc3luYyBnZXRCbG9iRGF0YUZyb21FdGhlcnNjYW4oYmxvYkhhc2g6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLXNlcG9saWEuZXRoZXJzY2FuLmlvL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCZ0eGhhc2g9JHtibG9iSGFzaH1gKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGlmIChkYXRhLnJlc3VsdCAmJiBkYXRhLnJlc3VsdC5ibG9iVmVyc2lvbmVkSGFzaGVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXhpc3RzOiB0cnVlLFxuICAgICAgICAgIGJsb2JEYXRhOiB7XG4gICAgICAgICAgICB0eEhhc2g6IGRhdGEucmVzdWx0Lmhhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogcGFyc2VJbnQoZGF0YS5yZXN1bHQuYmxvY2tOdW1iZXIsIDE2KSxcbiAgICAgICAgICAgIGJsb2JJbmRleDogMCxcbiAgICAgICAgICAgIGV0aGVyc2NhblVybDogYGh0dHBzOi8vc2Vwb2xpYS5ldGhlcnNjYW4uaW8vYmxvYi8ke2Jsb2JIYXNofWBcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7IGV4aXN0czogZmFsc2UgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXRoZXJzY2FuIEFQSSBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4geyBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBibG9iVmFsaWRhdGlvblNlcnZpY2UgPSBuZXcgQmxvYlZhbGlkYXRpb25TZXJ2aWNlKCk7XG4iXSwibmFtZXMiOlsiZXRoZXJzIiwiQmxvYlZhbGlkYXRpb25TZXJ2aWNlIiwidmFsaWRhdGVCbG9iSGFzaCIsImJsb2JIYXNoIiwiZm9ybWF0VmFsaWRhdGlvbiIsInZhbGlkYXRlQmxvYkhhc2hGb3JtYXQiLCJpc1ZhbGlkIiwiZXhpc3RlbmNlQ2hlY2siLCJjaGVja0Jsb2JFeGlzdHMiLCJleGlzdHMiLCJlcnJvciIsImJsb2JEYXRhIiwiY29uc29sZSIsIkVycm9yIiwibWVzc2FnZSIsIlN0cmluZyIsInN0YXJ0c1dpdGgiLCJsZW5ndGgiLCJoZXhSZWdleCIsInRlc3QiLCJhZnRlclByZWZpeCIsInN1YnN0cmluZyIsImludmFsaWRDaGFyIiwiaW52YWxpZFBvcyIsImkiLCJjaGFyIiwiZXJyb3JNZXNzYWdlIiwicHJvdmlkZXIiLCJzZW5kIiwidHhIYXNoIiwiYmxvY2tOdW1iZXIiLCJibG9iSW5kZXgiLCJldGhlcnNjYW5VcmwiLCJibG9iRXJyb3IiLCJsb2ciLCJjdXJyZW50QmxvY2siLCJnZXRCbG9ja051bWJlciIsInNlYXJjaEJsb2NrcyIsIk1hdGgiLCJtaW4iLCJibG9jayIsImdldEJsb2NrIiwidHJhbnNhY3Rpb25zIiwidHgiLCJ0eXBlIiwiYmxvYlZlcnNpb25lZEhhc2hlcyIsImJsb2JIYXNoZXMiLCJqIiwidG9Mb3dlckNhc2UiLCJoYXNoIiwiYmxvY2tFcnJvciIsImZpbHRlciIsImZyb21CbG9jayIsInRvQmxvY2siLCJ0b3BpY3MiLCJrZWNjYWsyNTYiLCJ0b1V0ZjhCeXRlcyIsInNsaWNlIiwibG9ncyIsImdldExvZ3MiLCJsb2dCbG9iSGFzaCIsInRyYW5zYWN0aW9uSGFzaCIsImxvZ0Vycm9yIiwidmFsaWRhdGVNdWx0aXBsZUJsb2JIYXNoZXMiLCJyZXN1bHRzIiwiTWFwIiwicmVzdWx0Iiwic2V0IiwiZ2V0QmxvYkRhdGFGcm9tRXRoZXJzY2FuIiwicmVzcG9uc2UiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwicGFyc2VJbnQiLCJycGNVcmwiLCJKc29uUnBjUHJvdmlkZXIiLCJ3aW5kb3ciLCJldGhlcmV1bSIsIkJyb3dzZXJQcm92aWRlciIsImJsb2JWYWxpZGF0aW9uU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/blobValidationService.ts\n"));

/***/ })

});