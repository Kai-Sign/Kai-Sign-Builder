"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_src_lib_graphClient_ts";
exports.ids = ["_rsc_src_lib_graphClient_ts"];
exports.modules = {

/***/ "(rsc)/./src/lib/graphClient.ts":
/*!********************************!*\
  !*** ./src/lib/graphClient.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KaiSignGraphClient: () => (/* binding */ KaiSignGraphClient),\n/* harmony export */   createKaiSignClient: () => (/* binding */ createKaiSignClient),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var graphql_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphql-request */ \"(rsc)/../node_modules/graphql-request/build/entrypoints/main.js\");\n\nclass KaiSignGraphClient {\n    constructor(graphqlEndpoint){\n        this.client = new graphql_request__WEBPACK_IMPORTED_MODULE_0__.GraphQLClient(graphqlEndpoint);\n    }\n    /**\n   * Get contracts with approved metadata for a specific chain\n   * Always returns latest metadata (handles disputes automatically)\n   */ async getContractsWithMetadata(chainID) {\n        const query = `\n      query GetContracts($chainID: String!) {\n        contracts(where: { chainID: $chainID, hasApprovedMetadata: true }) {\n          address\n          chainID\n          name\n          version\n          description\n          hasApprovedMetadata\n          latestSpecTimestamp\n          functionCount\n        }\n      }\n    `;\n        const data = await this.client.request(query, {\n            chainID\n        });\n        return data.contracts;\n    }\n    /**\n   * Get transaction metadata for a specific contract and selector\n   * Always uses latest approved metadata\n   */ async getTransactionMetadata(contractAddress, selector, chainID) {\n        // Query for specs that target this contract\n        const query = `\n      query GetContractSpecs($targetContract: Bytes!, $chainID: String!) {\n        specs(where: { \n          targetContract: $targetContract\n          chainID: $chainID\n        }) {\n          id\n          ipfs\n          user\n          status\n          blockTimestamp\n        }\n      }\n    `;\n        const targetContract = contractAddress.toLowerCase();\n        const data = await this.client.request(query, {\n            targetContract,\n            chainID\n        });\n        // If we have specs, return a placeholder indicating metadata is available\n        if (data.specs && data.specs.length > 0) {\n            return {\n                selector: selector,\n                name: `Contract Function ${selector}`,\n                intent: `Execute function ${selector} on contract`,\n                parameterTypes: [],\n                displayFormat: `function_${selector.slice(2, 10)}`\n            };\n        }\n        return null;\n    }\n    /**\n   * Get complete contract metadata with IPFS data\n   */ async getCompleteContractMetadata(contractAddress, chainID) {\n        const query = `\n      query GetContractSpecs($targetContract: Bytes!, $chainID: String!) {\n        specs(where: { \n          targetContract: $targetContract\n          chainID: $chainID\n        }\n        orderBy: blockTimestamp\n        orderDirection: desc) {\n          id\n          ipfs\n          user\n          status\n          blockTimestamp\n          targetContract\n          chainID\n        }\n      }\n    `;\n        const targetContract = contractAddress.toLowerCase();\n        const data = await this.client.request(query, {\n            targetContract,\n            chainID\n        });\n        let ipfsMetadata;\n        // Try to fetch IPFS metadata from the most recent spec\n        if (data.specs && data.specs.length > 0) {\n            const latestSpec = data.specs[0];\n            if (latestSpec) {\n                try {\n                    // Always fetch from IPFS gateways for real data\n                    const gateways = [\n                        `https://gateway.pinata.cloud/ipfs/${latestSpec.ipfs}`,\n                        `https://ipfs.io/ipfs/${latestSpec.ipfs}`,\n                        `https://dweb.link/ipfs/${latestSpec.ipfs}`,\n                        `https://cloudflare-ipfs.com/ipfs/${latestSpec.ipfs}`\n                    ];\n                    console.log(`Fetching real IPFS data for hash: ${latestSpec.ipfs}`);\n                    for (const gateway of gateways){\n                        try {\n                            console.log(`Trying IPFS gateway: ${gateway}`);\n                            const ipfsResponse = await fetch(gateway, {\n                                signal: AbortSignal.timeout(15000) // 15 second timeout per gateway\n                            });\n                            if (ipfsResponse.ok) {\n                                ipfsMetadata = await ipfsResponse.json();\n                                console.log(`Successfully fetched real metadata from: ${gateway}`);\n                                break; // Success, exit the loop\n                            }\n                        } catch (error) {\n                            console.log(`Gateway ${gateway} failed:`, error);\n                            continue; // Try next gateway\n                        }\n                    }\n                    if (!ipfsMetadata) {\n                        throw new Error(`Failed to fetch IPFS metadata for hash: ${latestSpec.ipfs}. All IPFS gateways failed.`);\n                    }\n                } catch (error) {\n                    console.log('Failed to fetch IPFS metadata:', error);\n                }\n            }\n        }\n        return {\n            specs: data.specs,\n            ipfsMetadata\n        };\n    }\n    /**\n   * Get dispute/replacement history for a contract\n   * Shows all finalized specs ordered by newest first\n   */ async getContractSpecHistory(contractAddress, chainID) {\n        const query = `\n      query GetSpecHistory($targetContract: Bytes!, $chainID: String!) {\n        specs(\n          where: { \n            targetContract: $targetContract\n            chainID: $chainID\n            status: FINALIZED\n          }\n          orderBy: blockTimestamp\n          orderDirection: desc\n        ) {\n          id\n          user\n          ipfs\n          blockTimestamp\n          status\n        }\n      }\n    `;\n        const data = await this.client.request(query, {\n            targetContract: contractAddress.toLowerCase(),\n            chainID\n        });\n        return data.specs.map((spec)=>({\n                id: spec.id,\n                creator: spec.user,\n                ipfsCID: spec.ipfs,\n                createdTimestamp: spec.blockTimestamp,\n                status: spec.status\n            }));\n    }\n    /**\n   * Get all functions for a specific contract\n   */ async getContractFunctions(contractAddress, chainID) {\n        const query = `\n      query GetContractFunctions($contractId: String!) {\n        functions(where: { contract: $contractId }) {\n          selector\n          name\n          intent\n          parameterTypes\n          displayFormat\n        }\n      }\n    `;\n        const contractId = `${contractAddress.toLowerCase()}-${chainID}`;\n        const data = await this.client.request(query, {\n            contractId\n        });\n        return data.functions;\n    }\n    /**\n   * Search contracts by name\n   */ async searchContracts(searchTerm, chainID) {\n        const whereClause = chainID ? `{ hasApprovedMetadata: true, chainID: \"${chainID}\", name_contains_nocase: \"${searchTerm}\" }` : `{ hasApprovedMetadata: true, name_contains_nocase: \"${searchTerm}\" }`;\n        const query = `\n      query SearchContracts {\n        contracts(where: ${whereClause}) {\n          address\n          chainID\n          name\n          version\n          description\n          hasApprovedMetadata\n          latestSpecTimestamp\n          functionCount\n        }\n      }\n    `;\n        const data = await this.client.request(query);\n        return data.contracts;\n    }\n    /**\n   * Get all finalized specifications created by a specific user\n   */ async getUserFinalizedSpecs(userAddress) {\n        const query = `\n      query GetUserFinalizedSpecs($user: Bytes!) {\n        specs(\n          where: { \n            user: $user\n            status: FINALIZED\n          }\n          orderBy: blockTimestamp\n          orderDirection: desc\n        ) {\n          id\n          user\n          ipfs\n          targetContract\n          blockTimestamp\n          status\n        }\n      }\n    `;\n        const data = await this.client.request(query, {\n            user: userAddress.toLowerCase()\n        });\n        if (!data || !data.specs) {\n            return [];\n        }\n        return data.specs.map((spec)=>({\n                id: spec.id,\n                creator: spec.user,\n                ipfsCID: spec.ipfs,\n                createdTimestamp: spec.blockTimestamp,\n                status: spec.status,\n                targetContract: spec.targetContract,\n                totalBonds: \"0\",\n                bondsSettled: false,\n                proposedTimestamp: spec.blockTimestamp // Use blockTimestamp as fallback\n            }));\n    }\n    /**\n   * Get all specifications (any status) created by a specific user\n   */ async getUserSpecs(userAddress) {\n        const query = `\n      query GetUserSpecs($user: Bytes!) {\n        specs(\n          where: { \n            user: $user\n          }\n          orderBy: blockTimestamp\n          orderDirection: desc\n        ) {\n          id\n          user\n          ipfs\n          targetContract\n          blockTimestamp\n          status\n        }\n      }\n    `;\n        const data = await this.client.request(query, {\n            user: userAddress.toLowerCase()\n        });\n        if (!data || !data.specs) {\n            return [];\n        }\n        return data.specs.map((spec)=>({\n                id: spec.id,\n                creator: spec.user,\n                ipfsCID: spec.ipfs,\n                createdTimestamp: spec.blockTimestamp,\n                status: spec.status,\n                targetContract: spec.targetContract,\n                totalBonds: \"0\",\n                bondsSettled: false,\n                proposedTimestamp: spec.blockTimestamp // Use blockTimestamp as fallback\n            }));\n    }\n}\n// Default client instance for common networks\nconst createKaiSignClient = (network)=>{\n    const endpoints = {\n        mainnet: 'https://api.thegraph.com/subgraphs/name/kai-sign/kaisign-mainnet',\n        sepolia: 'https://api.studio.thegraph.com/query/117022/kaisign-subgraph/v0.0.3'\n    };\n    const endpoint = endpoints[network] || network;\n    return new KaiSignGraphClient(endpoint);\n};\n// Re-export for convenience\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KaiSignGraphClient);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFLTSxjQUFjLENBQUMsaUNBQWlDO1lBQzFFO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU1hLGFBQWFKLFdBQW1CLEVBQTBCO1FBQzlELE1BQU1sRCxRQUFRLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBaUJmLENBQUM7UUFFRCxNQUFNQyxPQUFPLE1BQU0sSUFBSSxDQUFDSixNQUFNLENBQUNLLE9BQU8sQ0FBbUJGLE9BQU87WUFDOURzQyxNQUFNWSxZQUFZMUMsV0FBVztRQUMvQjtRQUVBLElBQUksQ0FBQ1AsUUFBUSxDQUFDQSxLQUFLUSxLQUFLLEVBQUU7WUFDeEIsT0FBTyxFQUFFO1FBQ1g7UUFFQSxPQUFPUixLQUFLUSxLQUFLLENBQUN5QixHQUFHLENBQUMsQ0FBQ0MsT0FBZTtnQkFDcENDLElBQUlELEtBQUtDLEVBQUU7Z0JBQ1hDLFNBQVNGLEtBQUtHLElBQUk7Z0JBQ2xCQyxTQUFTSixLQUFLZixJQUFJO2dCQUNsQm9CLGtCQUFrQkwsS0FBS00sY0FBYztnQkFDckNDLFFBQVFQLEtBQUtPLE1BQU07Z0JBQ25CbkMsZ0JBQWdCNEIsS0FBSzVCLGNBQWM7Z0JBQ25DNEMsWUFBWTtnQkFDWkMsY0FBYztnQkFDZEMsbUJBQW1CbEIsS0FBS00sY0FBYyxDQUFDLGlDQUFpQztZQUMxRTtJQUNGO0FBQ0Y7QUFFQSw4Q0FBOEM7QUFDdkMsTUFBTWMsc0JBQXNCLENBQUNDO0lBQ2xDLE1BQU1DLFlBQVk7UUFDaEJDLFNBQVM7UUFDVEMsU0FBUztJQUNYO0lBRUEsTUFBTUMsV0FBV0gsU0FBUyxDQUFDRCxRQUFrQyxJQUFJQTtJQUNqRSxPQUFPLElBQUk5RCxtQkFBbUJrRTtBQUNoQyxFQUFFO0FBRUYsNEJBQTRCO0FBQzVCLGlFQUFlbEUsa0JBQWtCQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcmljaGFyZGhhL0RvY3VtZW50cy/ou5/pq5Tlt6XnqIsvUHJvamVjdHMvS2FpLVNpZ24tQnVpbGRlci9mcm9udGVuZC9zcmMvbGliL2dyYXBoQ2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdyYXBoUUxDbGllbnQgfSBmcm9tICdncmFwaHFsLXJlcXVlc3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRyYWN0TWV0YWRhdGEge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGNoYWluSUQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICB2ZXJzaW9uOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBoYXNBcHByb3ZlZE1ldGFkYXRhOiBib29sZWFuO1xuICBsYXRlc3RTcGVjVGltZXN0YW1wOiBzdHJpbmc7XG4gIGZ1bmN0aW9uQ291bnQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbk1ldGFkYXRhIHtcbiAgc2VsZWN0b3I6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBpbnRlbnQ6IHN0cmluZztcbiAgcGFyYW1ldGVyVHlwZXM6IHN0cmluZ1tdO1xuICBkaXNwbGF5Rm9ybWF0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BlY0hpc3Rvcnkge1xuICBpZDogc3RyaW5nO1xuICBjcmVhdG9yOiBzdHJpbmc7XG4gIGlwZnNDSUQ6IHN0cmluZztcbiAgY3JlYXRlZFRpbWVzdGFtcDogc3RyaW5nO1xuICBzdGF0dXM6ICdDT01NSVRURUQnIHwgJ1NVQk1JVFRFRCcgfCAnUFJPUE9TRUQnIHwgJ0ZJTkFMSVpFRCcgfCAnQ0FOQ0VMTEVEJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUEZTTWV0YWRhdGEge1xuICBjb250ZXh0OiB7XG4gICAgY29udHJhY3Q6IHtcbiAgICAgIGRlcGxveWVkT246IHN0cmluZztcbiAgICAgIGRlcGxveW1lbnRBZGRyZXNzOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgbWV0YWRhdGE6IHtcbiAgICBhcHBEb21haW46IHN0cmluZztcbiAgICBjb25zdGFudHM6IFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgZW51bXM6IFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgZnVuY3Rpb25zOiBSZWNvcmQ8c3RyaW5nLCB7XG4gICAgICBpbnRlbnQ6IHN0cmluZztcbiAgICAgIGZpZWxkczogQXJyYXk8e1xuICAgICAgICBwYXRoOiBzdHJpbmc7XG4gICAgICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgICAgIGZvcm1hdDogc3RyaW5nO1xuICAgICAgICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgICAgfT47XG4gICAgfT47XG4gICAgb3duZXI6IHN0cmluZztcbiAgICBpbmZvOiB7XG4gICAgICBsZWdhbE5hbWU6IHN0cmluZztcbiAgICAgIGxhc3RVcGRhdGU6IHN0cmluZztcbiAgICAgIHZlcnNpb246IHN0cmluZztcbiAgICAgIHVybDogc3RyaW5nO1xuICAgIH07XG4gIH07XG59XG5cbmludGVyZmFjZSBTcGVjRGF0YSB7XG4gIGlkOiBzdHJpbmc7XG4gIHVzZXI6IHN0cmluZztcbiAgaXBmczogc3RyaW5nO1xuICBibG9ja1RpbWVzdGFtcDogc3RyaW5nO1xuICBzdGF0dXM6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEthaVNpZ25HcmFwaENsaWVudCB7XG4gIHByaXZhdGUgY2xpZW50OiBHcmFwaFFMQ2xpZW50O1xuICBcbiAgY29uc3RydWN0b3IoZ3JhcGhxbEVuZHBvaW50OiBzdHJpbmcpIHtcbiAgICB0aGlzLmNsaWVudCA9IG5ldyBHcmFwaFFMQ2xpZW50KGdyYXBocWxFbmRwb2ludCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbnRyYWN0cyB3aXRoIGFwcHJvdmVkIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIGNoYWluXG4gICAqIEFsd2F5cyByZXR1cm5zIGxhdGVzdCBtZXRhZGF0YSAoaGFuZGxlcyBkaXNwdXRlcyBhdXRvbWF0aWNhbGx5KVxuICAgKi9cbiAgYXN5bmMgZ2V0Q29udHJhY3RzV2l0aE1ldGFkYXRhKGNoYWluSUQ6IHN0cmluZyk6IFByb21pc2U8Q29udHJhY3RNZXRhZGF0YVtdPiB7XG4gICAgY29uc3QgcXVlcnkgPSBgXG4gICAgICBxdWVyeSBHZXRDb250cmFjdHMoJGNoYWluSUQ6IFN0cmluZyEpIHtcbiAgICAgICAgY29udHJhY3RzKHdoZXJlOiB7IGNoYWluSUQ6ICRjaGFpbklELCBoYXNBcHByb3ZlZE1ldGFkYXRhOiB0cnVlIH0pIHtcbiAgICAgICAgICBhZGRyZXNzXG4gICAgICAgICAgY2hhaW5JRFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICAgZGVzY3JpcHRpb25cbiAgICAgICAgICBoYXNBcHByb3ZlZE1ldGFkYXRhXG4gICAgICAgICAgbGF0ZXN0U3BlY1RpbWVzdGFtcFxuICAgICAgICAgIGZ1bmN0aW9uQ291bnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGA7XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdDx7IGNvbnRyYWN0czogQ29udHJhY3RNZXRhZGF0YVtdIH0+KHF1ZXJ5LCB7IGNoYWluSUQgfSk7XG4gICAgcmV0dXJuIGRhdGEuY29udHJhY3RzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0cmFuc2FjdGlvbiBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyBjb250cmFjdCBhbmQgc2VsZWN0b3JcbiAgICogQWx3YXlzIHVzZXMgbGF0ZXN0IGFwcHJvdmVkIG1ldGFkYXRhXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbk1ldGFkYXRhKFxuICAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLCBcbiAgICBzZWxlY3Rvcjogc3RyaW5nLCBcbiAgICBjaGFpbklEOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxGdW5jdGlvbk1ldGFkYXRhIHwgbnVsbD4ge1xuICAgIC8vIFF1ZXJ5IGZvciBzcGVjcyB0aGF0IHRhcmdldCB0aGlzIGNvbnRyYWN0XG4gICAgY29uc3QgcXVlcnkgPSBgXG4gICAgICBxdWVyeSBHZXRDb250cmFjdFNwZWNzKCR0YXJnZXRDb250cmFjdDogQnl0ZXMhLCAkY2hhaW5JRDogU3RyaW5nISkge1xuICAgICAgICBzcGVjcyh3aGVyZTogeyBcbiAgICAgICAgICB0YXJnZXRDb250cmFjdDogJHRhcmdldENvbnRyYWN0XG4gICAgICAgICAgY2hhaW5JRDogJGNoYWluSURcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlkXG4gICAgICAgICAgaXBmc1xuICAgICAgICAgIHVzZXJcbiAgICAgICAgICBzdGF0dXNcbiAgICAgICAgICBibG9ja1RpbWVzdGFtcFxuICAgICAgICB9XG4gICAgICB9XG4gICAgYDtcblxuICAgIGNvbnN0IHRhcmdldENvbnRyYWN0ID0gY29udHJhY3RBZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Q8eyBzcGVjczogU3BlY0RhdGFbXSB9PihcbiAgICAgIHF1ZXJ5LCBcbiAgICAgIHsgdGFyZ2V0Q29udHJhY3QsIGNoYWluSUQgfVxuICAgICk7XG4gICAgXG4gICAgLy8gSWYgd2UgaGF2ZSBzcGVjcywgcmV0dXJuIGEgcGxhY2Vob2xkZXIgaW5kaWNhdGluZyBtZXRhZGF0YSBpcyBhdmFpbGFibGVcbiAgICBpZiAoZGF0YS5zcGVjcyAmJiBkYXRhLnNwZWNzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgbmFtZTogYENvbnRyYWN0IEZ1bmN0aW9uICR7c2VsZWN0b3J9YCxcbiAgICAgICAgaW50ZW50OiBgRXhlY3V0ZSBmdW5jdGlvbiAke3NlbGVjdG9yfSBvbiBjb250cmFjdGAsXG4gICAgICAgIHBhcmFtZXRlclR5cGVzOiBbXSxcbiAgICAgICAgZGlzcGxheUZvcm1hdDogYGZ1bmN0aW9uXyR7c2VsZWN0b3Iuc2xpY2UoMiwgMTApfWBcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjb21wbGV0ZSBjb250cmFjdCBtZXRhZGF0YSB3aXRoIElQRlMgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0Q29tcGxldGVDb250cmFjdE1ldGFkYXRhKGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLCBjaGFpbklEOiBzdHJpbmcpOiBQcm9taXNlPHsgc3BlY3M6IFNwZWNEYXRhW10sIGlwZnNNZXRhZGF0YT86IElQRlNNZXRhZGF0YSB9PiB7XG4gICAgY29uc3QgcXVlcnkgPSBgXG4gICAgICBxdWVyeSBHZXRDb250cmFjdFNwZWNzKCR0YXJnZXRDb250cmFjdDogQnl0ZXMhLCAkY2hhaW5JRDogU3RyaW5nISkge1xuICAgICAgICBzcGVjcyh3aGVyZTogeyBcbiAgICAgICAgICB0YXJnZXRDb250cmFjdDogJHRhcmdldENvbnRyYWN0XG4gICAgICAgICAgY2hhaW5JRDogJGNoYWluSURcbiAgICAgICAgfVxuICAgICAgICBvcmRlckJ5OiBibG9ja1RpbWVzdGFtcFxuICAgICAgICBvcmRlckRpcmVjdGlvbjogZGVzYykge1xuICAgICAgICAgIGlkXG4gICAgICAgICAgaXBmc1xuICAgICAgICAgIHVzZXJcbiAgICAgICAgICBzdGF0dXNcbiAgICAgICAgICBibG9ja1RpbWVzdGFtcFxuICAgICAgICAgIHRhcmdldENvbnRyYWN0XG4gICAgICAgICAgY2hhaW5JRFxuICAgICAgICB9XG4gICAgICB9XG4gICAgYDtcblxuICAgIGNvbnN0IHRhcmdldENvbnRyYWN0ID0gY29udHJhY3RBZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Q8eyBzcGVjczogU3BlY0RhdGFbXSB9PihcbiAgICAgIHF1ZXJ5LCBcbiAgICAgIHsgdGFyZ2V0Q29udHJhY3QsIGNoYWluSUQgfVxuICAgICk7XG4gICAgXG4gICAgbGV0IGlwZnNNZXRhZGF0YTogSVBGU01ldGFkYXRhIHwgdW5kZWZpbmVkO1xuICAgIFxuICAgIC8vIFRyeSB0byBmZXRjaCBJUEZTIG1ldGFkYXRhIGZyb20gdGhlIG1vc3QgcmVjZW50IHNwZWNcbiAgICBpZiAoZGF0YS5zcGVjcyAmJiBkYXRhLnNwZWNzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxhdGVzdFNwZWMgPSBkYXRhLnNwZWNzWzBdO1xuICAgICAgaWYgKGxhdGVzdFNwZWMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBbHdheXMgZmV0Y2ggZnJvbSBJUEZTIGdhdGV3YXlzIGZvciByZWFsIGRhdGFcbiAgICAgICAgICBjb25zdCBnYXRld2F5cyA9IFtcbiAgICAgICAgICAgIGBodHRwczovL2dhdGV3YXkucGluYXRhLmNsb3VkL2lwZnMvJHtsYXRlc3RTcGVjLmlwZnN9YCxcbiAgICAgICAgICAgIGBodHRwczovL2lwZnMuaW8vaXBmcy8ke2xhdGVzdFNwZWMuaXBmc31gLFxuICAgICAgICAgICAgYGh0dHBzOi8vZHdlYi5saW5rL2lwZnMvJHtsYXRlc3RTcGVjLmlwZnN9YCxcbiAgICAgICAgICAgIGBodHRwczovL2Nsb3VkZmxhcmUtaXBmcy5jb20vaXBmcy8ke2xhdGVzdFNwZWMuaXBmc31gXG4gICAgICAgICAgXTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgcmVhbCBJUEZTIGRhdGEgZm9yIGhhc2g6ICR7bGF0ZXN0U3BlYy5pcGZzfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIGZvciAoY29uc3QgZ2F0ZXdheSBvZiBnYXRld2F5cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFRyeWluZyBJUEZTIGdhdGV3YXk6ICR7Z2F0ZXdheX1gKTtcbiAgICAgICAgICAgICAgY29uc3QgaXBmc1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2goZ2F0ZXdheSwge1xuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCgxNTAwMCkgLy8gMTUgc2Vjb25kIHRpbWVvdXQgcGVyIGdhdGV3YXlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChpcGZzUmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICBpcGZzTWV0YWRhdGEgPSBhd2FpdCBpcGZzUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgZmV0Y2hlZCByZWFsIG1ldGFkYXRhIGZyb206ICR7Z2F0ZXdheX1gKTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gU3VjY2VzcywgZXhpdCB0aGUgbG9vcFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgR2F0ZXdheSAke2dhdGV3YXl9IGZhaWxlZDpgLCBlcnJvcik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBUcnkgbmV4dCBnYXRld2F5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmICghaXBmc01ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBJUEZTIG1ldGFkYXRhIGZvciBoYXNoOiAke2xhdGVzdFNwZWMuaXBmc30uIEFsbCBJUEZTIGdhdGV3YXlzIGZhaWxlZC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBmZXRjaCBJUEZTIG1ldGFkYXRhOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBzcGVjczogZGF0YS5zcGVjcywgaXBmc01ldGFkYXRhIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRpc3B1dGUvcmVwbGFjZW1lbnQgaGlzdG9yeSBmb3IgYSBjb250cmFjdFxuICAgKiBTaG93cyBhbGwgZmluYWxpemVkIHNwZWNzIG9yZGVyZWQgYnkgbmV3ZXN0IGZpcnN0XG4gICAqL1xuICBhc3luYyBnZXRDb250cmFjdFNwZWNIaXN0b3J5KGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLCBjaGFpbklEOiBzdHJpbmcpOiBQcm9taXNlPFNwZWNIaXN0b3J5W10+IHtcbiAgICBjb25zdCBxdWVyeSA9IGBcbiAgICAgIHF1ZXJ5IEdldFNwZWNIaXN0b3J5KCR0YXJnZXRDb250cmFjdDogQnl0ZXMhLCAkY2hhaW5JRDogU3RyaW5nISkge1xuICAgICAgICBzcGVjcyhcbiAgICAgICAgICB3aGVyZTogeyBcbiAgICAgICAgICAgIHRhcmdldENvbnRyYWN0OiAkdGFyZ2V0Q29udHJhY3RcbiAgICAgICAgICAgIGNoYWluSUQ6ICRjaGFpbklEXG4gICAgICAgICAgICBzdGF0dXM6IEZJTkFMSVpFRFxuICAgICAgICAgIH1cbiAgICAgICAgICBvcmRlckJ5OiBibG9ja1RpbWVzdGFtcFxuICAgICAgICAgIG9yZGVyRGlyZWN0aW9uOiBkZXNjXG4gICAgICAgICkge1xuICAgICAgICAgIGlkXG4gICAgICAgICAgdXNlclxuICAgICAgICAgIGlwZnNcbiAgICAgICAgICBibG9ja1RpbWVzdGFtcFxuICAgICAgICAgIHN0YXR1c1xuICAgICAgICB9XG4gICAgICB9XG4gICAgYDtcblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0PHsgc3BlY3M6IFNwZWNEYXRhW10gfT4ocXVlcnksIHsgXG4gICAgICB0YXJnZXRDb250cmFjdDogY29udHJhY3RBZGRyZXNzLnRvTG93ZXJDYXNlKCksIFxuICAgICAgY2hhaW5JRCBcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gZGF0YS5zcGVjcy5tYXAoKHNwZWM6IFNwZWNEYXRhKSA9PiAoe1xuICAgICAgaWQ6IHNwZWMuaWQsXG4gICAgICBjcmVhdG9yOiBzcGVjLnVzZXIsXG4gICAgICBpcGZzQ0lEOiBzcGVjLmlwZnMsXG4gICAgICBjcmVhdGVkVGltZXN0YW1wOiBzcGVjLmJsb2NrVGltZXN0YW1wLFxuICAgICAgc3RhdHVzOiBzcGVjLnN0YXR1cyBhcyBTcGVjSGlzdG9yeVsnc3RhdHVzJ11cbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBmdW5jdGlvbnMgZm9yIGEgc3BlY2lmaWMgY29udHJhY3RcbiAgICovXG4gIGFzeW5jIGdldENvbnRyYWN0RnVuY3Rpb25zKGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLCBjaGFpbklEOiBzdHJpbmcpOiBQcm9taXNlPEZ1bmN0aW9uTWV0YWRhdGFbXT4ge1xuICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgcXVlcnkgR2V0Q29udHJhY3RGdW5jdGlvbnMoJGNvbnRyYWN0SWQ6IFN0cmluZyEpIHtcbiAgICAgICAgZnVuY3Rpb25zKHdoZXJlOiB7IGNvbnRyYWN0OiAkY29udHJhY3RJZCB9KSB7XG4gICAgICAgICAgc2VsZWN0b3JcbiAgICAgICAgICBuYW1lXG4gICAgICAgICAgaW50ZW50XG4gICAgICAgICAgcGFyYW1ldGVyVHlwZXNcbiAgICAgICAgICBkaXNwbGF5Rm9ybWF0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBgO1xuXG4gICAgY29uc3QgY29udHJhY3RJZCA9IGAke2NvbnRyYWN0QWRkcmVzcy50b0xvd2VyQ2FzZSgpfS0ke2NoYWluSUR9YDtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdDx7IGZ1bmN0aW9uczogRnVuY3Rpb25NZXRhZGF0YVtdIH0+KHF1ZXJ5LCB7IGNvbnRyYWN0SWQgfSk7XG4gICAgXG4gICAgcmV0dXJuIGRhdGEuZnVuY3Rpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBjb250cmFjdHMgYnkgbmFtZVxuICAgKi9cbiAgYXN5bmMgc2VhcmNoQ29udHJhY3RzKHNlYXJjaFRlcm06IHN0cmluZywgY2hhaW5JRD86IHN0cmluZyk6IFByb21pc2U8Q29udHJhY3RNZXRhZGF0YVtdPiB7XG4gICAgY29uc3Qgd2hlcmVDbGF1c2UgPSBjaGFpbklEIFxuICAgICAgPyBgeyBoYXNBcHByb3ZlZE1ldGFkYXRhOiB0cnVlLCBjaGFpbklEOiBcIiR7Y2hhaW5JRH1cIiwgbmFtZV9jb250YWluc19ub2Nhc2U6IFwiJHtzZWFyY2hUZXJtfVwiIH1gXG4gICAgICA6IGB7IGhhc0FwcHJvdmVkTWV0YWRhdGE6IHRydWUsIG5hbWVfY29udGFpbnNfbm9jYXNlOiBcIiR7c2VhcmNoVGVybX1cIiB9YDtcblxuICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgcXVlcnkgU2VhcmNoQ29udHJhY3RzIHtcbiAgICAgICAgY29udHJhY3RzKHdoZXJlOiAke3doZXJlQ2xhdXNlfSkge1xuICAgICAgICAgIGFkZHJlc3NcbiAgICAgICAgICBjaGFpbklEXG4gICAgICAgICAgbmFtZVxuICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgICBkZXNjcmlwdGlvblxuICAgICAgICAgIGhhc0FwcHJvdmVkTWV0YWRhdGFcbiAgICAgICAgICBsYXRlc3RTcGVjVGltZXN0YW1wXG4gICAgICAgICAgZnVuY3Rpb25Db3VudFxuICAgICAgICB9XG4gICAgICB9XG4gICAgYDtcblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0PHsgY29udHJhY3RzOiBDb250cmFjdE1ldGFkYXRhW10gfT4ocXVlcnkpO1xuICAgIHJldHVybiBkYXRhLmNvbnRyYWN0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGZpbmFsaXplZCBzcGVjaWZpY2F0aW9ucyBjcmVhdGVkIGJ5IGEgc3BlY2lmaWMgdXNlclxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlckZpbmFsaXplZFNwZWNzKHVzZXJBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPFNwZWNIaXN0b3J5W10+IHtcbiAgICBjb25zdCBxdWVyeSA9IGBcbiAgICAgIHF1ZXJ5IEdldFVzZXJGaW5hbGl6ZWRTcGVjcygkdXNlcjogQnl0ZXMhKSB7XG4gICAgICAgIHNwZWNzKFxuICAgICAgICAgIHdoZXJlOiB7IFxuICAgICAgICAgICAgdXNlcjogJHVzZXJcbiAgICAgICAgICAgIHN0YXR1czogRklOQUxJWkVEXG4gICAgICAgICAgfVxuICAgICAgICAgIG9yZGVyQnk6IGJsb2NrVGltZXN0YW1wXG4gICAgICAgICAgb3JkZXJEaXJlY3Rpb246IGRlc2NcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWRcbiAgICAgICAgICB1c2VyXG4gICAgICAgICAgaXBmc1xuICAgICAgICAgIHRhcmdldENvbnRyYWN0XG4gICAgICAgICAgYmxvY2tUaW1lc3RhbXBcbiAgICAgICAgICBzdGF0dXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGA7XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdDx7IHNwZWNzOiBhbnlbXSB9PihxdWVyeSwgeyBcbiAgICAgIHVzZXI6IHVzZXJBZGRyZXNzLnRvTG93ZXJDYXNlKClcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEuc3BlY3MpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRhdGEuc3BlY3MubWFwKChzcGVjOiBhbnkpID0+ICh7XG4gICAgICBpZDogc3BlYy5pZCxcbiAgICAgIGNyZWF0b3I6IHNwZWMudXNlcixcbiAgICAgIGlwZnNDSUQ6IHNwZWMuaXBmcyxcbiAgICAgIGNyZWF0ZWRUaW1lc3RhbXA6IHNwZWMuYmxvY2tUaW1lc3RhbXAsXG4gICAgICBzdGF0dXM6IHNwZWMuc3RhdHVzIGFzIFNwZWNIaXN0b3J5WydzdGF0dXMnXSxcbiAgICAgIHRhcmdldENvbnRyYWN0OiBzcGVjLnRhcmdldENvbnRyYWN0LFxuICAgICAgdG90YWxCb25kczogXCIwXCIsIC8vIERlZmF1bHQgc2luY2Ugbm90IGF2YWlsYWJsZSBpbiBzdWJncmFwaFxuICAgICAgYm9uZHNTZXR0bGVkOiBmYWxzZSwgLy8gRGVmYXVsdCBzaW5jZSBub3QgYXZhaWxhYmxlIGluIHN1YmdyYXBoXG4gICAgICBwcm9wb3NlZFRpbWVzdGFtcDogc3BlYy5ibG9ja1RpbWVzdGFtcCAvLyBVc2UgYmxvY2tUaW1lc3RhbXAgYXMgZmFsbGJhY2tcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBzcGVjaWZpY2F0aW9ucyAoYW55IHN0YXR1cykgY3JlYXRlZCBieSBhIHNwZWNpZmljIHVzZXJcbiAgICovXG4gIGFzeW5jIGdldFVzZXJTcGVjcyh1c2VyQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxTcGVjSGlzdG9yeVtdPiB7XG4gICAgY29uc3QgcXVlcnkgPSBgXG4gICAgICBxdWVyeSBHZXRVc2VyU3BlY3MoJHVzZXI6IEJ5dGVzISkge1xuICAgICAgICBzcGVjcyhcbiAgICAgICAgICB3aGVyZTogeyBcbiAgICAgICAgICAgIHVzZXI6ICR1c2VyXG4gICAgICAgICAgfVxuICAgICAgICAgIG9yZGVyQnk6IGJsb2NrVGltZXN0YW1wXG4gICAgICAgICAgb3JkZXJEaXJlY3Rpb246IGRlc2NcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWRcbiAgICAgICAgICB1c2VyXG4gICAgICAgICAgaXBmc1xuICAgICAgICAgIHRhcmdldENvbnRyYWN0XG4gICAgICAgICAgYmxvY2tUaW1lc3RhbXBcbiAgICAgICAgICBzdGF0dXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGA7XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdDx7IHNwZWNzOiBhbnlbXSB9PihxdWVyeSwgeyBcbiAgICAgIHVzZXI6IHVzZXJBZGRyZXNzLnRvTG93ZXJDYXNlKClcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEuc3BlY3MpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRhdGEuc3BlY3MubWFwKChzcGVjOiBhbnkpID0+ICh7XG4gICAgICBpZDogc3BlYy5pZCxcbiAgICAgIGNyZWF0b3I6IHNwZWMudXNlcixcbiAgICAgIGlwZnNDSUQ6IHNwZWMuaXBmcyxcbiAgICAgIGNyZWF0ZWRUaW1lc3RhbXA6IHNwZWMuYmxvY2tUaW1lc3RhbXAsXG4gICAgICBzdGF0dXM6IHNwZWMuc3RhdHVzIGFzIFNwZWNIaXN0b3J5WydzdGF0dXMnXSxcbiAgICAgIHRhcmdldENvbnRyYWN0OiBzcGVjLnRhcmdldENvbnRyYWN0LFxuICAgICAgdG90YWxCb25kczogXCIwXCIsIC8vIERlZmF1bHQgc2luY2Ugbm90IGF2YWlsYWJsZSBpbiBzdWJncmFwaFxuICAgICAgYm9uZHNTZXR0bGVkOiBmYWxzZSwgLy8gRGVmYXVsdCBzaW5jZSBub3QgYXZhaWxhYmxlIGluIHN1YmdyYXBoXG4gICAgICBwcm9wb3NlZFRpbWVzdGFtcDogc3BlYy5ibG9ja1RpbWVzdGFtcCAvLyBVc2UgYmxvY2tUaW1lc3RhbXAgYXMgZmFsbGJhY2tcbiAgICB9KSk7XG4gIH1cbn1cblxuLy8gRGVmYXVsdCBjbGllbnQgaW5zdGFuY2UgZm9yIGNvbW1vbiBuZXR3b3Jrc1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUthaVNpZ25DbGllbnQgPSAobmV0d29yazogJ21haW5uZXQnIHwgJ3NlcG9saWEnIHwgc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGVuZHBvaW50cyA9IHtcbiAgICBtYWlubmV0OiAnaHR0cHM6Ly9hcGkudGhlZ3JhcGguY29tL3N1YmdyYXBocy9uYW1lL2thaS1zaWduL2thaXNpZ24tbWFpbm5ldCcsXG4gICAgc2Vwb2xpYTogJ2h0dHBzOi8vYXBpLnN0dWRpby50aGVncmFwaC5jb20vcXVlcnkvMTE3MDIyL2thaXNpZ24tc3ViZ3JhcGgvdjAuMC4zJyxcbiAgfTtcblxuICBjb25zdCBlbmRwb2ludCA9IGVuZHBvaW50c1tuZXR3b3JrIGFzIGtleW9mIHR5cGVvZiBlbmRwb2ludHNdIHx8IG5ldHdvcms7XG4gIHJldHVybiBuZXcgS2FpU2lnbkdyYXBoQ2xpZW50KGVuZHBvaW50KTtcbn07XG5cbi8vIFJlLWV4cG9ydCBmb3IgY29udmVuaWVuY2VcbmV4cG9ydCBkZWZhdWx0IEthaVNpZ25HcmFwaENsaWVudDtcbiJdLCJuYW1lcyI6WyJHcmFwaFFMQ2xpZW50IiwiS2FpU2lnbkdyYXBoQ2xpZW50IiwiY29uc3RydWN0b3IiLCJncmFwaHFsRW5kcG9pbnQiLCJjbGllbnQiLCJnZXRDb250cmFjdHNXaXRoTWV0YWRhdGEiLCJjaGFpbklEIiwicXVlcnkiLCJkYXRhIiwicmVxdWVzdCIsImNvbnRyYWN0cyIsImdldFRyYW5zYWN0aW9uTWV0YWRhdGEiLCJjb250cmFjdEFkZHJlc3MiLCJzZWxlY3RvciIsInRhcmdldENvbnRyYWN0IiwidG9Mb3dlckNhc2UiLCJzcGVjcyIsImxlbmd0aCIsIm5hbWUiLCJpbnRlbnQiLCJwYXJhbWV0ZXJUeXBlcyIsImRpc3BsYXlGb3JtYXQiLCJzbGljZSIsImdldENvbXBsZXRlQ29udHJhY3RNZXRhZGF0YSIsImlwZnNNZXRhZGF0YSIsImxhdGVzdFNwZWMiLCJnYXRld2F5cyIsImlwZnMiLCJjb25zb2xlIiwibG9nIiwiZ2F0ZXdheSIsImlwZnNSZXNwb25zZSIsImZldGNoIiwic2lnbmFsIiwiQWJvcnRTaWduYWwiLCJ0aW1lb3V0Iiwib2siLCJqc29uIiwiZXJyb3IiLCJFcnJvciIsImdldENvbnRyYWN0U3BlY0hpc3RvcnkiLCJtYXAiLCJzcGVjIiwiaWQiLCJjcmVhdG9yIiwidXNlciIsImlwZnNDSUQiLCJjcmVhdGVkVGltZXN0YW1wIiwiYmxvY2tUaW1lc3RhbXAiLCJzdGF0dXMiLCJnZXRDb250cmFjdEZ1bmN0aW9ucyIsImNvbnRyYWN0SWQiLCJmdW5jdGlvbnMiLCJzZWFyY2hDb250cmFjdHMiLCJzZWFyY2hUZXJtIiwid2hlcmVDbGF1c2UiLCJnZXRVc2VyRmluYWxpemVkU3BlY3MiLCJ1c2VyQWRkcmVzcyIsInRvdGFsQm9uZHMiLCJib25kc1NldHRsZWQiLCJwcm9wb3NlZFRpbWVzdGFtcCIsImdldFVzZXJTcGVjcyIsImNyZWF0ZUthaVNpZ25DbGllbnQiLCJuZXR3b3JrIiwiZW5kcG9pbnRzIiwibWFpbm5ldCIsInNlcG9saWEiLCJlbmRwb2ludCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/graphClient.ts\n");

/***/ })

};
;