"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_src_lib_blobService_ts";
exports.ids = ["_ssr_src_lib_blobService_ts"];
exports.modules = {

/***/ "(ssr)/./src/lib/blobService.ts":
/*!********************************!*\
  !*** ./src/lib/blobService.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   postToBlob: () => (/* binding */ postToBlob),\n/* harmony export */   postToBlobWithValidation: () => (/* binding */ postToBlobWithValidation),\n/* harmony export */   validateBlobHash: () => (/* binding */ validateBlobHash),\n/* harmony export */   validateMultipleBlobHashes: () => (/* binding */ validateMultipleBlobHashes)\n/* harmony export */ });\n/* harmony import */ var _blobValidationService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blobValidationService */ \"(ssr)/./src/lib/blobValidationService.ts\");\n\nasync function postToBlob(json) {\n    const body = typeof json === 'string' ? {\n        json\n    } : {\n        json\n    };\n    const res = await fetch('/api/blob/submit', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(body)\n    });\n    if (!res.ok) {\n        const text = await res.text().catch(()=>'');\n        throw new Error(text || `HTTP ${res.status}`);\n    }\n    const data = await res.json();\n    if (!data?.blobVersionedHash) {\n        throw new Error('Blob upload did not return versioned hash');\n    }\n    return data;\n}\n/**\n * Validates a blob hash before using it in transactions\n */ async function validateBlobHash(blobHash) {\n    return await _blobValidationService__WEBPACK_IMPORTED_MODULE_0__.blobValidationService.validateBlobHash(blobHash);\n}\n/**\n * Validates multiple blob hashes at once\n */ async function validateMultipleBlobHashes(blobHashes) {\n    return await _blobValidationService__WEBPACK_IMPORTED_MODULE_0__.blobValidationService.validateMultipleBlobHashes(blobHashes);\n}\n/**\n * Posts blob and validates the result\n */ async function postToBlobWithValidation(json) {\n    const result = await postToBlob(json);\n    // Validate the returned blob hash\n    const validation = await validateBlobHash(result.blobVersionedHash);\n    if (!validation.isValid || !validation.exists) {\n        throw new Error(`Blob posted but validation failed: ${validation.error || 'Unknown error'}`);\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvbGliL2Jsb2JTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNGO0FBUy9FLGVBQWVDLFdBQVdDLElBQXFCO0lBQ3BELE1BQU1DLE9BQU8sT0FBT0QsU0FBUyxXQUFXO1FBQUVBO0lBQUssSUFBSTtRQUFFQTtJQUFLO0lBQzFELE1BQU1FLE1BQU0sTUFBTUMsTUFBTSxvQkFBb0I7UUFDMUNDLFFBQVE7UUFDUkMsU0FBUztZQUFFLGdCQUFnQjtRQUFtQjtRQUM5Q0osTUFBTUssS0FBS0MsU0FBUyxDQUFDTjtJQUN2QjtJQUNBLElBQUksQ0FBQ0MsSUFBSU0sRUFBRSxFQUFFO1FBQ1gsTUFBTUMsT0FBTyxNQUFNUCxJQUFJTyxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFNO1FBQzFDLE1BQU0sSUFBSUMsTUFBTUYsUUFBUSxDQUFDLEtBQUssRUFBRVAsSUFBSVUsTUFBTSxFQUFFO0lBQzlDO0lBQ0EsTUFBTUMsT0FBTyxNQUFNWCxJQUFJRixJQUFJO0lBQzNCLElBQUksQ0FBQ2EsTUFBTUMsbUJBQW1CO1FBQzVCLE1BQU0sSUFBSUgsTUFBTTtJQUNsQjtJQUNBLE9BQU9FO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLGVBQWVFLGlCQUFpQkMsUUFBZ0I7SUFDckQsT0FBTyxNQUFNbEIseUVBQXFCQSxDQUFDaUIsZ0JBQWdCLENBQUNDO0FBQ3REO0FBRUE7O0NBRUMsR0FDTSxlQUFlQywyQkFBMkJDLFVBQW9CO0lBQ25FLE9BQU8sTUFBTXBCLHlFQUFxQkEsQ0FBQ21CLDBCQUEwQixDQUFDQztBQUNoRTtBQUVBOztDQUVDLEdBQ00sZUFBZUMseUJBQXlCbkIsSUFBcUI7SUFDbEUsTUFBTW9CLFNBQVMsTUFBTXJCLFdBQVdDO0lBRWhDLGtDQUFrQztJQUNsQyxNQUFNcUIsYUFBYSxNQUFNTixpQkFBaUJLLE9BQU9OLGlCQUFpQjtJQUNsRSxJQUFJLENBQUNPLFdBQVdDLE9BQU8sSUFBSSxDQUFDRCxXQUFXRSxNQUFNLEVBQUU7UUFDN0MsTUFBTSxJQUFJWixNQUFNLENBQUMsbUNBQW1DLEVBQUVVLFdBQVdHLEtBQUssSUFBSSxpQkFBaUI7SUFDN0Y7SUFFQSxPQUFPSjtBQUNUIiwic291cmNlcyI6WyIvVXNlcnMvcmljaGFyZGhhL0RvY3VtZW50cy/ou5/pq5Tlt6XnqIsvUHJvamVjdHMvS2FpLVNpZ24tQnVpbGRlci9mcm9udGVuZC9zcmMvbGliL2Jsb2JTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJsb2JWYWxpZGF0aW9uU2VydmljZSwgQmxvYlZhbGlkYXRpb25SZXN1bHQgfSBmcm9tICcuL2Jsb2JWYWxpZGF0aW9uU2VydmljZSc7XG5cbmV4cG9ydCB0eXBlIEJsb2JQb3N0UmVzdWx0ID0ge1xuICB0eEhhc2g6IHN0cmluZztcbiAgYmxvYlZlcnNpb25lZEhhc2g6IHN0cmluZztcbiAgZXRoZXJzY2FuQmxvYlVybDogc3RyaW5nO1xuICBibG9ja051bWJlcj86IG51bWJlciB8IG51bGw7XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcG9zdFRvQmxvYihqc29uOiBvYmplY3QgfCBzdHJpbmcpOiBQcm9taXNlPEJsb2JQb3N0UmVzdWx0PiB7XG4gIGNvbnN0IGJvZHkgPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyB7IGpzb24gfSA6IHsganNvbiB9O1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9ibG9iL3N1Ym1pdCcsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgfSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCkuY2F0Y2goKCkgPT4gJycpO1xuICAgIHRocm93IG5ldyBFcnJvcih0ZXh0IHx8IGBIVFRQICR7cmVzLnN0YXR1c31gKTtcbiAgfVxuICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgaWYgKCFkYXRhPy5ibG9iVmVyc2lvbmVkSGFzaCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmxvYiB1cGxvYWQgZGlkIG5vdCByZXR1cm4gdmVyc2lvbmVkIGhhc2gnKTtcbiAgfVxuICByZXR1cm4gZGF0YSBhcyBCbG9iUG9zdFJlc3VsdDtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBibG9iIGhhc2ggYmVmb3JlIHVzaW5nIGl0IGluIHRyYW5zYWN0aW9uc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVCbG9iSGFzaChibG9iSGFzaDogc3RyaW5nKTogUHJvbWlzZTxCbG9iVmFsaWRhdGlvblJlc3VsdD4ge1xuICByZXR1cm4gYXdhaXQgYmxvYlZhbGlkYXRpb25TZXJ2aWNlLnZhbGlkYXRlQmxvYkhhc2goYmxvYkhhc2gpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBtdWx0aXBsZSBibG9iIGhhc2hlcyBhdCBvbmNlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZU11bHRpcGxlQmxvYkhhc2hlcyhibG9iSGFzaGVzOiBzdHJpbmdbXSk6IFByb21pc2U8TWFwPHN0cmluZywgQmxvYlZhbGlkYXRpb25SZXN1bHQ+PiB7XG4gIHJldHVybiBhd2FpdCBibG9iVmFsaWRhdGlvblNlcnZpY2UudmFsaWRhdGVNdWx0aXBsZUJsb2JIYXNoZXMoYmxvYkhhc2hlcyk7XG59XG5cbi8qKlxuICogUG9zdHMgYmxvYiBhbmQgdmFsaWRhdGVzIHRoZSByZXN1bHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBvc3RUb0Jsb2JXaXRoVmFsaWRhdGlvbihqc29uOiBvYmplY3QgfCBzdHJpbmcpOiBQcm9taXNlPEJsb2JQb3N0UmVzdWx0PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBvc3RUb0Jsb2IoanNvbik7XG4gIFxuICAvLyBWYWxpZGF0ZSB0aGUgcmV0dXJuZWQgYmxvYiBoYXNoXG4gIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0ZUJsb2JIYXNoKHJlc3VsdC5ibG9iVmVyc2lvbmVkSGFzaCk7XG4gIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkIHx8ICF2YWxpZGF0aW9uLmV4aXN0cykge1xuICAgIHRocm93IG5ldyBFcnJvcihgQmxvYiBwb3N0ZWQgYnV0IHZhbGlkYXRpb24gZmFpbGVkOiAke3ZhbGlkYXRpb24uZXJyb3IgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbiJdLCJuYW1lcyI6WyJibG9iVmFsaWRhdGlvblNlcnZpY2UiLCJwb3N0VG9CbG9iIiwianNvbiIsImJvZHkiLCJyZXMiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJ0ZXh0IiwiY2F0Y2giLCJFcnJvciIsInN0YXR1cyIsImRhdGEiLCJibG9iVmVyc2lvbmVkSGFzaCIsInZhbGlkYXRlQmxvYkhhc2giLCJibG9iSGFzaCIsInZhbGlkYXRlTXVsdGlwbGVCbG9iSGFzaGVzIiwiYmxvYkhhc2hlcyIsInBvc3RUb0Jsb2JXaXRoVmFsaWRhdGlvbiIsInJlc3VsdCIsInZhbGlkYXRpb24iLCJpc1ZhbGlkIiwiZXhpc3RzIiwiZXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/lib/blobService.ts\n");

/***/ }),

/***/ "(ssr)/./src/lib/blobValidationService.ts":
/*!******************************************!*\
  !*** ./src/lib/blobValidationService.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobValidationService: () => (/* binding */ BlobValidationService),\n/* harmony export */   blobValidationService: () => (/* binding */ blobValidationService)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(ssr)/../node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(ssr)/../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(ssr)/../node_modules/ethers/lib.esm/utils/utf8.js\");\n\nclass BlobValidationService {\n    constructor(rpcUrl){\n        this.provider = null;\n        if (rpcUrl) {\n            this.provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider(rpcUrl);\n        } else if (false) {}\n    }\n    /**\n   * Validates blob hash format and checks if it exists on-chain\n   */ async validateBlobHash(blobHash) {\n        try {\n            // Step 1: Basic format validation\n            const formatValidation = this.validateBlobHashFormat(blobHash);\n            if (!formatValidation.isValid) {\n                return formatValidation;\n            }\n            // Step 2: Check if blob exists on-chain\n            const existenceCheck = await this.checkBlobExists(blobHash);\n            if (!existenceCheck.exists) {\n                return {\n                    isValid: false,\n                    exists: false,\n                    error: `Blob hash ${blobHash} does not exist on-chain. This could be because:\n1. The blob was never posted to the blockchain\n2. The blob hash is incorrect\n3. The blob transaction failed or was reverted\n4. You're checking on the wrong network (should be Sepolia)`\n                };\n            }\n            return {\n                isValid: true,\n                exists: true,\n                blobData: existenceCheck.blobData\n            };\n        } catch (error) {\n            console.error('Blob validation error:', error);\n            return {\n                isValid: false,\n                exists: false,\n                error: `Validation failed: ${error instanceof Error ? error.message : String(error)}`\n            };\n        }\n    }\n    /**\n   * Validates the basic format of a blob hash\n   */ validateBlobHashFormat(blobHash) {\n        // Check if it's a string\n        if (typeof blobHash !== 'string') {\n            return {\n                isValid: false,\n                exists: false,\n                error: 'Blob hash must be a string'\n            };\n        }\n        // Check if it starts with 0x01 (EIP-4844 blob version)\n        if (!blobHash.startsWith('0x01')) {\n            return {\n                isValid: false,\n                exists: false,\n                error: 'Blob hash must start with 0x01 (EIP-4844 blob version)'\n            };\n        }\n        // Check if it's exactly 66 characters (0x + 64 hex chars)\n        if (blobHash.length !== 66) {\n            return {\n                isValid: false,\n                exists: false,\n                error: `Blob hash must be exactly 66 characters (got ${blobHash.length}). Expected format: 0x01 + 64 hex characters`\n            };\n        }\n        // Check if it contains only valid hex characters\n        const hexRegex = /^0x01[a-fA-F0-9]{64}$/;\n        if (!hexRegex.test(blobHash)) {\n            // Find the first invalid character for better error reporting\n            const afterPrefix = blobHash.substring(4); // Remove \"0x01\"\n            let invalidChar = '';\n            let invalidPos = -1;\n            for(let i = 0; i < afterPrefix.length; i++){\n                const char = afterPrefix[i];\n                if (!/[0-9a-fA-F]/.test(char)) {\n                    invalidChar = char;\n                    invalidPos = i + 4; // +4 to account for \"0x01\" prefix\n                    break;\n                }\n            }\n            const errorMessage = invalidChar ? `Invalid character '${invalidChar}' at position ${invalidPos}. Only hex characters (0-9, a-f, A-F) are allowed after 0x01` : 'Blob hash contains invalid characters. Only hex characters (0-9, a-f, A-F) are allowed after 0x01';\n            return {\n                isValid: false,\n                exists: false,\n                error: errorMessage\n            };\n        }\n        // Check for common invalid patterns\n        if (blobHash === '0x010000000000000000000000000000000000000000000000000000000000000000') {\n            return {\n                isValid: false,\n                exists: false,\n                error: 'This is a zero blob hash which is invalid. Blob hashes cannot be all zeros.'\n            };\n        }\n        // Check for the specific invalid example mentioned\n        if (blobHash === '0x0100000000000') {\n            return {\n                isValid: false,\n                exists: false,\n                error: 'This blob hash is too short and invalid. Valid blob hashes must be 66 characters long starting with 0x01.'\n            };\n        }\n        return {\n            isValid: true,\n            exists: false // Will be checked in next step\n        };\n    }\n    /**\n   * Checks if a blob hash actually exists on the blockchain\n   */ async checkBlobExists(blobHash) {\n        if (!this.provider) {\n            throw new Error('No provider available for blockchain queries');\n        }\n        try {\n            // Method 1: Try to get blob data using eth_getBlobByHash (if supported)\n            try {\n                const blobData = await this.provider.send('eth_getBlobByHash', [\n                    blobHash\n                ]);\n                if (blobData && blobData !== '0x') {\n                    return {\n                        exists: true,\n                        blobData: {\n                            txHash: 'Unknown',\n                            blockNumber: 0,\n                            blobIndex: 0,\n                            etherscanUrl: `https://sepolia.etherscan.io/blob/${blobHash}`\n                        }\n                    };\n                }\n            } catch (blobError) {\n                // eth_getBlobByHash might not be supported by all RPCs\n                console.log('eth_getBlobByHash not supported, trying alternative methods');\n            }\n            // Method 2: Search for blob transactions in recent blocks\n            const currentBlock = await this.provider.getBlockNumber();\n            const searchBlocks = Math.min(1000, currentBlock); // Search last 1000 blocks\n            for(let i = 0; i < searchBlocks; i += 10){\n                const blockNumber = currentBlock - i;\n                try {\n                    const block = await this.provider.getBlock(blockNumber, true);\n                    if (!block || !block.transactions) continue;\n                    for (const tx of block.transactions){\n                        if (tx && typeof tx === 'object' && 'type' in tx && tx.type === 3 && 'blobVersionedHashes' in tx && tx.blobVersionedHashes) {\n                            const blobHashes = tx.blobVersionedHashes;\n                            for(let j = 0; j < blobHashes.length; j++){\n                                if (blobHashes[j]?.toLowerCase() === blobHash.toLowerCase()) {\n                                    return {\n                                        exists: true,\n                                        blobData: {\n                                            txHash: tx.hash || 'Unknown',\n                                            blockNumber: blockNumber,\n                                            blobIndex: j,\n                                            etherscanUrl: `https://sepolia.etherscan.io/blob/${blobHash}`\n                                        }\n                                    };\n                                }\n                            }\n                        }\n                    }\n                } catch (blockError) {\n                    continue;\n                }\n            }\n            // Method 3: Try to get transaction receipt by searching for blob events\n            // This is a fallback method that might work on some RPCs\n            try {\n                const filter = {\n                    fromBlock: currentBlock - 1000,\n                    toBlock: 'latest',\n                    topics: [\n                        '0x' + ethers__WEBPACK_IMPORTED_MODULE_1__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes('LogRevealSpec(address,bytes32,bytes32,bytes32,address,uint256)')).slice(2, 10)\n                    ]\n                };\n                const logs = await this.provider.getLogs(filter);\n                for (const log of logs){\n                    if (log.topics && log.topics.length >= 3) {\n                        const logBlobHash = log.topics[2]; // blobHash is the third topic\n                        if (logBlobHash.toLowerCase() === blobHash.toLowerCase()) {\n                            return {\n                                exists: true,\n                                blobData: {\n                                    txHash: log.transactionHash,\n                                    blockNumber: log.blockNumber,\n                                    blobIndex: 0,\n                                    etherscanUrl: `https://sepolia.etherscan.io/blob/${blobHash}`\n                                }\n                            };\n                        }\n                    }\n                }\n            } catch (logError) {\n                console.log('Log search failed:', logError);\n            }\n            return {\n                exists: false\n            };\n        } catch (error) {\n            console.error('Error checking blob existence:', error);\n            throw new Error(`Failed to check blob existence: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    /**\n   * Validates multiple blob hashes at once\n   */ async validateMultipleBlobHashes(blobHashes) {\n        const results = new Map();\n        for (const blobHash of blobHashes){\n            const result = await this.validateBlobHash(blobHash);\n            results.set(blobHash, result);\n        }\n        return results;\n    }\n    /**\n   * Gets blob data from Etherscan API (alternative method)\n   */ async getBlobDataFromEtherscan(blobHash) {\n        try {\n            const response = await fetch(`https://api-sepolia.etherscan.io/api?module=proxy&action=eth_getTransactionByHash&txhash=${blobHash}`);\n            const data = await response.json();\n            if (data.result && data.result.blobVersionedHashes) {\n                return {\n                    exists: true,\n                    blobData: {\n                        txHash: data.result.hash,\n                        blockNumber: parseInt(data.result.blockNumber, 16),\n                        blobIndex: 0,\n                        etherscanUrl: `https://sepolia.etherscan.io/blob/${blobHash}`\n                    }\n                };\n            }\n            return {\n                exists: false\n            };\n        } catch (error) {\n            console.error('Etherscan API error:', error);\n            return {\n                exists: false\n            };\n        }\n    }\n}\n// Export singleton instance\nconst blobValidationService = new BlobValidationService();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvbGliL2Jsb2JWYWxpZGF0aW9uU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFnQztBQWN6QixNQUFNQztJQUdYLFlBQVlDLE1BQWUsQ0FBRTthQUZyQkMsV0FBbUU7UUFHekUsSUFBSUQsUUFBUTtZQUNWLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUlILG1EQUFzQixDQUFDRTtRQUM3QyxPQUFPLElBQUksS0FBeUQsRUFBRSxFQUVyRTtJQUNIO0lBRUE7O0dBRUMsR0FDRCxNQUFNTSxpQkFBaUJDLFFBQWdCLEVBQWlDO1FBQ3RFLElBQUk7WUFDRixrQ0FBa0M7WUFDbEMsTUFBTUMsbUJBQW1CLElBQUksQ0FBQ0Msc0JBQXNCLENBQUNGO1lBQ3JELElBQUksQ0FBQ0MsaUJBQWlCRSxPQUFPLEVBQUU7Z0JBQzdCLE9BQU9GO1lBQ1Q7WUFFQSx3Q0FBd0M7WUFDeEMsTUFBTUcsaUJBQWlCLE1BQU0sSUFBSSxDQUFDQyxlQUFlLENBQUNMO1lBQ2xELElBQUksQ0FBQ0ksZUFBZUUsTUFBTSxFQUFFO2dCQUMxQixPQUFPO29CQUNMSCxTQUFTO29CQUNURyxRQUFRO29CQUNSQyxPQUFPLENBQUMsVUFBVSxFQUFFUCxTQUFTOzs7OzJEQUlvQixDQUFDO2dCQUNwRDtZQUNGO1lBRUEsT0FBTztnQkFDTEcsU0FBUztnQkFDVEcsUUFBUTtnQkFDUkUsVUFBVUosZUFBZUksUUFBUTtZQUNuQztRQUVGLEVBQUUsT0FBT0QsT0FBTztZQUNkRSxRQUFRRixLQUFLLENBQUMsMEJBQTBCQTtZQUN4QyxPQUFPO2dCQUNMSixTQUFTO2dCQUNURyxRQUFRO2dCQUNSQyxPQUFPLENBQUMsbUJBQW1CLEVBQUVBLGlCQUFpQkcsUUFBUUgsTUFBTUksT0FBTyxHQUFHQyxPQUFPTCxRQUFRO1lBQ3ZGO1FBQ0Y7SUFDRjtJQUVBOztHQUVDLEdBQ0QsdUJBQStCUCxRQUFnQixFQUF3QjtRQUNyRSx5QkFBeUI7UUFDekIsSUFBSSxPQUFPQSxhQUFhLFVBQVU7WUFD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QUFNLENBQUNqQixJQUFJO3dCQUN4Qm5CLGFBQWEyQyxTQUFTRixLQUFLTCxNQUFNLENBQUNwQyxXQUFXLEVBQUU7d0JBQy9DQyxXQUFXO3dCQUNYQyxjQUFjLENBQUMsa0NBQWtDLEVBQUU1QixVQUFVO29CQUMvRDtnQkFDRjtZQUNGO1lBRUEsT0FBTztnQkFBRU0sUUFBUTtZQUFNO1FBQ3pCLEVBQUUsT0FBT0MsT0FBTztZQUNkRSxRQUFRRixLQUFLLENBQUMsd0JBQXdCQTtZQUN0QyxPQUFPO2dCQUFFRCxRQUFRO1lBQU07UUFDekI7SUFDRjtBQUNGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1nRSx3QkFBd0IsSUFBSTlFLHdCQUF3QiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpY2hhcmRoYS9Eb2N1bWVudHMv6Luf6auU5bel56iLL1Byb2plY3RzL0thaS1TaWduLUJ1aWxkZXIvZnJvbnRlbmQvc3JjL2xpYi9ibG9iVmFsaWRhdGlvblNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSBcImV0aGVyc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJsb2JWYWxpZGF0aW9uUmVzdWx0IHtcbiAgaXNWYWxpZDogYm9vbGVhbjtcbiAgZXhpc3RzOiBib29sZWFuO1xuICBlcnJvcj86IHN0cmluZztcbiAgYmxvYkRhdGE/OiB7XG4gICAgdHhIYXNoOiBzdHJpbmc7XG4gICAgYmxvY2tOdW1iZXI6IG51bWJlcjtcbiAgICBibG9iSW5kZXg6IG51bWJlcjtcbiAgICBldGhlcnNjYW5Vcmw6IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIEJsb2JWYWxpZGF0aW9uU2VydmljZSB7XG4gIHByaXZhdGUgcHJvdmlkZXI6IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIgfCBldGhlcnMuQnJvd3NlclByb3ZpZGVyIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IocnBjVXJsPzogc3RyaW5nKSB7XG4gICAgaWYgKHJwY1VybCkge1xuICAgICAgdGhpcy5wcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKHJwY1VybCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93IGFzIGFueSkuZXRoZXJldW0pIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgZXRoZXJzLkJyb3dzZXJQcm92aWRlcigod2luZG93IGFzIGFueSkuZXRoZXJldW0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYmxvYiBoYXNoIGZvcm1hdCBhbmQgY2hlY2tzIGlmIGl0IGV4aXN0cyBvbi1jaGFpblxuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGVCbG9iSGFzaChibG9iSGFzaDogc3RyaW5nKTogUHJvbWlzZTxCbG9iVmFsaWRhdGlvblJlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBTdGVwIDE6IEJhc2ljIGZvcm1hdCB2YWxpZGF0aW9uXG4gICAgICBjb25zdCBmb3JtYXRWYWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZUJsb2JIYXNoRm9ybWF0KGJsb2JIYXNoKTtcbiAgICAgIGlmICghZm9ybWF0VmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRWYWxpZGF0aW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGVwIDI6IENoZWNrIGlmIGJsb2IgZXhpc3RzIG9uLWNoYWluXG4gICAgICBjb25zdCBleGlzdGVuY2VDaGVjayA9IGF3YWl0IHRoaXMuY2hlY2tCbG9iRXhpc3RzKGJsb2JIYXNoKTtcbiAgICAgIGlmICghZXhpc3RlbmNlQ2hlY2suZXhpc3RzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgICAgZXhpc3RzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogYEJsb2IgaGFzaCAke2Jsb2JIYXNofSBkb2VzIG5vdCBleGlzdCBvbi1jaGFpbi4gVGhpcyBjb3VsZCBiZSBiZWNhdXNlOlxuMS4gVGhlIGJsb2Igd2FzIG5ldmVyIHBvc3RlZCB0byB0aGUgYmxvY2tjaGFpblxuMi4gVGhlIGJsb2IgaGFzaCBpcyBpbmNvcnJlY3RcbjMuIFRoZSBibG9iIHRyYW5zYWN0aW9uIGZhaWxlZCBvciB3YXMgcmV2ZXJ0ZWRcbjQuIFlvdSdyZSBjaGVja2luZyBvbiB0aGUgd3JvbmcgbmV0d29yayAoc2hvdWxkIGJlIFNlcG9saWEpYFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICBleGlzdHM6IHRydWUsXG4gICAgICAgIGJsb2JEYXRhOiBleGlzdGVuY2VDaGVjay5ibG9iRGF0YVxuICAgICAgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdCbG9iIHZhbGlkYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGV4aXN0czogZmFsc2UsXG4gICAgICAgIGVycm9yOiBgVmFsaWRhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWBcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgYmFzaWMgZm9ybWF0IG9mIGEgYmxvYiBoYXNoXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlQmxvYkhhc2hGb3JtYXQoYmxvYkhhc2g6IHN0cmluZyk6IEJsb2JWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICAvLyBDaGVjayBpZiBpdCdzIGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBibG9iSGFzaCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBleGlzdHM6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ0Jsb2IgaGFzaCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBpdCBzdGFydHMgd2l0aCAweDAxIChFSVAtNDg0NCBibG9iIHZlcnNpb24pXG4gICAgaWYgKCFibG9iSGFzaC5zdGFydHNXaXRoKCcweDAxJykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBleGlzdHM6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ0Jsb2IgaGFzaCBtdXN0IHN0YXJ0IHdpdGggMHgwMSAoRUlQLTQ4NDQgYmxvYiB2ZXJzaW9uKSdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgaXQncyBleGFjdGx5IDY2IGNoYXJhY3RlcnMgKDB4ICsgNjQgaGV4IGNoYXJzKVxuICAgIGlmIChibG9iSGFzaC5sZW5ndGggIT09IDY2KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXhpc3RzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBCbG9iIGhhc2ggbXVzdCBiZSBleGFjdGx5IDY2IGNoYXJhY3RlcnMgKGdvdCAke2Jsb2JIYXNoLmxlbmd0aH0pLiBFeHBlY3RlZCBmb3JtYXQ6IDB4MDEgKyA2NCBoZXggY2hhcmFjdGVyc2BcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgaXQgY29udGFpbnMgb25seSB2YWxpZCBoZXggY2hhcmFjdGVyc1xuICAgIGNvbnN0IGhleFJlZ2V4ID0gL14weDAxW2EtZkEtRjAtOV17NjR9JC87XG4gICAgaWYgKCFoZXhSZWdleC50ZXN0KGJsb2JIYXNoKSkge1xuICAgICAgLy8gRmluZCB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgZm9yIGJldHRlciBlcnJvciByZXBvcnRpbmdcbiAgICAgIGNvbnN0IGFmdGVyUHJlZml4ID0gYmxvYkhhc2guc3Vic3RyaW5nKDQpOyAvLyBSZW1vdmUgXCIweDAxXCJcbiAgICAgIGxldCBpbnZhbGlkQ2hhciA9ICcnO1xuICAgICAgbGV0IGludmFsaWRQb3MgPSAtMTtcbiAgICAgIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZnRlclByZWZpeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gYWZ0ZXJQcmVmaXhbaV07XG4gICAgICAgIGlmICghL1swLTlhLWZBLUZdLy50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgaW52YWxpZENoYXIgPSBjaGFyO1xuICAgICAgICAgIGludmFsaWRQb3MgPSBpICsgNDsgLy8gKzQgdG8gYWNjb3VudCBmb3IgXCIweDAxXCIgcHJlZml4XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gaW52YWxpZENoYXIgXG4gICAgICAgID8gYEludmFsaWQgY2hhcmFjdGVyICcke2ludmFsaWRDaGFyfScgYXQgcG9zaXRpb24gJHtpbnZhbGlkUG9zfS4gT25seSBoZXggY2hhcmFjdGVycyAoMC05LCBhLWYsIEEtRikgYXJlIGFsbG93ZWQgYWZ0ZXIgMHgwMWBcbiAgICAgICAgOiAnQmxvYiBoYXNoIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycy4gT25seSBoZXggY2hhcmFjdGVycyAoMC05LCBhLWYsIEEtRikgYXJlIGFsbG93ZWQgYWZ0ZXIgMHgwMSc7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBleGlzdHM6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBjb21tb24gaW52YWxpZCBwYXR0ZXJuc1xuICAgIGlmIChibG9iSGFzaCA9PT0gJzB4MDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGV4aXN0czogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnVGhpcyBpcyBhIHplcm8gYmxvYiBoYXNoIHdoaWNoIGlzIGludmFsaWQuIEJsb2IgaGFzaGVzIGNhbm5vdCBiZSBhbGwgemVyb3MuJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgdGhlIHNwZWNpZmljIGludmFsaWQgZXhhbXBsZSBtZW50aW9uZWRcbiAgICBpZiAoYmxvYkhhc2ggPT09ICcweDAxMDAwMDAwMDAwMDAnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXhpc3RzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdUaGlzIGJsb2IgaGFzaCBpcyB0b28gc2hvcnQgYW5kIGludmFsaWQuIFZhbGlkIGJsb2IgaGFzaGVzIG11c3QgYmUgNjYgY2hhcmFjdGVycyBsb25nIHN0YXJ0aW5nIHdpdGggMHgwMS4nXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgZXhpc3RzOiBmYWxzZSAvLyBXaWxsIGJlIGNoZWNrZWQgaW4gbmV4dCBzdGVwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBibG9iIGhhc2ggYWN0dWFsbHkgZXhpc3RzIG9uIHRoZSBibG9ja2NoYWluXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNoZWNrQmxvYkV4aXN0cyhibG9iSGFzaDogc3RyaW5nKTogUHJvbWlzZTx7IGV4aXN0czogYm9vbGVhbjsgYmxvYkRhdGE/OiBhbnkgfT4ge1xuICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwcm92aWRlciBhdmFpbGFibGUgZm9yIGJsb2NrY2hhaW4gcXVlcmllcycpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBNZXRob2QgMTogVHJ5IHRvIGdldCBibG9iIGRhdGEgdXNpbmcgZXRoX2dldEJsb2JCeUhhc2ggKGlmIHN1cHBvcnRlZClcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJsb2JEYXRhID0gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKCdldGhfZ2V0QmxvYkJ5SGFzaCcsIFtibG9iSGFzaF0pO1xuICAgICAgICBpZiAoYmxvYkRhdGEgJiYgYmxvYkRhdGEgIT09ICcweCcpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXhpc3RzOiB0cnVlLFxuICAgICAgICAgICAgYmxvYkRhdGE6IHtcbiAgICAgICAgICAgICAgdHhIYXNoOiAnVW5rbm93bicsXG4gICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiAwLFxuICAgICAgICAgICAgICBibG9iSW5kZXg6IDAsXG4gICAgICAgICAgICAgIGV0aGVyc2NhblVybDogYGh0dHBzOi8vc2Vwb2xpYS5ldGhlcnNjYW4uaW8vYmxvYi8ke2Jsb2JIYXNofWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChibG9iRXJyb3IpIHtcbiAgICAgICAgLy8gZXRoX2dldEJsb2JCeUhhc2ggbWlnaHQgbm90IGJlIHN1cHBvcnRlZCBieSBhbGwgUlBDc1xuICAgICAgICBjb25zb2xlLmxvZygnZXRoX2dldEJsb2JCeUhhc2ggbm90IHN1cHBvcnRlZCwgdHJ5aW5nIGFsdGVybmF0aXZlIG1ldGhvZHMnKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWV0aG9kIDI6IFNlYXJjaCBmb3IgYmxvYiB0cmFuc2FjdGlvbnMgaW4gcmVjZW50IGJsb2Nrc1xuICAgICAgY29uc3QgY3VycmVudEJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgY29uc3Qgc2VhcmNoQmxvY2tzID0gTWF0aC5taW4oMTAwMCwgY3VycmVudEJsb2NrKTsgLy8gU2VhcmNoIGxhc3QgMTAwMCBibG9ja3NcbiAgICAgIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWFyY2hCbG9ja3M7IGkgKz0gMTApIHsgLy8gQ2hlY2sgZXZlcnkgMTB0aCBibG9jayBmb3IgZWZmaWNpZW5jeVxuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGN1cnJlbnRCbG9jayAtIGk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKGJsb2NrTnVtYmVyLCB0cnVlKTtcbiAgICAgICAgICBpZiAoIWJsb2NrIHx8ICFibG9jay50cmFuc2FjdGlvbnMpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgZm9yIChjb25zdCB0eCBvZiBibG9jay50cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eCAmJiB0eXBlb2YgdHggPT09ICdvYmplY3QnICYmICd0eXBlJyBpbiB0eCAmJiB0eC50eXBlID09PSAzICYmICdibG9iVmVyc2lvbmVkSGFzaGVzJyBpbiB0eCAmJiB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJsb2JIYXNoZXMgPSB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzIGFzIHN0cmluZ1tdO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2JIYXNoZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvYkhhc2hlc1tqXT8udG9Mb3dlckNhc2UoKSA9PT0gYmxvYkhhc2gudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBibG9iRGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgIHR4SGFzaDogKHR4IGFzIGFueSkuaGFzaCB8fCAnVW5rbm93bicsXG4gICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgIGJsb2JJbmRleDogaixcbiAgICAgICAgICAgICAgICAgICAgICBldGhlcnNjYW5Vcmw6IGBodHRwczovL3NlcG9saWEuZXRoZXJzY2FuLmlvL2Jsb2IvJHtibG9iSGFzaH1gXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChibG9ja0Vycm9yKSB7XG4gICAgICAgICAgLy8gU2tpcCBibG9ja3MgdGhhdCBjYW4ndCBiZSBmZXRjaGVkXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTWV0aG9kIDM6IFRyeSB0byBnZXQgdHJhbnNhY3Rpb24gcmVjZWlwdCBieSBzZWFyY2hpbmcgZm9yIGJsb2IgZXZlbnRzXG4gICAgICAvLyBUaGlzIGlzIGEgZmFsbGJhY2sgbWV0aG9kIHRoYXQgbWlnaHQgd29yayBvbiBzb21lIFJQQ3NcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICBmcm9tQmxvY2s6IGN1cnJlbnRCbG9jayAtIDEwMDAsXG4gICAgICAgICAgdG9CbG9jazogJ2xhdGVzdCcsXG4gICAgICAgICAgdG9waWNzOiBbXG4gICAgICAgICAgICAnMHgnICsgZXRoZXJzLmtlY2NhazI1NihldGhlcnMudG9VdGY4Qnl0ZXMoJ0xvZ1JldmVhbFNwZWMoYWRkcmVzcyxieXRlczMyLGJ5dGVzMzIsYnl0ZXMzMixhZGRyZXNzLHVpbnQyNTYpJykpLnNsaWNlKDIsIDEwKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBsb2dzID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRMb2dzKGZpbHRlcik7XG4gICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3MpIHtcbiAgICAgICAgICBpZiAobG9nLnRvcGljcyAmJiBsb2cudG9waWNzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICBjb25zdCBsb2dCbG9iSGFzaCA9IGxvZy50b3BpY3NbMl07IC8vIGJsb2JIYXNoIGlzIHRoZSB0aGlyZCB0b3BpY1xuICAgICAgICAgICAgaWYgKGxvZ0Jsb2JIYXNoLnRvTG93ZXJDYXNlKCkgPT09IGJsb2JIYXNoLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBleGlzdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgYmxvYkRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHR4SGFzaDogbG9nLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgICBibG9iSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgICBldGhlcnNjYW5Vcmw6IGBodHRwczovL3NlcG9saWEuZXRoZXJzY2FuLmlvL2Jsb2IvJHtibG9iSGFzaH1gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAobG9nRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0xvZyBzZWFyY2ggZmFpbGVkOicsIGxvZ0Vycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZXhpc3RzOiBmYWxzZSB9O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGJsb2IgZXhpc3RlbmNlOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNoZWNrIGJsb2IgZXhpc3RlbmNlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIG11bHRpcGxlIGJsb2IgaGFzaGVzIGF0IG9uY2VcbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlTXVsdGlwbGVCbG9iSGFzaGVzKGJsb2JIYXNoZXM6IHN0cmluZ1tdKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBCbG9iVmFsaWRhdGlvblJlc3VsdD4+IHtcbiAgICBjb25zdCByZXN1bHRzID0gbmV3IE1hcDxzdHJpbmcsIEJsb2JWYWxpZGF0aW9uUmVzdWx0PigpO1xuICAgIFxuICAgIGZvciAoY29uc3QgYmxvYkhhc2ggb2YgYmxvYkhhc2hlcykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy52YWxpZGF0ZUJsb2JIYXNoKGJsb2JIYXNoKTtcbiAgICAgIHJlc3VsdHMuc2V0KGJsb2JIYXNoLCByZXN1bHQpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGJsb2IgZGF0YSBmcm9tIEV0aGVyc2NhbiBBUEkgKGFsdGVybmF0aXZlIG1ldGhvZClcbiAgICovXG4gIGFzeW5jIGdldEJsb2JEYXRhRnJvbUV0aGVyc2NhbihibG9iSGFzaDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9hcGktc2Vwb2xpYS5ldGhlcnNjYW4uaW8vYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJnR4aGFzaD0ke2Jsb2JIYXNofWApO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEucmVzdWx0ICYmIGRhdGEucmVzdWx0LmJsb2JWZXJzaW9uZWRIYXNoZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleGlzdHM6IHRydWUsXG4gICAgICAgICAgYmxvYkRhdGE6IHtcbiAgICAgICAgICAgIHR4SGFzaDogZGF0YS5yZXN1bHQuaGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBwYXJzZUludChkYXRhLnJlc3VsdC5ibG9ja051bWJlciwgMTYpLFxuICAgICAgICAgICAgYmxvYkluZGV4OiAwLFxuICAgICAgICAgICAgZXRoZXJzY2FuVXJsOiBgaHR0cHM6Ly9zZXBvbGlhLmV0aGVyc2Nhbi5pby9ibG9iLyR7YmxvYkhhc2h9YFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHsgZXhpc3RzOiBmYWxzZSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFdGhlcnNjYW4gQVBJIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGJsb2JWYWxpZGF0aW9uU2VydmljZSA9IG5ldyBCbG9iVmFsaWRhdGlvblNlcnZpY2UoKTtcbiJdLCJuYW1lcyI6WyJldGhlcnMiLCJCbG9iVmFsaWRhdGlvblNlcnZpY2UiLCJycGNVcmwiLCJwcm92aWRlciIsIkpzb25ScGNQcm92aWRlciIsIndpbmRvdyIsImV0aGVyZXVtIiwiQnJvd3NlclByb3ZpZGVyIiwidmFsaWRhdGVCbG9iSGFzaCIsImJsb2JIYXNoIiwiZm9ybWF0VmFsaWRhdGlvbiIsInZhbGlkYXRlQmxvYkhhc2hGb3JtYXQiLCJpc1ZhbGlkIiwiZXhpc3RlbmNlQ2hlY2siLCJjaGVja0Jsb2JFeGlzdHMiLCJleGlzdHMiLCJlcnJvciIsImJsb2JEYXRhIiwiY29uc29sZSIsIkVycm9yIiwibWVzc2FnZSIsIlN0cmluZyIsInN0YXJ0c1dpdGgiLCJsZW5ndGgiLCJoZXhSZWdleCIsInRlc3QiLCJhZnRlclByZWZpeCIsInN1YnN0cmluZyIsImludmFsaWRDaGFyIiwiaW52YWxpZFBvcyIsImkiLCJjaGFyIiwiZXJyb3JNZXNzYWdlIiwic2VuZCIsInR4SGFzaCIsImJsb2NrTnVtYmVyIiwiYmxvYkluZGV4IiwiZXRoZXJzY2FuVXJsIiwiYmxvYkVycm9yIiwibG9nIiwiY3VycmVudEJsb2NrIiwiZ2V0QmxvY2tOdW1iZXIiLCJzZWFyY2hCbG9ja3MiLCJNYXRoIiwibWluIiwiYmxvY2siLCJnZXRCbG9jayIsInRyYW5zYWN0aW9ucyIsInR4IiwidHlwZSIsImJsb2JWZXJzaW9uZWRIYXNoZXMiLCJibG9iSGFzaGVzIiwiaiIsInRvTG93ZXJDYXNlIiwiaGFzaCIsImJsb2NrRXJyb3IiLCJmaWx0ZXIiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwidG9waWNzIiwia2VjY2FrMjU2IiwidG9VdGY4Qnl0ZXMiLCJzbGljZSIsImxvZ3MiLCJnZXRMb2dzIiwibG9nQmxvYkhhc2giLCJ0cmFuc2FjdGlvbkhhc2giLCJsb2dFcnJvciIsInZhbGlkYXRlTXVsdGlwbGVCbG9iSGFzaGVzIiwicmVzdWx0cyIsIk1hcCIsInJlc3VsdCIsInNldCIsImdldEJsb2JEYXRhRnJvbUV0aGVyc2NhbiIsInJlc3BvbnNlIiwiZmV0Y2giLCJkYXRhIiwianNvbiIsInBhcnNlSW50IiwiYmxvYlZhbGlkYXRpb25TZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/lib/blobValidationService.ts\n");

/***/ })

};
;